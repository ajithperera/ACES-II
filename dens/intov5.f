      SUBROUTINE INTOV5(IAI,ICORE,MAXCOR,IUHF,bRedundant)
C
C THIS ROUTINE COMPUTES THE CONTRACTION
C
C    Z(a,i) =   SUM  <em||fi> Gamma(em,fa)
C               mef
C
C FOR THE FOLLOWING SPIN CASES:
C
C    Z(A,I) =   SUM  <EM||FI> Gamma(EM,FA) + SUM <eM|fI> Gamma(eM,fA)
C               MEF       (AAA)              eMf       (BAB)
C
C             + SUM  <Em|If>  Gamma(Em,Af)   [RHF and UHF]
C               Emf   (ABB)
C    
C               
C    Z(a,i) =   SUM  <em||fi> Gamma(em,fa) + SUM <Em|Fi> Gamma(Em,Fa)
C               mef       (BBB)              EmF       (ABA)
C
C             + SUM  <eM|iF> Gamma(eM,aF)   [UHF only]
C               eMF   (BAA)
C
C
C USING BOTH IN-CORE AND OUT-OF-CORE ALGORITHMS.
C
C SPIN ADAPTION HAS BEEN ADDED :
C
C   Z(A,I) = SUM [ 2*<eM||fI> - <Em||fI>] Gamma(eM,fA)
C
C           + SUM [ 2*<Em||fI> - <eM||fI>] Gamma(Em,fA)
C
CEND
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION ONE,ALPHA,BETA,IAI,ONEM,TWO
      DIMENSION IOFFOV(8),IOFFSM(8,4),IAI(1)
      LOGICAL INCORE,RHF,bRedundant
      DIMENSION ICORE(MAXCOR),FULLAB(8)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON/SYMPOP2/IRPDPD(8,22)
      COMMON/SYMPOP/IRP_DM(8,22),ISYTYP(2,500),NTOT(18) 
      COMMON /SYM2/ POP(8,2),VRT(8,2),NT(2),NFEA(2),NFMI(2)
      COMMON /SHIFT/ ISHIFT 
      common /dropgeo/ ndrgeo
      COMMON /INFO/ NOCCO(2),NVRTO(2)
      DATA ONE   /1.0/
      DATA ONEM  /-1.0/
      DATA TWO /2.0D0/
C
C  FOR UHF RESORT FIRST SOME INTEGRALS
C
      IF(IUHF.EQ.1) CALL NWRNGAA(ICORE,MAXCOR,IUHF)
C
      RHF=.FALSE.
      IF(IUHF.EQ.0)RHF=.TRUE.
      IAIOFF=1
      ALPHA=ONE
      BETA=ONE
      DO 10 ISPIN=1,1+IUHF
       TARSIZ=NT(ISPIN)
       CALL IZERO(ICORE,TARSIZ*IINTFP)
       IOFFOV(1)=1
       DO 11 IRREP=1,NIRREP-1
        IOFFOV(IRREP+1)=IOFFOV(IRREP)+POP(IRREP,ISPIN)*
     &                    VRT(IRREP,ISPIN)*IINTFP
11     CONTINUE
C
C THIS PART CAN BE SKIPPED FOR RHF 
C
       IF(.NOT.RHF) THEN
C
C SPIN CASES AAA AND BBB
C
C    Z(A,I) =   SUM  <EM||FI> Gamma(EM,FA) (ISPIN=1) 
C               MEF   
C
C    Z(A,I) =   SUM  <em||fi> Gamma(em,fa) (ISPIN=2)
C               mef   
C
C FILL OUT FULLAB VECTOR 
C
       CALL IZERO(FULLAB,NIRREP)
       DO 1000 IRREP=1,NIRREP
        DO 1001 IRREP1=1,NIRREP
         IRREP2=DIRPRD(IRREP1,IRREP)
         FULLAB(IRREP)=FULLAB(IRREP)+VRT(IRREP1,ISPIN)*
     &                 VRT(IRREP2,ISPIN) 
1001    CONTINUE
1000   CONTINUE
C
C SET THINGS UP
C
       LISTI=22+ISPIN + ISHIFT 
       LISTG=126+ISPIN
       DO 20 IRREPDO=1,NIRREP
        GAMDSZ=IRPDPD(IRREPDO,ISYTYP(1,LISTG))
        GAMDIS=IRPDPD(IRREPDO,ISYTYP(2,LISTG)) 
        INTDSZ=IRPDPD(IRREPDO,ISYTYP(1,LISTI))
        INTDIS=IRPDPD(IRREPDO,ISYTYP(2,LISTI))
        FULLSZ=FULLAB(IRREPDO)
C
C SEE IF THERE IS SUFFICIENT CORE TO DO THIS WITH AN INCORE ALGORITHM.
C  THE ALGORITHM USED HERE IS A GENERALIZATION OF A PUBLISHED METHOD.
C  [SEE J.F. STANTON, J. GAUSS, J.D. WATTS AND R.J. BARTLETT,
C                  JCP XX, XXXX (1991)].
C
        INEED=INTDIS*INTDSZ+GAMDIS*FULLSZ+TARSIZ
     &        +3*MAX(GAMDSZ,INTDSZ)
        INCORE = (INEED.LE.MAXCOR/IINTFP)
C
C ALLOCATE CORE FOR TARGET AND INTEGRAL MATRICES.
C
        I000=1
        I010=I000+TARSIZ*IINTFP
        I020=I010+INTDSZ*INTDIS*IINTFP
C
C DO IN-CORE ALGORITHM IF POSSIBLE
C
        IF(INCORE)THEN 
         I030=I020+FULLSZ*GAMDIS*IINTFP
         I040=I030+GAMDSZ
         if (ndrgeo.eq.0) then
           CALL GETTRN(ICORE(I020),ICORE(I030),GAMDSZ,
     &                               GAMDIS,2,IRREPDO,LISTG) 
         else
           CALL GETGOV5TU(ICORE(I020),ICORE(I030),GAMDSZ,
     &                               GAMDIS,2,IRREPDO,LISTG,ispin) 
         endif 
C
C MATRIX RETURNED FROM THIS CALL IS Gamma(EM;F<A) [Gamma(em;f<a)],
C    WE NEED TO EXPAND THIS TO F,A [f,a].
C     
         CALL SYMEXP(IRREPDO,VRT(1,ISPIN),GAMDIS,ICORE(I020))
C
C NOW REDEFINE GAMDIS AND GAMDSZ TO REFER TO THE MATRIX WHICH IS HELD
C   (Gamma(EM,FA) [Gamma(em;fa)] 
C
         GAMDSZ=GAMDIS
         GAMDIS=FULLSZ
C
C NOW READ IN THE INTEGRALS.
C
         CALL GETLST(ICORE(I010),1,INTDIS,2,IRREPDO,LISTI)
C
C NOW WE HAVE SOMETHING NICE.  THE INTEGRALS ARE ORDERED
C 
C     <EM||FI>   E,M ; F,I   [<em||fi> e,m ; f,i]
C
C  AND THE GAMMAS
C
C     G(EM,FA)   E,M ; F,A   [G(em,fa) e,m ; f,a]
C
C AND WE CAN IMMEDIATELY GENERATE THE TARGET Z(A,I) [Z(a,i)] WITH NIRREP
C  MATRIX MULTIPLIES.  
C
        IOFFZ=I000
        IOFFI=I010
        IOFFG=I020
        DO 30 IRREPAI=1,NIRREP
C
C FIRST FIGURE OUT THE DIMENSIONS OF THE
C  MATRICES G(EMF;A) AND I(EMF;I) FOR EACH IRREP.
C
         NROWG=GAMDSZ*VRT(DIRPRD(IRREPAI,IRREPDO),ISPIN)
         NROWI=NROWG
         NCOLG=VRT(IRREPAI,ISPIN)
         NCOLI=POP(IRREPAI,ISPIN)
C
C DO MATRIX MULTIPLY TO FORM THIS CONTRIBUTION TO Z(A,I) AND ACCUMULATE.
C
         IF(MIN(NCOLI,NCOLG,NROWG).NE.0)THEN
          CALL XGEMM('T','N',NCOLG,NCOLI,NROWG,ALPHA,ICORE(IOFFG),
     &               NROWG,ICORE(IOFFI),NROWI,BETA,ICORE(IOFFZ),
     &               NCOLG)
         ENDIF
         IOFFI=IOFFI+NCOLI*NROWI*IINTFP
         IOFFG=IOFFG+NCOLG*NROWG*IINTFP
         IOFFZ=IOFFZ+NCOLG*NCOLI*IINTFP
30      CONTINUE
       ELSEIF(.NOT.INCORE)THEN
C
C OUT-OF-CORE ALGORITHM FOR THIS IRREP.  FIRST READ IN INTEGRALS.
C
        CALL GETLST(ICORE(I010),1,INTDIS,2,IRREPDO,LISTI)
C----------- for drop--mo ----------
C Make a space -- INDXG in GETINO4U -- for drop-mo business.
C Make another space -- NRDISG in GETINO4U -- for drop-mo business.
C
        IF (NDRGEO.NE.0) THEN 
          IINDXG = I020 
          ITMP = IINDXG + GAMDIS + 1 + mod((gamdis+1),2)
          I020 = ITMP + IINTFP*GAMDSZ + 2 
        ENDIF 
C-----------------------------------
C
C DETERMINE HOW MANY LOGICAL RECORDS OF GAMMAS CAN BE HELD IN CORE
C  SIMULTANEOUSLY.
C
        ILEFT=MAXCOR-I020
        NUMIN=ILEFT/(FULLSZ*IINTFP)
C
C NOW DETERMINE HOW MANY PASSES MUST BE MADE TO PROCESS ALL INTEGRALS.
C
        NPASS=GAMDIS/NUMIN
        NLAST=GAMDIS
        IF(GAMDIS.NE.NPASS*NUMIN)THEN
         NLAST=GAMDIS-NPASS*NUMIN
         NPASS=NPASS+1
        ENDIF
c---------- for drop--mo -----------
c    pre-requisit for the out-of-core jobs in drop-mo case
c
      IF (NDRGEO.NE.0) THEN
        CALL GETINO4U(ICORE(IINDXG),GAMDIS,GAMDSZ,LISTG,IRREPDO,ISPIN)
        NIKI = 1
        IFIRDR = 1
      ENDIF 
c---------- for drop--mo -----------
C
C LOOP OVER PASSES
C
        DO 40 IPASS=1,NPASS
         IOFFZ=0  
         IOFFIL=0
         IOFFIR=0
         IF(IPASS.NE.NPASS)THEN
          NUMGET=NUMIN
         ELSE
          NUMGET=NLAST
         ENDIF
         IFIRST=1+(IPASS-1)*NUMIN
C
C PICK UP A LOAD OF GAMMAS AND EXPAND THEM TO
C
C         G(FA,EM) F,A ; E,M
C
         if (ndrgeo.eq.0) then 
              CALL GETLST(ICORE(I020),IFIRST,NUMGET,2,IRREPDO,LISTG)
         else 
           CALL GETGO4UO(ICORE(I020),ICORE(ITMP),IFIRDR,NUMGET,2,
     x                    IRREPDO,LISTG,
     x                    ispin,listi,gamdsz,ICORE(IINDXG),NIKI)
         endif 
         CALL SYMEXP2(IRREPDO,VRT(1,ISPIN),FULLSZ,GAMDSZ,NUMGET,
     &                ICORE(I020),ICORE(I020))
C
C NOW PROCESS ALL E,M PAIRS WHICH ARE IN CORE.  THE
C  MATRIX MULTIPLY WHICH IS PERFORMED IS 
C                       t        
C                 G(F,A) x I(F,I)
C
C FOR EACH EM.
C
         ITHRU=0
         DO 50 INUMEM=IFIRST,IFIRST+NUMGET-1
          ITHRU=ITHRU+1
          IOFFIR=I010+IINTFP*INTDSZ*(INUMEM-1)
          IOFFGR=I020+IINTFP*FULLSZ*(ITHRU-1)
          IOFFIL=0
          IOFFGL=0
          DO 51 IRREPI=1,NIRREP
           IRREPF=DIRPRD(IRREPI,IRREPDO)
           IRREPA=IRREPI
           IOFFI =IOFFIR+IOFFIL
           IOFFG =IOFFGR+IOFFGL
           IOFFZ =IOFFOV(IRREPI)
           NROW  =VRT(IRREPA,ISPIN)
           NCOL  =POP(IRREPI,ISPIN)
           NSUM  =VRT(IRREPF,ISPIN)
           IF(MIN(NROW,NCOL,NSUM).GT.0)THEN
            CALL XGEMM('T','N',NROW,NCOL,NSUM,ALPHA,ICORE(IOFFG),NSUM,
     &                 ICORE(IOFFI),NSUM,BETA,ICORE(IOFFZ),NROW)
           ENDIF
           IOFFIL=IOFFIL+NCOL*NSUM*IINTFP
           IOFFGL=IOFFGL+NROW*NSUM*IINTFP
51        CONTINUE
50       CONTINUE
40      CONTINUE
       ENDIF
20    CONTINUE
      ENDIF
C
C SPIN CASES ABB AND BAA
C
C    Z(A,I) =   SUM  <Em|If>  Gamma(Em,Af)   (ISPIN=1)
C               mEn   (AAB)
C
C    Z(a,i) =   SUM  <eM|iF>  Gamma(eM,aF)   (ISPIN=1)
C               mEn   (AAB)
c!@#$%
      LISTI=20+ISPIN + ISHIFT 
      LISTI2=25 + ISHIFT 
      LISTG=131-ISPIN
      DO 120 IRREPDO=1,NIRREP
       GAMDSZ=IRPDPD(IRREPDO,ISYTYP(1,LISTG))
       GAMDIS=IRPDPD(IRREPDO,ISYTYP(2,LISTG))
       INTDSZ=IRPDPD(IRREPDO,ISYTYP(1,LISTI))
       INTDIS=IRPDPD(IRREPDO,ISYTYP(2,LISTI))
C
C SEE IF THERE IS SUFFICIENT CORE FOR INCORE ALGORITHM.
C
       INEED=INTDIS*INTDSZ+GAMDIS*GAMDSZ+TARSIZ+3*MAX(GAMDIS,GAMDSZ)
       INCORE = (INEED.LE.MAXCOR/IINTFP)
C
C ALLOCATE CORE FOR THE TARGET AND INTEGRAL MATRICES
C
       I000=1
       I010=I000+TARSIZ*IINTFP
       I020=I010+INTDSZ*INTDIS*IINTFP
C
C DO IN-CORE ALGORITHM
C
       IF(INCORE)THEN
C
C NOW READ THE INTEGRALS
C
        IF(bRedundant) THEN
          CALL GETLST(ICORE(I010),1,INTDIS,2,IRREPDO,LISTI)
        ELSE
          CALL GETLST_NR(ICORE(I010),ICORE(I020),MAXCOR-I020,
     &                   LISTI,IRREPDO)
        ENDIF
           

C
C  SPIN ADAPT FOR RHF
C
        IF(RHF) THEN
         CALL SSCAL(INTDIS*INTDSZ,TWO,ICORE(I010),1)
         I030=I020+IINTFP*INTDIS*INTDSZ
         IF(I030.GE.MAXCOR) STOP 'INTOV5'
         CALL GETLST(ICORE(I020),1,INTDIS,2,IRREPDO,LISTI2)

         CALL SAXPY(INTDIS*INTDSZ,ONEM,ICORE(I020),1,ICORE(I010),1)
        ENDIF
C
        I030=I020+GAMDSZ*GAMDIS*IINTFP
        I040=I030+GAMDSZ
        if (ndrgeo.eq.0) then
           CALL GETTRN(ICORE(I020),ICORE(I030),GAMDSZ,
     &                            GAMDIS,2,IRREPDO,LISTG)
        else 
         if (iuhf.eq.1 .and. ispin.eq.2) then 
           CALL GETGOV5TR(ICORE(I020),ICORE(I030),GAMDSZ,
     &                                   GAMDIS,2,IRREPDO,LISTG,ispin)
         else 
           CALL GETGOV5T(ICORE(I020),ICORE(I030),GAMDSZ,
     &                                   GAMDIS,2,IRREPDO,LISTG,ispin)
         endif 
        endif 
C
C MATRIX RETURNED FROM THIS CALL IS :
C
C         Gamma(Em,Af) E,m ; A,f (ISPIN=1)
C         Gamma(Me,Fa) M,e ; F,a (ISPIN=2)
C
C REDEFINE GAMDIS AND GAMDSZ TO REFER TO THIS STORAGE MODE.
C
        ITMP=GAMDIS
        GAMDIS=GAMDSZ
        GAMDSZ=ITMP
C
C TRANSPOSE KET SIDE TO MAKE A THE SLOWEST INDEX IF ISPIN = 1.
C  THIS GIVES
C
C         Gamma(Em,fA) (ISPIN=1)
C 
C
        IF(ISPIN.EQ.1)THEN
         I040=I030+GAMDSZ*IINTFP
         I050=I040+GAMDSZ*IINTFP
         I060=I050+GAMDSZ*IINTFP
         CALL SYMTR1(IRREPDO,VRT(1,1),VRT(1,2),GAMDSZ,ICORE(I020),
     &               ICORE(I030),ICORE(I040),ICORE(I050))
        ENDIF
C
C INTEGRALS ARE ALREADY READ IN HERE, PREPARE THEM FOR THE MULTIPLICATION
C MATRIX RETURNED FROM THIS CALL IS :
C
C         I(Em;fI) (ISPIN=1)
C         I(eM;Fi) (ISPIN=2)
C
C
C NOW WE HAVE:
C
C        I(Em;fI) AND Gamma(Em,fA) (ISPIN=1)
C        I(eM;Fi) AND Gamma(Me,Fa) (ISPIN=2)
C
C FOR ISPIN=2 WE NEED TO TRANSPOSE THE BRA SIDE OF THE INTEGRALS.
C
        IF(ISPIN.EQ.2)THEN
         I040=I030+IINTFP*INTDIS
         I050=I040+IINTFP*INTDIS
         CALL SYMTR3(IRREPDO,VRT(1,2),POP(1,1),INTDSZ,INTDIS,
     &               ICORE(I010),ICORE(I030),ICORE(I040),
     &               ICORE(I050))
        ENDIF
C
C NOW WE HAVE
C        
C        I(Em;fI) AND Gamma(Em,fA) (ISPIN=1)
C        I(Me;Fi) AND Gamma(Me,Fa) (ISPIN=2)
C       
C AND THE PRODUCT CAN BE FORMED.
C
        IOFFZ=I000
        IOFFI=I010
        IOFFG=I020
        DO 130 IRREPAI=1,NIRREP
C
C FIRST FIGURE OUT THE DIMENSIONS OF THE
C  MATRICES G(EMF,A) AND I(EMF,I) FOR EACH IRREP.
C
         NROWG=GAMDSZ*VRT(DIRPRD(IRREPAI,IRREPDO),3-ISPIN)
         NROWI=NROWG
         NCOLG=VRT(IRREPAI,ISPIN)
         NCOLI=POP(IRREPAI,ISPIN)
C
C DO MATRIX MULTIPLY AND ACCUMULATE
C
         CALL XGEMM('T','N',NCOLG,NCOLI,NROWG,ALPHA,ICORE(IOFFG),
     &              NROWG,ICORE(IOFFI),NROWI,BETA,ICORE(IOFFZ),
     &              NCOLG)
         IOFFI=IOFFI+NCOLI*NROWI*IINTFP
         IOFFG=IOFFG+NCOLG*NROWG*IINTFP
         IOFFZ=IOFFZ+NCOLG*NCOLI*IINTFP
130     CONTINUE
       ELSEIF(.NOT.INCORE)THEN
C
C OUT-OF-CORE ALGORITHM FOR THIS IRREP.  
C
C
C GET OFFSET INFORMATION
C
        CALL SYMOFF(IOFFSM,IRREPDO)
C
C READ IN INTEGRALS.
C
        LISTI=23-ISPIN + ISHIFT 
        LISTI2=25 + ISHIFT 
        IF(RHF)LISTI=21 + ISHIFT 
        INTDSZ=IRPDPD(IRREPDO,ISYTYP(1,LISTI))
        INTDIS=IRPDPD(IRREPDO,ISYTYP(2,LISTI))
        IF (bRedundant) THEN
           CALL GETLST(ICORE(I010),1,INTDIS,2,IRREPDO,LISTI)
        ELSE
           CALL GETLST_NR(ICORE(I010),ICORE(I020),MAXCOR-I020,
     &                    LISTI,IRREPDO)
        END IF

C
C  SPIN ADAPT FOR RHF
C
        IF(RHF) THEN
         CALL SSCAL(INTDIS*INTDSZ,TWO,ICORE(I010),1)
         I030=I020+IINTFP*INTDIS*INTDSZ
         IF(I030.GE.MAXCOR) STOP 'INTOV5'
         CALL GETLST(ICORE(I020),1,INTDIS,2,IRREPDO,LISTI2)
         CALL SAXPY(INTDIS*INTDSZ,ONEM,ICORE(I020),1,ICORE(I010),1)
        ENDIF
C
C INTEGRALS ARE
C
C         I(fI;Em) (ISPIN=1)
C         I(Fi;eM) (ISPIN=2)
C
C AND KET PART MUST BE TRANSPOSED IF ISPIN=2.
C
        IF(ISPIN.EQ.2)THEN
         I030=I020+INTDSZ*IINTFP
         I040=I030+INTDSZ*IINTFP
         I050=I040+INTDSZ*IINTFP
         CALL SYMTR1(IRREPDO,VRT(1,2),POP(1,1),INTDSZ,
     &               ICORE(I010),ICORE(I030),ICORE(I040),
     &               ICORE(I050))
        ENDIF
C-------------- for drop--mo -------------
C Make a space -- INDXG in GETINO4(R) -- for drop-mo business.
C Make another space -- NRDISG in GETINO4(R) -- for drop-mo business.
C
        IF (NDRGEO.NE.0) THEN 
          IINDXG = I020 
          ITMP = IINDXG + GAMDIS + 1 +mod((gamdis+1),2)
          I020 = ITMP + IINTFP*GAMDSZ + 2
        ENDIF 
c----------------------------------------
C
C DETERMINE HOW MANY LOGICAL RECORDS OF GAMMAS CAN BE HELD IN CORE
C  SIMULTANEOUSLY.
C
        ILEFT=MAXCOR-I020
        NUMIN=ILEFT/(GAMDSZ*IINTFP)
C
C NOW DETERMINE HOW MANY PASSES MUST BE MADE TO PROCESS ALL INTEGRALS.
C
        NPASS=GAMDIS/NUMIN
        NLAST=GAMDIS
        IF(GAMDIS.NE.NPASS*NUMIN)THEN
         NLAST=GAMDIS-NPASS*NUMIN
         NPASS=NPASS+1
        ENDIF
C-------------- for drop--mo -------------
c    pre-requisit for the out-of-core jobs in drop-mo case
c
      IF (NDRGEO.NE.0) THEN
        if (iuhf.eq.1 .and. ispin.eq.2) then 
         CALL GETINO4R(ICORE(IINDXG),GAMDIS,GAMDSZ,LISTG,IRREPDO)
        else 
         CALL GETINO4 (ICORE(IINDXG),GAMDIS,GAMDSZ,LISTG,IRREPDO)
        endif 
        NIKI = 1
        IFIRDR = 1
      ENDIF 
c----------------------------------------
C
C LOOP OVER PASSES
C
        DO 140 IPASS=1,NPASS
         IOFFIL=0
         IOFFIR=0
         IF(IPASS.NE.NPASS)THEN
          NUMGET=NUMIN
         ELSE
          NUMGET=NLAST
         ENDIF
         IFIRST=1+(IPASS-1)*NUMIN
C
C PICK UP A LOAD OF GAMMAS.
C
C         Gamma(Af,Em) (ISPIN=1)
C         Gamma(Fa,Me) (ISPIN=2)
C
         if (ndrgeo.eq.0) then 
            CALL GETLST(ICORE(I020),IFIRST,NUMGET,2,IRREPDO,LISTG)
         else 
            CALL GETGO4O (ICORE(I020),ICORE(ITMP),IFIRDR,NUMGET,2,
     x                       IRREPDO,LISTG,
     x                       ispin,listi,gamdsz,ICORE(IINDXG),NIKI)
         endif 
C
C WE HAVE
C
C        I(fI;Em) AND Gamma(Af,Em) (ISPIN=1)
C        I(Fi;Me) AND Gamma(Fa,Me) (ISPIN=2)
C
C NOW PROCESS ALL E,m [M,e] PAIRS WHICH ARE IN CORE, USING
C                  
C             G(A,f) x I(f,I)  (ISPIN=1)
C                   t
C             G(F,a) x I(F,i)  (ISPIN=2)
C
C MATRIX MULTIPLIES FOR EACH E,m [M,e].
C
         ITHRU=0
         DO 150 INUMEM=IFIRST,IFIRST+NUMGET-1
          ITHRU=ITHRU+1
          IOFFIR=I010+IINTFP*INTDSZ*(INUMEM-1)
          IOFFGR=I020+IINTFP*GAMDSZ*(ITHRU-1)
          IOFFGL=0
          IF(ISPIN.EQ.1)THEN
           DO 151 IRREPF=1,NIRREP
            IRREPI=DIRPRD(IRREPF,IRREPDO)
            IRREPA=IRREPI
            IOFFI =IOFFIR+IOFFSM(IRREPI,3)*IINTFP
            IOFFG =IOFFGR+IOFFGL
            IOFFZ =IOFFOV(IRREPI)
            NROW  =VRT(IRREPA,1)
            NCOL  =POP(IRREPI,1)
            NSUM  =VRT(IRREPF,2)
            IF(MIN(NROW,NCOL,NSUM).GT.0)THEN
             CALL XGEMM('N','N',NROW,NCOL,NSUM,ALPHA,ICORE(IOFFG),NROW,
     &                  ICORE(IOFFI),NSUM,BETA,ICORE(IOFFZ),NROW)
            ENDIF
            IOFFGL=IOFFGL+NROW*NSUM*IINTFP
151        CONTINUE
          ELSE
           DO 152 IRREPA=1,NIRREP
            IRREPF=DIRPRD(IRREPA,IRREPDO)
            IRREPI=IRREPA
            IOFFI =IOFFIR+IOFFSM(IRREPI,4)*IINTFP 
            IOFFG =IOFFGR+IOFFGL
            IOFFZ =IOFFOV(IRREPI)
            NROW  =VRT(IRREPA,2)
            NCOL  =POP(IRREPI,2)
            NSUM  =VRT(IRREPF,1)
            IF(MIN(NROW,NCOL,NSUM).GT.0)THEN
             CALL XGEMM('T','N',NROW,NCOL,NSUM,ALPHA,ICORE(IOFFG),NSUM,
     &                  ICORE(IOFFI),NSUM,BETA,ICORE(IOFFZ),NROW)
            ENDIF
            IOFFGL=IOFFGL+NROW*NSUM*IINTFP
152        CONTINUE
          ENDIF
150      CONTINUE
140     CONTINUE
       ENDIF
120   CONTINUE
C
C SPIN CASES ABA AND BAB
C
C    Z(A,I) =   SUM <eM|fI> Gamma(eM,fA)  (ISPIN = 1)
C               eMf 
C
C    Z(a,i) =   SUM <Em|Fi> Gamma(Em,Fa)  (ISPIN = 2)
C               EmF
C
      LISTI=27-ISPIN + ISHIFT 
      LISTI2=21 + ISHIFT 
      IF(RHF)LISTI=25 + ISHIFT 
      LISTG=128+ISPIN
      IF(RHF)LISTG=130

      DO 220 IRREPDO=1,NIRREP
       GAMDSZ=IRPDPD(IRREPDO,ISYTYP(1,LISTG))
       GAMDIS=IRPDPD(IRREPDO,ISYTYP(2,LISTG))
       INTDSZ=IRPDPD(IRREPDO,ISYTYP(1,LISTI))
       INTDIS=IRPDPD(IRREPDO,ISYTYP(2,LISTI))
C
C SEE IF THERE IS SUFFICIENT CORE FOR INCORE ALGORITHM.
C
       INEED=INTDIS*INTDSZ+GAMDIS*GAMDSZ+TARSIZ
       INCORE = (INEED.LE.MAXCOR/IINTFP)
C
C ALLOCATE CORE FOR THE TARGET AND INTEGRAL MATRICES
C
       I000=1
       I010=I000+TARSIZ*IINTFP
       I020=I010+INTDSZ*INTDIS*IINTFP
C
C NOW READ THE INTEGRALS
C
        CALL GETLST(ICORE(I010),1,INTDIS,2,IRREPDO,LISTI)
C
C SPIN ADAPT FOR RHF
C
        IF(RHF) THEN
         CALL SSCAL(INTDIS*INTDSZ,TWO,ICORE(I010),1)
         I030=I020+IINTFP*INTDIS*INTDSZ
         IF(I030.GE.MAXCOR) STOP'INTOV5'
         IF(bRedundant) THEN
           CALL GETLST(ICORE(I020),1,INTDIS,2,IRREPDO,LISTI2)
         ELSE
           CALL GETLST_NR(ICORE(I020),ICORE(I030),MAXCOR-I030,
     &                LISTI2,IRREPDO)
         ENDIF
         CALL SAXPY(INTDIS*INTDSZ,ONEM,ICORE(I020),1,ICORE(I010),1)
        ENDIF
C
C DO IN-CORE ALGORITHM
C
       IF(INCORE)THEN
        I030=I020+GAMDSZ*GAMDIS*IINTFP
        I040=I030+GAMDSZ
C
        if (ndrgeo.eq.0) then
          CALL GETTRN(ICORE(I020),ICORE(I030),GAMDSZ,
     &                               GAMDIS,2,IRREPDO,LISTG)
        else  
         if (iuhf.eq.1 .and. ispin.eq.1) then 
          CALL GETGOV5TR(ICORE(I020),ICORE(I030),GAMDSZ,
     &                               GAMDIS,2,IRREPDO,LISTG,ispin)
         else  
          CALL GETGOV5T(ICORE(I020),ICORE(I030),GAMDSZ,
     &                               GAMDIS,2,IRREPDO,LISTG,ispin)
         endif 
        endif 
C
C MATRIX RETURNED FROM THIS CALL IS :
C
C         Gamma(Me,Af)  (ISPIN=1)
C         Gamma(Em;Fa)  (ISPIN=2 OR RHF)
C
C REDEFINE GAMDIS AND GAMDSZ TO REFER TO THIS STORAGE MODE.
C
        ITMP=GAMDIS
        GAMDIS=GAMDSZ
        GAMDSZ=ITMP
C
C TRANSPOSE BRA AND KET SIDES TO MAKE A SLOWEST INDEX IF ISPIN=1
C
C THIS GIVES US
C
C         Gamma(eM;fA)  (ISPIN=1)
C         Gamma(Em;Fa)  (ISPIN=2 OR RHF)
C
        IF(ISPIN.EQ.1.AND..NOT.RHF)THEN
         I040=I030+MAX(GAMDIS,GAMDSZ)*IINTFP
         I050=I040+MAX(GAMDIS,GAMDSZ)*IINTFP
         I060=I050+MAX(GAMDIS,GAMDSZ)*IINTFP
         CALL SYMTR1(IRREPDO,VRT(1,1),VRT(1,2),GAMDSZ,ICORE(I020),
     &               ICORE(I030),ICORE(I040),ICORE(I050))
         CALL SYMTR3(IRREPDO,POP(1,1),VRT(1,2),GAMDSZ,GAMDIS,
     &               ICORE(I020),ICORE(I030),ICORE(I040),ICORE(I050))
        ENDIF
C
C INTEGRALS ARE ALREADY READ IN
C MATRIX RETURNED FROM THIS CALL IS :
C
C         I(eM;fI) (ISPIN=1)
C         I(Em;Fi) (ISPIN=2 OR RHF)
C
C
C NOW WE HAVE:
C
C        I(eM;fI) AND Gamma(eM;fA) (ISPIN=1)
C        I(Em;Fi) AND Gamma(Em;Fi) (ISPIN=2 OR RHF)
C
C AND THE PRODUCT CAN BE FORMED.
C
        IOFFZ=I000
        IOFFI=I010
        IOFFG=I020
        DO 230 IRREPAI=1,NIRREP
C
C FIRST FIGURE OUT THE DIMENSIONS OF THE
C  MATRICES G(EMF,A) AND I(EMF,I) FOR EACH IRREP.
C
         NROWG=GAMDSZ*VRT(DIRPRD(IRREPAI,IRREPDO),3-ISPIN)
         NROWI=NROWG
         NCOLG=VRT(IRREPAI,ISPIN)
         NCOLI=POP(IRREPAI,ISPIN)
C
C DO MATRIX MULTIPLY AND ACCUMULATE
C
         CALL XGEMM('T','N',NCOLG,NCOLI,NROWG,ALPHA,ICORE(IOFFG),
     &              NROWG,ICORE(IOFFI),NROWI,BETA,ICORE(IOFFZ),
     &              NCOLG)
         IOFFI=IOFFI+NCOLI*NROWI*IINTFP
         IOFFG=IOFFG+NCOLG*NROWG*IINTFP
         IOFFZ=IOFFZ+NCOLG*NCOLI*IINTFP
230     CONTINUE
       ELSEIF(.NOT.INCORE)THEN
C
C GET OFFSET INFORMATION
C
        CALL SYMOFF(IOFFSM,IRREPDO)
C
C OUT-OF-CORE ALGORITHM FOR THIS IRREP. INTEGRALS ARE ALREADY READ IN.
C INTEGRALS ARE
C
C         I(fI;eM) (ISPIN=1)
C         I(Fi;Em) (ISPIN=2 OR RHF)
C
C AND KET PART MUST BE TRANSPOSED IF ISPIN=1.
C
        IF(ISPIN.EQ.1.AND..NOT.RHF)THEN
         I030=I020+INTDSZ*IINTFP
         I040=I030+INTDSZ*IINTFP
         I050=I040+INTDSZ*IINTFP
         CALL SYMTR1(IRREPDO,VRT(1,2),POP(1,1),INTDSZ,
     &               ICORE(I010),ICORE(I030),ICORE(I040),
     &               ICORE(I050))
        ENDIF
C----------  for drop--mo  -----------
C Make a space -- INDXG in GETINO4(R) -- for drop-mo business.
C Make another space -- NRDISG in GETINO4(R) -- for drop-mo business.
C
        IF (NDRGEO.NE.0) THEN 
          IINDXG = I020 
          ITMP = IINDXG + GAMDIS + 1 +mod((gamdis+1),2)
          I020 = ITMP + IINTFP*GAMDSZ + 2
        ENDIF 
c-------------------------------------
C
C DETERMINE HOW MANY LOGICAL RECORDS OF GAMMAS CAN BE HELD IN CORE
C  SIMULTANEOUSLY.
C
        ILEFT=MAXCOR-I020
        NUMIN=ILEFT/(GAMDSZ*IINTFP)
C
C NOW DETERMINE HOW MANY PASSES MUST BE MADE TO PROCESS ALL INTEGRALS.
C
        NPASS=GAMDIS/NUMIN
        NLAST=GAMDIS
        IF(GAMDIS.NE.NPASS*NUMIN)THEN
         NLAST=GAMDIS-NPASS*NUMIN
         NPASS=NPASS+1
        ENDIF
C----------  for drop--mo  -----------
c
c    pre-requisit for the out-of-core jobs in drop-mo case
c
      IF (NDRGEO.NE.0) THEN
        if (iuhf.eq.1 .and. ispin.eq.1) then 
         CALL GETINO4R(ICORE(IINDXG),GAMDIS,GAMDSZ,LISTG,IRREPDO)
        else 
         CALL GETINO4 (ICORE(IINDXG),GAMDIS,GAMDSZ,LISTG,IRREPDO)
        endif 
        NIKI = 1
        IFIRDR = 1
      ENDIF 
c-------------------------------------
C
C LOOP OVER PASSES
C
        DO 240 IPASS=1,NPASS
         IOFFZ=0  
         IOFFIL=0
         IOFFIR=0
         IF(IPASS.NE.NPASS)THEN
          NUMGET=NUMIN
         ELSE
          NUMGET=NLAST
         ENDIF
         IFIRST=1+(IPASS-1)*NUMIN
C
C         Gamma(Af;Me) (ISPIN=1)
C         Gamma(Fa;Em) (ISPIN=2 OR RHF)
C
         if (ndrgeo.eq.0) then 
            CALL GETLST(ICORE(I020),IFIRST,NUMGET,2,IRREPDO,LISTG)
         else  
           CALL GETGO4O(ICORE(I020),ICORE(ITMP),IFIRDR,NUMGET,2,
     x                       IRREPDO,LISTG,
     x                       ispin,listi,gamdsz,ICORE(IINDXG),NIKI)
         endif 
C
C WE HAVE
C
C        I(fI;Me) AND Gamma(Af;Me) (ISPIN=1)
C        I(Fi;Em) AND Gamma(Fa;Em) (ISPIN=2 OR RHF)
C
C NOW PROCESS ALL M,e [E,m] PAIRS WHICH ARE IN CORE
C
         ITHRU=0
         DO 250 INUMME=IFIRST,IFIRST+NUMGET-1
          ITHRU=ITHRU+1
          IOFFIR=I010+IINTFP*INTDSZ*(INUMME-1)
          IOFFGR=I020+IINTFP*GAMDSZ*(ITHRU-1)
          IOFFGL=0
          IF(ISPIN.EQ.1.AND..NOT.RHF)THEN
           DO 251 IRREPF=1,NIRREP
            IRREPI=DIRPRD(IRREPF,IRREPDO)
            IRREPA=IRREPI
            IOFFI =IOFFIR+IOFFSM(IRREPI,3)*IINTFP
            IOFFG =IOFFGR+IOFFGL
            IOFFZ =IOFFOV(IRREPI)
            NROW  =VRT(IRREPA,1)
            NCOL  =POP(IRREPI,1)
            NSUM  =VRT(IRREPF,2)
            IF(MIN(NROW,NCOL,NSUM).GT.0)THEN
             CALL XGEMM('N','N',NROW,NCOL,NSUM,ALPHA,ICORE(IOFFG),NROW,
     &                  ICORE(IOFFI),NSUM,BETA,ICORE(IOFFZ),NROW)
            ENDIF
            IOFFGL=IOFFGL+NROW*NSUM*IINTFP
251        CONTINUE
          ELSE
           DO 252 IRREPI=1,NIRREP
            IRREPF=DIRPRD(IRREPI,IRREPDO)
            IRREPA=IRREPI
            IOFFI =IOFFIR+IOFFSM(IRREPI,4)*IINTFP
            IOFFG =IOFFGR+IOFFGL
            IOFFZ =IOFFOV(IRREPI)
            NROW  =VRT(IRREPA,2)
            NCOL  =POP(IRREPI,2)
            NSUM  =VRT(IRREPF,1)
            IF(MIN(NROW,NCOL,NSUM).GT.0)THEN
             CALL XGEMM('T','N',NROW,NCOL,NSUM,ALPHA,ICORE(IOFFG),NSUM,
     &                  ICORE(IOFFI),NSUM,BETA,ICORE(IOFFZ),NROW)
            ENDIF
            IOFFGL=IOFFGL+NROW*NSUM*IINTFP
252        CONTINUE
          ENDIF
250      CONTINUE
240     CONTINUE
       ENDIF
220   CONTINUE
C
C NOW INCREMENT XIA.
C
      CALL SAXPY(TARSIZ,ONEM,ICORE(I000),1,IAI(IAIOFF),1)
      IAIOFF=IAIOFF+TARSIZ
10    CONTINUE
C
C  FOR UHF RESORT SOME INTEGRALS
C
      IF(IUHF.EQ.1) CALL NWRNGAA(ICORE,MAXCOR,IUHF)
C
      RETURN
      END
