      SUBROUTINE XIA3AA(G,W,MAXSIZE,XIA,FACT,ISPIN,POP,VRT,DISSYT,
     &                  NUMSYT,DISSYW,NUMSYW,LISTG,LISTW,IRREP,TMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT,DISSYW,DISMAX,DISLEFT,DISREAD,DIRPRD,POP,VRT
      DIMENSION G(DISSYT,1),W(DISSYW,1),XIA(1),POP(8),VRT(8),TMP(1),
     &          IPT(8)
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
      common /dropgeo/ ndrgeo
C
      DATA ONEM,ONE,HALF /-1.0D0,1.D0,0.5D0/
C
C  PICK UP THE G-AMPLITUDES AND THE INTEGRALS
C
      if (ndrgeo.eq.0) then
        CALL GETLST(G,1,NUMSYT,1,IRREP,LISTG)
      else   
        CALL GETGO1U(G,W,1,NUMSYT,1,IRREP,LISTG,ispin,listg,dissyt)
      endif 
C
C  EXPAND THE OCCUPIED-OCCUPIED BLOCK OF THE AMPLITUDES
C
      CALL SYMEXP(IRREP,POP,DISSYT,G)
C
C  DECIDE WHICH ALGORITHM BY CHECKING MAXSIZE
C
      IF(MAXSIZE.GT.NUMSYW*DISSYW) THEN
       CALL GETLST(W,1,NUMSYW,2,IRREP,LISTW)
       CALL SYMTR1(IRREP,VRT,POP,DISSYW,W,TMP,TMP(1+DISSYW),
     &             TMP(1+2*DISSYW))
C
C  PERFORM MULTIPLICATION
C
C  JOFFG OFFSET IN G
C  JOFFW OFFSET IN W
C  IOFF OFFSET IN XIA
C
       JOFFG=1
       JOFFW=1
       IOFF=1
       DO 90 IRREPJ=1,NIRREP
C          
C  GET OCCUPATION NUMBER FOR JRREP     
C
        NOCCJ=POP(IRREPJ)
        NVRTJ=VRT(IRREPJ)
C
C        DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH JRREP GIVES IRREP
C
        IRREPI=DIRPRD(IRREP,IRREPJ)
C
C  GET OCCUPATION NUMBER FOR IRREPI
C
        NOCCI=POP(IRREPI)
C
C  IF NOCCI, NOCCJ, OR NVRTJ EQUAL ZERO, NOTHING TO COMPUTE
C
        IF(MIN(NOCCJ,NOCCI,NVRTJ).NE.0) THEN
C
          CALL XGEMM('T','N',NVRTJ,NOCCJ,DISSYT*NOCCI,FACT,
     &               W(1,JOFFW),NOCCI*DISSYT,G(1,JOFFG),      
     &               NOCCI*DISSYT,ONE,XIA(IOFF),NVRTJ)
        ENDIF
C
C UPDATE THE OFFSETS
C
        JOFFG=JOFFG+NOCCJ*NOCCI
        JOFFW=JOFFW+NOCCI*NVRTJ
        IOFF=IOFF+NOCCJ*NVRTJ
90     CONTINUE
C
      ELSE
C
C OUT OF CORE ALGORITHM 
C
C  DETERMINE FIRST OFFSETS WITHIN THE XIA INTERMEDIATE
C
       IPT(1)=1
       DO 150 IRREPJ=1,NIRREP-1
        IPT(IRREPJ+1)=IPT(IRREPJ)+POP(IRREPJ)*VRT(IRREPJ)
150    CONTINUE
C
C  DETERMINE MAXIMUM NUMBER OF DISTRIBUTIONS WHICH FIT INTO CORE
C
       MAXDIS=MAXSIZE/DISSYW
C
C  SET OFFSETS FOR INTEGRAL LIST AND G AMPLITUDES
C
       IOFFSET=1
       JOFFG=1
C
C  LOOP OVER THE IRREPS OF THE LAST INDEX
C
       DO 200 IRREPJ=1,NIRREP
C
        NOCCJ=POP(IRREPJ)
        IRREPI=DIRPRD(IRREP,IRREPJ)
        NOCCI=POP(IRREPI)
        NVRTI=VRT(IRREPI)
        IF(MIN(NOCCI,NVRTI,NOCCJ).NE.0) THEN
C
C DETERMINE NUMBER OF (E<F,A) BLOCKS WHICH CAN BE HELD IN CORE
C
         DISMAX=MAXDIS/NVRTI 
         IF(DISMAX.LE.0) STOP 'XIA3AA'
C
C NUMBER OF (E<F,A) BLOCKS TO READ
C
         DISLEFT=NOCCJ
C
10       CONTINUE
C
C NUMBER OF (E<F,A) BLOCKS WHICH ARE READ IN THIS PATH
C
          DISREAD=MIN(DISLEFT,DISMAX)
          DISLEFT=DISLEFT-DISREAD
C
C GET THE DISTRIBUTIONS FROM DISK
C
          CALL GETLST(W,IOFFSET,DISREAD*NVRTI,2,IRREP,LISTW)
C
C  UPDATE IOFFSET
C
          IOFFSET=IOFFSET+DISREAD*NVRTI
C
C  LOOP OVER ALL DISTRIBUTIONS AND PERFORM MULTIPLICATION
C
          JOFFW=1
          IOFF=IPT(IRREPI)
C
          DO 250 NUM=1,DISREAD
C
           CALL XGEMM('T','N',NVRTI,NOCCI,DISSYW,-FACT,
     &                W(1,JOFFW),DISSYT,G(1,JOFFG),DISSYW,
     &                ONE,XIA(IOFF),NVRTI)
C
C  UPDATE OFFSETS
C
           JOFFW=JOFFW+NVRTI
           JOFFG=JOFFG+NOCCI  
C
250       CONTINUE
C
C IF NOT ALL (E<F,A) BLOCKS HAVE BEEN PROCESSED, GO BACK TO 10
C
         IF(DISLEFT.NE.0) GO TO 10
C
        ELSE
C
C  UPDATE OFFSETS IN THE CASE NOTHING HAS BEEN DONE
C
         IOFFSET=IOFFSET+NOCCJ*NVRTI
         JOFFG=JOFFG+NOCCJ*NOCCI
        ENDIF
200    CONTINUE
C
      ENDIF
C
      RETURN
      END
