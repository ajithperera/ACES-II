      SUBROUTINE IOV1AA(G,W,T,AIOV,FACT,ISPIN,POP,VRT,DISSYT,NUMSYT,
     &                  DISSYW,NUMSYW,LISTG,LISTW,IRREP,TMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT,DISSYW,DIRPRD,POP,VRT
      DIMENSION T(DISSYT,1),G(NUMSYT,1),W(DISSYW,1),AIOV(1),
     &          POP(8),VRT(8),TMP(1)
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      common /dropgeo/ ndrgeo
C
      DATA ONE /1.D0/
C
C PICK UP THE G AMPLITUDES AND INTEGRALS REQUIRED
C
      if (ndrgeo.eq.0) CALL GETLST(T,1,NUMSYT,1,IRREP,LISTG)
      if (ndrgeo.eq.1) 
     x     CALL GETGO1U(T,G,1,NUMSYT,1,IRREP,LISTG,ispin,listg,dissyt)
      CALL TRANSP(T,G,NUMSYT,DISSYT)
      CALL SYMEXP(IRREP,VRT,NUMSYT,G)
      CALL GETLST(W,1,NUMSYW,2,IRREP,LISTW)   
      CALL SYMTR1(IRREP,POP,VRT,DISSYW,W,TMP,TMP(1+DISSYW),
     &            TMP(1+2*DISSYW))
      call checksum("intov1-aa-W",w,dissyw*numsyw)
      call checksum("intov1-aa-G",g,dissyt*numsyt)
C
C PERFORM MULTIPLICATION 
C
C JOFFG AND JOFFW OFFSET IN THE VIRTUAL-VIRTUAL BLOCK OF G AND W
C IOFF OFFSET IN IOV
C
      IOFF=1
      JOFFG=1
      JOFFW=1
      DO 90 IRREPJ=1,NIRREP
C          
C GET NUMBER OF VIRTUAL ORBITALS FOR IRREPJ     
C
       NOCCJ=POP(IRREPJ)
       NVRTJ=VRT(IRREPJ)
C
C DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH IRREPJ GIVES IRREP
C
       IRREPI=DIRPRD(IRREP,IRREPJ)
C
C GET NUMBER  OF VIRTUAL ORBITALS FOR IRREPI
C
       NVRTI=VRT(IRREPI)
C
C IF NVRTI OR NVRTJ EQUAL ZERO, NOTHING TO COMPUTE
C
       IF(MIN(NVRTI,NVRTJ,NOCCJ).NE.0) THEN
C
          CALL XGEMM('T','N',NVRTJ,NOCCJ,NVRTI*NUMSYT,FACT,
     &             G(1,JOFFG),NVRTI*NUMSYT,W(1,JOFFW),
     &             NVRTI*NUMSYT,ONE,AIOV(IOFF),NVRTJ)
       ENDIF
C
C  UPDATE OFFSETS
C
       JOFFG=JOFFG+NVRTI*NVRTJ
       JOFFW=JOFFW+NVRTI*NOCCJ
       IOFF=IOFF+NVRTJ*NOCCJ
90    CONTINUE
C
      RETURN
      END
