      SUBROUTINE IV5AB(G,W,T,AIVVA,AIVVB,FACT,ISPIN,POP1,POP2,VRT1,VRT2,
     &                  DISSYT,NUMSYT,DISSYW,NUMSYW,LISTG,LISTW,IRREP,
     &                  TMP,IUHF,NUMMAX)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT,DISSYW,DIRPRD,POP1,POP2,VRT1,VRT2
      DIMENSION G(1),W(1),T(DISSYW,1),AIVVA(1),
     &          AIVVB(1),TMP(1),POP1(8),POP2(8),VRT1(8),VRT2(8) 
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      common /dropgeo/ ndrgeo
C
      DATA ONE,ONEM,TWO /1.0D0,-1.D0,2.D0/
C
      IOFFSET=1
      NUMLEFT=NUMSYW
      ITIN = 1
      IF (NDRGEO.NE.0) THEN
        ITIN1 = ITIN 
        if (iuhf.eq.1 .and. ispin.eq.2) then 
         CALL GETINO4R(TMP(ITIN1),NUMSYT,DISSYT,LISTG,IRREP)
        else
         CALL GETINO4 (TMP(ITIN1),NUMSYT,DISSYT,LISTG,IRREP)
        endif 
        ITIN = ITIN1 + NUMSYT + 1 
        NIKI = 1
        IODRSET = 1
      ENDIF 
C
1      CONTINUE
C
C      PICK UP FIRST THE INTEGRALS
C      AND TRANSPOSE THEM
C
       NUMREAD=MIN(NUMLEFT,NUMMAX)
       NUMLEFT=NUMLEFT-NUMREAD
       CALL GETLST(T,IOFFSET,NUMREAD,2,IRREP,LISTW)
       CALL TRANSP(T,W,NUMREAD,DISSYW)
C
C  SPIN ADAPTED CODE FOR RHF
C
      IF(IUHF.EQ.0) THEN
       CALL SPINAD1(IRREP,VRT1,NUMREAD,W,TMP(ITIN),TMP(ITIN+NUMREAD))
      ENDIF
C
C PCIK UP G AMPLITUDES AND TRANSPOSE THEM
C
      if (ndrgeo.eq.0) then
        CALL GETLST(T,IOFFSET,NUMREAD,1,IRREP,LISTG)
      else 
        CALL GETGO4O(T,G,IODRSET,NUMREAD,1,IRREP,LISTG,
     x                  ispin,listg,dissyt,TMP(ITIN1),NIKI)  
      endif 
      IOFFSET=IOFFSET+NUMREAD
      CALL TRANSP(T,G,NUMREAD,DISSYT)
C
C  PERFORM MULTIPLICATION
C
C  JOFF OFFSET IN THE RIGHTMOST BLOCK OF G AND W
C  IOFF OFFSET IN AIVV
C
      IOFF=1
      JOFF=1
      DO 90 IRREPI=1,NIRREP
C          
C        GET NUMBER OF VIRTUAL ORBITALS FOR IRREPJ
C
       NVRTI=VRT2(IRREPI)
C
C        DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH IRREPJ GIVES IRREP
C
       IRREPJ=DIRPRD(IRREP,IRREPI)
C
C        GET NUMBER OF VIRTUAL ORBITALS FOR IRREPI
C
       NVRTJ=VRT1(IRREPJ)
C
C        IF NVRTJ OR NVRTI EQUAL ZERO, NOTHING TO COMPUTE
C
       IF(MIN(NVRTI,NVRTJ).NE.0) THEN
C
          CALL XGEMM('T','N',NVRTI,NVRTI,NUMREAD*NVRTJ,FACT,
     &               W(JOFF),NVRTJ*NUMREAD,G(JOFF),
     &               NVRTJ*NUMREAD,ONE,AIVVB(IOFF),NVRTI)
       ENDIF
C
C  UPDATE THE OFFSETS
C
       JOFF=JOFF+NVRTI*NVRTJ*NUMREAD
       IOFF=IOFF+NVRTI*NVRTI
90    CONTINUE
C
C
C  TRANSPOSE THE LAST TWO INDICES FOR THE AA CONTRIBUTION
C
        CALL SYMTR1(IRREP,VRT1,VRT2,NUMREAD,G,TMP(ITIN),
     &                    TMP(ITIN+NUMREAD),TMP(ITIN+2*NUMREAD))
        CALL SYMTR1(IRREP,VRT1,VRT2,NUMREAD,W,TMP(ITIN),
     &                    TMP(ITIN+NUMREAD),TMP(ITIN+2*NUMREAD))
C
C  PERFORM MULTIPLICATION
C
C  JOFF OFFSET IN THE RIGHTMOST BLOCK OF G AND W
C  IOFF OFFSET IN AIVV
C
      IOFF=1
      JOFF=1
      DO 190 IRREPI=1,NIRREP
C          
C        GET NUMBER OF VIRTUAL ORBITALS FOR IRREPJ
C
       NVRTI=VRT1(IRREPI)
C
C        DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH IRREPJ GIVES IRREP
C
       IRREPJ=DIRPRD(IRREP,IRREPI)
C
C        GET NUMBER OF VIRTUAL ORBITALS FOR IRREPI
C
       NVRTJ=VRT2(IRREPJ)
C
C        IF NVRTJ OR NVRTI EQUAL ZERO, NOTHING TO COMPUTE
C
       IF(MIN(NVRTI,NVRTJ).NE.0) THEN
C
          CALL XGEMM('T','N',NVRTI,NVRTI,NUMREAD*NVRTJ,FACT,
     &               W(JOFF),NVRTJ*NUMREAD,G(JOFF),
     &               NVRTJ*NUMREAD,ONE,AIVVA(IOFF),NVRTI)
       ENDIF
C
C  UPDATE THE OFFSETS
C
       JOFF=JOFF+NVRTI*NVRTJ*NUMREAD
       IOFF=IOFF+NVRTI*NVRTI
190    CONTINUE
      IF(NUMLEFT.NE.0) GO TO 1
      RETURN
      END
