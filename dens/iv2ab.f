      SUBROUTINE IV2AB(G,W,T,MAXDIS,AIVV,FACT,ISPIN,POP1,POP2,
     &                 VRT1,VRT2,DISSYT,NUMSYT,DISSYW,NUMSYW,
     &                 LISTG,LISTW,IRREP,TMP,IUHF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT,DISSYW,DIRPRD,POP1,POP2,VRT1,VRT2
      DIMENSION G(1),W(2),T(1),AIVV(1),TMP(1)
      DIMENSION POP1(8),POP2(8),VRT1(8),VRT2(8) 
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD  
      common /dropgeo/ ndrgeo
C
      DATA ONE,ONEM,HALF,TWO /1.0D0,-1.0D0,0.5D0,2.0D+0/
C
C      PICK UP FIRST THE G AMPLITUDES AND INTEGRALS
C
      ITIN = 1
      IOFFSET=1
      NTDIS=NUMSYT
      IF (NDRGEO.NE.0) THEN
        ITIN1 = ITIN 
        CALL GETINV2(TMP(ITIN1),NUMSYT,DISSYT,LISTG,IRREP)
        ITIN = ITIN1 + NUMSYT + 1 
        NIKI = 1
        IODRSET = 1
      ENDIF 
1     NRDIS=MIN(NTDIS,MAXDIS)
      NTDIS=NTDIS-NRDIS
C
      if (ndrgeo.eq.0) then
        CALL GETLST(T,IOFFSET,NRDIS,1,IRREP,LISTG)
      else
        CALL GETGV2O(T,G,IODRSET,NRDIS,1,IRREP,LISTG,ispin,LISTG,dissyt,
     x              TMP(ITIN1),NIKI)
      endif 
C
C  SPIN ADAPTED CODE FOR RHF
C
       IF(IUHF.EQ.0) THEN
C
        CALL SPINAD3(IRREP,VRT1,DISSYT,NRDIS,T,TMP(ITIN),
     x                                              TMP(ITIN+DISSYT))
       ENDIF
C
       CALL TRANSP(T,G,NRDIS,DISSYT)
C
       CALL GETLST(T,IOFFSET,NRDIS,2,IRREP,LISTW)
       CALL TRANSP(T,W,NRDIS,DISSYW)
C
C UPDATE IOFFSET
C
       IOFFSET=IOFFSET+NRDIS
C-------------------------------
C      Note that the IODRSET was updated in the getgv2o 
C-------------------------------
C
C  TRANSPOSE THE LAST TWO INDICES IN THE AA CASE
C
C  HOWEVER, IN RHF TAKE ADVANTAGE IF THE SPIN SYMMETRY
C
      IF(IUHF.EQ.1.AND.ISPIN.EQ.1) THEN
        CALL SYMTR1(IRREP,VRT1,VRT2,NRDIS,G,TMP(ITIN),TMP(ITIN+NRDIS),
     &              TMP(ITIN+2*NRDIS))
        CALL SYMTR1(IRREP,VRT1,VRT2,NRDIS,W,TMP(ITIN),TMP(ITIN+NRDIS),
     &              TMP(ITIN+2*NRDIS))
      ENDIF
C
C  PERFORM MULTIPLICATION
C
C  JOFF OFFSET IN THE VIRTUAL-VIRTUAL BLOCK OF G AND W
C  IOFF OFFSET IN AIVV
C
      IOFF=1
      JOFF=1
      DO 90 IRREPI=1,NIRREP
C          
C        GET NUMBER OF VIRTUAL ORBITALS FOR IRREPJ
C
       NVRTI=VRT1(IRREPI)
C
C        DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH IRREPJ GIVES IRREP
C
       IRREPJ=DIRPRD(IRREP,IRREPI)
C
C        GET NUMBER OF VIRTUAL ORBITALS FOR KRREP
C
       NVRTJ=VRT2(IRREPJ)
C
C        IF NVRTI OR NVRTJ EQUAL ZERO, NOTHING TO COMPUTE
C
       IF(MIN(NVRTJ,NVRTI).NE.0) THEN
C
          CALL XGEMM('T','N',NVRTI,NVRTI,NRDIS*NVRTJ,FACT,
     &               W(JOFF),NVRTJ*NRDIS,G(JOFF),
     &               NVRTJ*NRDIS,ONE,AIVV(IOFF),NVRTI)
       ENDIF
C
C  UPDATE THE OFFSETS
C
       JOFF=JOFF+NVRTJ*NVRTI*NRDIS
       IOFF=IOFF+NVRTI*NVRTI
90    CONTINUE
      IF(NTDIS.NE.0) GO TO 1
      RETURN
      END
