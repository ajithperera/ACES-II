      SUBROUTINE H4G6AB(H,H1,H2,G,G1,T1A,T1B,FACT,DISSYH1,DISSYH2,
     &                  DISSYG,NUMSYH1,NUMSYH2,NUMSYG,POP1,POP2,    
     &                  VRT1,VRT2,LISTH1,LISTH2,LISTG,ISPIN,IRREP,
     &                  IUHF,TMP,TRIP,LISTG1)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL TRIP,CIS,EOM,LTRP
      INTEGER DISSYH1,DISSYH2,DISSYG,DIRPRD,POP1,POP2,VRT1,VRT2
      DIMENSION H1(NUMSYH1,DISSYH2),H2(NUMSYH2,DISSYH2),H(1),
     &          G(NUMSYG,DISSYG),G1(DISSYG,NUMSYG),T1A(1),T1B(1),
     &          TMP(1),POP1(8),POP2(8),VRT1(8),VRT2(8) 
C
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON/EXCITE/CIS,EOM
      COMMON/LTRIP/LTRP
C
      DATA AZERO,ONE /0.D0,1.D0/
C
C  GET RESORTED H4 FROM DISK: FISRT THE H4(Fi,aK) INTERMEDIATES
C
      CALL GETLST(H,1,NUMSYH1,1,IRREP,LISTH1)
C
C  TRANPOSE H4 :     F,j ; a,K  ---->  a,K ; F,j
C
      CALL TRANSP(H,H1,NUMSYH1,DISSYH1)
C
C  ZERO OUTPUT ARRAY
C
      CALL ZERO(G,NUMSYG*DISSYG)
C
C  TRANSPOSE THE LAST TWO INDICES:  a,K ; F,j ---->  a,K ; j,F 
C
      CALL SYMTR1(IRREP,VRT1,POP2,NUMSYH1,H1,TMP,TMP(1+NUMSYH1),
     &             TMP(1+2*NUMSYH1))
C
C  LOOP OVER IRREPS OF F AND MULTIPLY WITH T1A
C
      IOFFH=1
      IOFFG=1
      IOFFT=1
      DO 100 IRREPJ=1,NIRREP
C
C  GET POPULATIONS
C
       NVRTJ=VRT1(IRREPJ)
       NOCCJ=POP1(IRREPJ)
       IRREPI=DIRPRD(IRREPJ,IRREP)
       NOCCI=POP2(IRREPI)
C
C IF ONE OF THE POPULATIONS IS ZERO, SKIP MULTIPLICATION 
C
       IF(MIN(NVRTJ,NOCCI,NOCCJ).NE.0) THEN
C
        CALL XGEMM('N','N',NUMSYH1*NOCCI,NOCCJ,NVRTJ,FACT,H1(1,IOFFH),
     &             NUMSYH1*NOCCI,T1A(IOFFT),NVRTJ,AZERO,G(1,IOFFG),
     &             NUMSYG*NOCCI)
       ENDIF
C
C UPDATE OFFSETS
C
       IOFFT=IOFFT+NOCCJ*NVRTJ
       IOFFG=IOFFG+NOCCI*NOCCJ
       IOFFH=IOFFH+NOCCI*NVRTJ
C
100    CONTINUE 
C
C  TRANSPOSE THE G LIST FOR SECOND CONTRACTION :    a,K ; j,I --> a,K ; I,j
C
       CALL SYMTR1(IRREP,POP2,POP1,NUMSYG,G,TMP,TMP(1+NUMSYG),
     &             TMP(1+2*NUMSYG))
C
C  GET SECOND H4 LIST : H4(fI,aK) INTERMEDIATE WITH ORDERING f,I;a,K
C
       CALL GETLST(H,1,NUMSYH2,1,IRREP,LISTH2)
C
C     TRANPOSE H4 : f,I ; a,K  ----> a,K ; f,I
C
       CALL TRANSP(H,H2,NUMSYH2,DISSYh2)
C
C   TRANPOSE THE LAST TWO INDICES OF H4 : a,K ; f,I  ---> a,K ; I,f
C
       CALL SYMTR1(IRREP,VRT2,POP1,NUMSYH2,H2,TMP,TMP(1+NUMSYH2),
     &             TMP(1+2*NUMSYH2))
C
C      PERFORM MULTIPLICATION WITH T1B
C
      IOFFG=1
      IOFFH=1
      IOFFT=1
      DO 200 IRREPJ=1,NIRREP
C
C  GET POPULATIONS FOR MULTIPLICATION
C
       NOCCJ=POP2(IRREPJ)
       NVRTJ=VRT2(IRREPJ)
       IRREPI=DIRPRD(IRREP,IRREPJ)
       NOCCI=POP1(IRREPI)
C
C  IF ONE OF THE POPULATIONS IS ZERO, SKIP THE MULTIPLICATION 
C
       IF(MIN(NOCCI,NOCCJ,NVRTJ).NE.0) THEN
C
        CALL XGEMM('N','N',NUMSYH2*NOCCI,NOCCJ,NVRTJ,FACT,H2(1,IOFFH),
     &             NUMSYH2*NOCCI,T1B(IOFFT),NVRTJ,ONE,G(1,IOFFG),
     &             NUMSYG*NOCCI)
C
       ENDIF
C
C   UPDATE OFFSETS
C
       IOFFT=IOFFT+NOCCJ*NVRTJ
       IOFFG=IOFFG+NOCCI*NOCCJ
       IOFFH=IOFFH+NOCCI*NVRTJ
C
200   CONTINUE
C
C  TRANSPOSE THE WHOLE G MATRIX : a,K ; I,j  -- --> I,j ; a,K
C
      IF(ISPIN.EQ.2) THEN
       CALL SYMTR1(IRREP,POP1,POP2,NUMSYG,G,TMP,TMP(1+NUMSYG),
     &             TMP(1+2*NUMSYG))
      ENDIF
C
       CALL TRANSP(G,G1,DISSYG,NUMSYG)
C
C  TRANPOSE LAST TWO INDICES IN G --> I,j ; K,a, BUT ONLY FOR ISPIN=1
C
       IF(ISPIN.EQ.1) THEN
        CALL SYMTR1(IRREP,VRT2,POP1,DISSYG,G1,TMP,TMP(1+DISSYG),
     &              TMP(1+2*DISSYG))
       ENDIF
C
C IN CASE OF TRIPLE EXCITATIONS, ADD HERE THEIR CONTRIBUTION
C
       IF(TRIP) THEN
        CALL GETLST(G,1,NUMSYG,1,IRREP,LISTG1)
        CALL SAXPY(NUMSYG*DISSYG,ONE,G,1,G1,1)
       ENDIF
       IF(EOM .OR. LTRP) THEN
        CALL GETLST(G,1,NUMSYG,1,IRREP,LISTG)
        CALL SAXPY(NUMSYG*DISSYG,ONE,G,1,G1,1)
       ENDIF
C
C SAVE GAMMA6 ON DISK
C
       CALL PUTLST(G1,1,NUMSYG,1,IRREP,LISTG)
C
C  ALL DONE, RETURN
C
       RETURN
       END
