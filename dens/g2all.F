      SUBROUTINE G2ALL(T1,T2,G,MAXSIZE,T1A,T1B,TAU,MBPT4,FACT,ISPIN,
     &                 ISAME,DISSYT,NUMSYT,LISTT1,LISTT2,LISTG,IRREP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL ISAME,TAU,MBPT4,CIS,EOM,LTRP
      INTEGER DISSYT,DISTMP,DISLEFT,DIRPRD,POP,VRT
      DIMENSION T1(DISSYT,NUMSYT),T2(DISSYT,NUMSYT),G(DISSYT,1),
     &          T1A(1),T1B(1)
      COMMON/SYM/POP(8,2),VRT(8,2),NTAA,NTBB,NF1AA,NF1BB,NF2AA,NF2BB
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
      COMMON /EXCITE/ CIS,EOM
      COMMON /LTRIP/ LTRP

#include "parcc.com"
C
      DATA AZERO,ONE,ONEM,TWO /0.0D0,1.D0,-1.D0,2.D0/
C
C PICK UP FIRST THE APPROBIATE T AMPLITUDES
C
      CALL GETLST(T1,1,NUMSYT,2,IRREP,LISTT1)

C This is W(mnij) and W(abef) scalling 
CSSS        If (Ispar) Then
CSSS           Write(6, "(a,F5.2)")" In G2AL (ABCD) setting T2 scalng to :",
CSSS     &                            Wmnij_scale
CSSS           Write(6,*)
CSSS           CALL DSCAL(NUMSYT*DISSYT, Wmnij_scale, T1, 1)
CSSS        Endif
CSSS#endif
C
C IN THE CASE THAT TAU AMPLITUDES ARE REQUIRED, THE AMPLITUDES
C FROM LISTT1 MUST BE MODIFIED
C
      IF(TAU) THEN
       IF(ISPIN.LT.3) THEN
        CALL FTAU(T1,T1A,T1B,DISSYT,NUMSYT,POP(1,ISPIN),POP(1,ISPIN),
     &            VRT(1,ISPIN),VRT(1,ISPIN),IRREP,ISPIN,ONE)
       ELSE
        CALL FTAU(T1,T1A,T1B,DISSYT,NUMSYT,POP(1,1),POP(1,2),VRT(1,1),
     &            VRT(1,2),IRREP,ISPIN,ONE)
       ENDIF
      ENDIF
C
C GET SECOND AMPLITUDES BUT NOT FOR MBPT(3) (ISAME = TRUE)
C
      IF(.NOT.ISAME)CALL GETLST(T2,1,NUMSYT,1,IRREP,LISTT2)
C
C FOR MBPT4 BUILD     2* T2 - T1
C
      IF(MBPT4) THEN
       CALL SSCAL(NUMSYT*DISSYT,TWO,T2,1)
       CALL SAXPY(NUMSYT*DISSYT,ONEM,T1,1,T2,1)
      ENDIF
C
C CHECK IF WE CAN DO IT IN CORE OR NOT
C
      IF(DISSYT.NE.0) THEN
       MAXDIS=MAXSIZE/DISSYT
      ELSE
       MAXDIS=DISSYT
      ENDIF
C
      IF(MAXDIS.GE.DISSYT) THEN
C
C EVERYTHING FITS INTO CORE 
C
C PERFORM THE MULTIPLICATION 
C 
       IF(EOM .OR. LTRP)THEN
        CALL GETLST(G,1,DISSYT,1,IRREP,LISTG)
        FACT2=ONE
       ELSE
        FACT2=AZERO
       ENDIF
C
       CALL XGEMM('N','T',DISSYT,DISSYT,NUMSYT,FACT,T1,DISSYT,
     &            T2,DISSYT,FACT2,G,DISSYT)
C
C     SAVE THE RESULT ON FILE
C
C SYMMETRIZE THE CALCULATED GAMMA INTERMEDIATE (NOT NECCESARY WHEN
C THE TWO LISTS ARE ACTUALLY THE SAME (ISAME = TRUE)
C
      IF(.NOT.ISAME) THEN
       CALL SYMMET2(G,DISSYT)
      ENDIF
C
      CALL PUTLST(G,1,DISSYT,1,IRREP,LISTG)
C
      ELSE
C
C OUT CORE ALGORITHM
C
      DISLEFT=DISSYT
      IOFFSET=1
10    CONTINUE
      DISTMP=MIN(MAXDIS,DISLEFT)
      DISLEFT=DISLEFT-DISTMP
C
      IF(EOM .OR. LTRP) THEN
       FACT2=ONE
       CALL GETLST(G,IOFFSET,DISTMP,1,IRREP,LISTG)
      ELSE
       FACT2=AZERO
      ENDIF
C
      CALL XGEMM('N','T',DISSYT,DISTMP,NUMSYT,FACT,T1,DISSYT,
     &           T2(IOFFSET,1),DISSYT,FACT2,G,DISSYT)
C
C SAVE THE RESULT ON FILE
C
      CALL PUTLST(G,IOFFSET,DISTMP,1,IRREP,LISTG)
      IOFFSET=IOFFSET+DISTMP
      IF(DISLEFT.NE.0) GO TO 10
C
C SYMMETRIZE THE CALCULATED GAMMA INTERMEDIATE ( NOT NECCESSARY
C WHEN THE TWO LISTS ARE ACTUALLY THE SAME (ISAME = TRUE)
C
      IF(.NOT.ISAME) THEN
       LENGTH=2*DISSYT*NUMSYT+MAXSIZE
       CALL SYMMET3(IRREP,LISTG,DISSYT,T1,LENGTH)
      ENDIF
C
      ENDIF
      RETURN
      END
