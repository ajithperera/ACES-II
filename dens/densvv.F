       SUBROUTINE DENSVV(DVV,ICORE,MAXCOR,IUHF)
C
C
C THIS ROUTINE CALCULATES THE VIRTUAL-VIRTUAL BLOCK
C OF THE RELAXED DENSITY MATRIX IN CORRELATION METHODS
C
C THE FORMULAS ARE
C
C D(A,B) = 1/2 SUM M,N,E T[1](MN,AE) T[1](MN,BE)              (MBPT(2))
C
C D(A,B) = 1/2 SUM M,N,E T[1](MN,AE) T[1](MN,BE)            
C
C          + SUM M T[1](M,A) T[1](M,B)                        (ROHF-MBPT(2))
C
C D(A,B) = 1/2 P(AB) SUM M,N,E T[1](MN,AE) (1/2 T[1](MN,BE)+T2(MN,BE)) 
C          
C                                                             (MBPT(3))
C
C D(A,B) =  1/4 P(AB) SUM M,N,E T[1](IM,EF) (L[2](JM,EF)+T[2](JM,EF))
C
C           1/2 SUM M,N,E T[1](IM,EF) T[1](JM,EF))
C
C           1/2 P(AB) SUM M T[1](M,A) (T[1](I,E) + L[2](M,B)+ T[2](M,B))
C
C                                                         (ROHF-MBPT(3))
C
C D(A,B) = SUM M T[2](M,A) T[2](M,B)
C
C          + 1/2 SUM M,N,E {T[1](MN,AE)+T[2](MN,AE)}{T[2](MN,BE)+T[1](MN,BE)}
C         
C          + 1/2 P(AB) SUM M,N,E T[1](MN,AE) ( T[3](MN,BE) 
C 
C                                            + 1/2 X(MN,BE))
C
C          + 1/12 SUM M,N,O,E,F T[2](MNO,AEF) T[2](MNO,BEF)     (MBPT(4))
C
C D(A,B) = 1/4 P(AB) SUM M,N,E T(MN,AE) LAMBDA(MN,BE)       (CCD)
C
C D(A,B) = 1/4 P(AB) SUM M,N,E T(MN,AE) LAMNDA(MN,BE)
C
C          + 1/2 P(AB) SUM N T(M,A) LAMBDA(M,B)             (CCSD, QCISD)
C     
C D(A,B) = 1/4 P(AB) SUM M,N,E T(MN,AE) T(MN,BE)
C
C          + 1/2 P(AB) SUM N T(M,A) T(M,B)                    (UCC)
C 
C 
C THERE ARE THE FOLLOWING SPIN TYPES TO CONSIDER
C
C          D(AB)                T(MN,AE),....
C
C          AA                   AAAA, ABAB
C
C          BB                   BBBB, BABA
C
C THIS SUBROUTINE USES EXPLICITELY SYMMETRY
C
C THE TRIPLES CONTRIBUTION IS CALCULATED IN TRPS AND HERE SIMPLY
C ADDED TO THE REMAINING TERMS.
C
C IN THE RHF CASE EXPLICIT SPIN ADAPTED CODE IS USED
C
CEND
C
C CODED   JULY/90    JG
C
C EXTENDED FOR ROHF-MBPT(3), DECEMBER 92
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DIRPRD,DISSYT,POP,VRT
      LOGICAL MBPT4,CC
      LOGICAL MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC
      LOGICAL DENS,GRAD,QRHF,NONHF,ROHF,SEMI,CANON,TRIP1,TRIP2,
     &        GABCD,RELAXED,TRULY_NONHF
C
      DIMENSION ICORE(MAXCOR),DVV(1)
C
      COMMON/SYM/POP(8,2),VRT(8,2),NTAA,NTBB,NF1(2),NF2(2)
      COMMON/INFO/NOCCO(2),NVRTO(2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/FLAGS/IFLAGS(100)
      COMMON/METH/MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC
      COMMON/DERIV/DENS,GRAD,QRHF,NONHF,ROHF,SEMI,CANON,TRIP1,TRIP2,
     &             GABCD,RELAXED,TRULY_NONHF
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),NTOT(18)
C
      DATA ONE,TWO,ONEM,HALF /1.0D0,2.0D0,-1.0D0,0.5D0/
C
      MBPT4=M4DQ.OR.M4SDQ.OR.M4SDTQ
      CC=CCD.OR.CCSD.OR.QCISD
      MXCOR=MAXCOR
C
C CONTRIBUTIONS DUE TO SINGLE EXCITATIONS
C
      IF(CCSD.OR.QCISD.OR.M4SDQ.OR.M4SDTQ.OR.UCC.OR.ROHF) THEN
C
C ALLOCATE MEMORY FOR T1 AMPLITUDES
C
      I0T1A=MXCOR+1-NTAA*IINTFP
      MXCOR=MXCOR-NTAA*IINTFP
      CALL GETLST(ICORE(I0T1A),1,1,1,1,90)
C
      IF(CC) THEN
C
       I0T2A=I0T1A-NTAA*IINTFP
       MXCOR=MXCOR-NTAA*IINTFP
       CALL GETLST(ICORE(I0T2A),1,1,1,1,190)
C
      ELSE IF(ROHF.AND.MBPT3) THEN
C
       I0T2A=I0T1A-NTAA*IINTFP
       I0T3A=I0T2A-NTAA*IINTFP
       MXCOR=MXCOR-2*NTAA*IINTFP
c YAU : old
c      CALL ICOPY(NTAA*IINTFP,ICORE(I0T1A),1,ICORE(I0T2A),1)
c YAU : new
       CALL DCOPY(NTAA,ICORE(I0T1A),1,ICORE(I0T2A),1)
c YAU : end
       CALL GETLST(ICORE(I0T3A),1,1,1,3,90)
       CALL SAXPY(NTAA,ONE,ICORE(I0T3A),1,ICORE(I0T2A),1)
       CALL GETLST(ICORE(I0T3A),1,1,1,1,190)
       CALL SAXPY(NTAA,ONE,ICORE(I0T3A),1,ICORE(I0T2A),1)
C
      ELSE
C
       I0T2A=I0T1A
C
      ENDIF
C
      IF(IUHF.EQ.0) THEN
C
       I0T1B=I0T1A
       I0T2B=I0T2A
C
      ELSE
C
       I0T1B=I0T2A-NTBB*IINTFP
       MXCOR=MXCOR-NTBB*IINTFP
       CALL GETLST(ICORE(I0T1B),1,1,1,2,90)
C
       IF(CC) THEN
C
        I0T2B=I0T1B-NTBB*IINTFP
        MXCOR=MXCOR-NTBB*IINTFP
        CALL GETLST(ICORE(I0T2B),1,1,2,2,190)
C
       ELSE IF(ROHF.AND.MBPT3) THEN
C
        I0T2B=I0T1B-NTBB*IINTFP
        I0T3B=I0T2B-NTBB*IINTFP
        MXCOR=MXCOR-2*NTBB*IINTFP
c YAU : old
c       CALL ICOPY(IINTFP*NTBB,ICORE(I0T1B),1,ICORE(I0T2B),1)
c YAU : new
        CALL DCOPY(NTBB,ICORE(I0T1B),1,ICORE(I0T2B),1)
c YAU : end
        CALL GETLST(ICORE(I0T3B),1,1,2,4,90)
        CALL SAXPY(NTBB,ONE,ICORE(I0T3B),1,ICORE(I0T2B),1)
        CALL GETLST(ICORE(I0T3B),1,1,2,2,190)
        CALL SAXPY(NTBB,ONE,ICORE(I0T3B),1,ICORE(I0T2B),1)
C
       ELSE
C
        I0T2B=I0T1B
C
       ENDIF
      ENDIF
C
C PERFORM MULTIPLICATION:    SUM M   T(M,A) L(M,B)
C
C   FACT IS HERE ALWAYS ONE
C
      FACT=ONE
C
      DO 300 ISPIN=1,IUHF+1
C
       IF(ISPIN.EQ.1) THEN
        IOFFT1=I0T1A
        IOFFT2=I0T2A
        IOFFD=1
       ELSE
        IOFFT1=I0T1B
        IOFFT2=I0T2B
        IOFFD=1+NF2(1)
       ENDIF
C 
       DO 250 IRREP=1,NIRREP
C
        NOCC=POP(IRREP,ISPIN)
        NVRT=VRT(IRREP,ISPIN)
        IF(MIN(NVRT,NOCC).GT.0) THEN
         CALL XGEMM('N','T',NVRT,NVRT,NOCC,FACT,ICORE(IOFFT1),NVRT, 
     &              ICORE(IOFFT2),NVRT,ONE,DVV(IOFFD),NVRT)
        ENDIF
        IOFFT1=IOFFT1+NOCC*NVRT*IINTFP
        IOFFT2=IOFFT2+NOCC*NVRT*IINTFP
        IOFFD=IOFFD+NVRT*NVRT
250    CONTINUE
#ifdef _DEBUG_LVL0
        Call checksum("T(e,i)*L(j,e)->DVV    :",DVV(1+(ISPIN-1)*
     &                 NF2(ISPIN)),NF2(ISPIN))
#endif
300   CONTINUE
C
      ENDIF
C
C CONTRIBUTION DUE TO DOUBLES
C
C    RESET MXCOR
C
       MXCOR=MAXCOR 
C
C LOOP OVER SPIN CASES (ISPIN=1: ALPHA DENSITY MATRIX, =2: BETA DENSITY MATRIX)
C
       DO 1000 ISPIN=1,IUHF+1
C
       IF(ISPIN.EQ.1) THEN
        IOFF=1
       ELSE
        IOFF=NF2(1)+1
       ENDIF
       IF(IUHF.EQ.1) THEN
C
C  CONTRIBUTION DUE TO AAAA OR BBBB AMPLITUDES (IS SKIPPED FOR RHF)
C
C  IN MBPT3 : 
C            LISTT1 CONTAINS THE FIRST ORDER AMPLITUDES  
C            LISTT2 CONTAINS THE SECOND ORDER AMPLITUDES 
C  IN MBPT4 :
C            LISTT1 CONTAINS THE SECOND ORDER AMPLITUDES
C            LISTT2 CONTAINS THE SECOND ORDER AMPLITUDES
C            LISTT3 CONTAINS THE FIRST ORDER AMPLITUDES  
C            LISTT4 CONTAINS THE THIRD ORDER DELTA AMPITUDES
C            LISTT5 CONTAINS THE X-CONTRIBUTION DUE TO QUADS
C  IN CC  : 
C            LISTT1 CONTAINS THE CC AMPLITUDES
C            LISTT2 CONTAINS THE LAMBDA AMPLITUDES
C
C NOTE SOME FURTHER LOGICAL STUFF HERE
C
C MBPT2 LISTT1 IS EQUAL TO LISTT2 (DON'T READ IT TWICE)
C MBPT4 THERE IS AN ADDITIONAL STEP REQUIRED HERE (LISTT4+5 TIMES LISTT3)
C
C THE SYMMETRIZATION OF THE DENSITY MATRIX 
C
C         D(A,B) = (D(A,B) + D(B,A))/2
C
C HAS TO BE CARRIED OUT FOR ALL METHODS EXCEPT MBPT2
C
        IF(MBPT2) THEN
         LISTT1=43+ISPIN
         LISTT2=43+ISPIN
         FACT=ONE
         IFLAG=1
        ELSE IF(MBPT3) THEN
         IF(ROHF) THEN
          LISTT1=143+ISPIN
          LISTT2=60+ISPIN
          LISTT3=43+ISPIN
          FACT=ONE
          IFLAG=5
         ELSE
          LISTT1=43+ISPIN
          LISTT2=60+ISPIN
          FACT=ONE
          IFLAG=3
         ENDIF
        ELSE IF(MBPT4) THEN
         LISTT1=143+ISPIN
         LISTT2=143+ISPIN
         LISTT3=43+ISPIN
         LISTT4=60+ISPIN
         LISTT5=113+ISPIN
         FACT=ONE
         IFLAG=1
        ELSE IF(UCC) THEN
         LISTT1=43+ISPIN
         LISTT2=43+ISPIN
         FACT=ONE
         IFLAG=1
        ELSE IF(CC) THEN
         LISTT1=43+ISPIN
         LISTT2=143+ISPIN
         FACT=ONE
         IFLAG=2
        ENDIF
C
C
C LOOP OVER IR REPS OF MN BLOCK (THE SAME IRREPS AS THE AF AND EF BLOCKS C HAVE
C
       DO 100 IRREP=1,NIRREP
C
C DETERMINE LENGTH OF EXPANDED VIRTUAL-VIRTUAL BLOCK
C
        NVRT2SQ=0
        DO 110 IRREPJ=1,NIRREP
         NVRT2SQ=NVRT2SQ+VRT(IRREPJ,ISPIN)*
     &                   VRT(DIRPRD(IRREPJ,IRREP),ISPIN)
110     CONTINUE
C
        DISSYT=IRPDPD(IRREP,ISYTYP(1,LISTT1))
        NUMSYT=IRPDPD(IRREP,ISYTYP(2,LISTT1)) 
        I001=1
        I002=I001+IINTFP*NUMSYT*NVRT2SQ
        I003=I002+IINTFP*NUMSYT*NVRT2SQ
        I004=I003+IINTFP*NUMSYT*DISSYT
        IF(MIN(NUMSYT,DISSYT).NE.0) THEN
         IF(I004.LT.MXCOR) THEN
C  
C         IN CORE VERSION
C
          CALL DVVAA(ICORE(I001),ICORE(I002),ICORE(I003),DVV(IOFF),
     &               FACT,ISPIN,POP(1,ISPIN),VRT(1,ISPIN),
     &               DISSYT,NUMSYT,LISTT1,LISTT2,LISTT3,IRREP,IFLAG)
          IF(MBPT4) THEN
          CALL DVVAA(ICORE(I001),ICORE(I002),ICORE(I003),DVV(IOFF),
     &               FACT,ISPIN,POP(1,ISPIN),VRT(1,ISPIN),
     &               DISSYT,NUMSYT,LISTT4,LISTT5,LISTT3,IRREP,4)
          ENDIF
         ELSE
          CALL INSMEM('DVVAA',I004,MXCOR)
         ENDIF
        ELSE
        ENDIF      
100    CONTINUE
       ENDIF
#ifdef _DEBUG_LVL0
        Call checksum("T(im,ef)*L(jm,ef)->DVV:",DVV(1+(ISPIN-1)*
     &                 NF2(1)),NF2(ISPIN))
#endif
C
C       AB SPIN CASE
C
       IF(MBPT2) THEN
        LISTT1=46
        LISTT2=46
        FACT=ONE
        IFLAG=1
       ELSE IF(MBPT3) THEN
        IF(ROHF) THEN
         LISTT1=146
         LISTT2=63
         LISTT3=46
         FACT=ONE
         IFLAG=5
        ELSE
         LISTT1=46
         LISTT2=63
         FACT=ONE
         IFLAG=3
        ENDIF
       ELSE IF(MBPT4) THEN
        LISTT1=146
        LISTT2=146
        LISTT3=46
        LISTT4=63
        LISTT5=116
        FACT=ONE
        IFLAG=1
       ELSE IF(UCC) THEN
        LISTT1=46
        LISTT2=46
        FACT=ONE
        IFLAG=1
       ELSE IF(CC) THEN
        LISTT1=46
        LISTT2=146
        FACT=ONE
        IFLAG=2
       ENDIF
C
C      LOOP OVER IRREPS.
C
       DO 200 IRREP=1,NIRREP
C
        DISSYT=IRPDPD(IRREP,ISYTYP(1,46))
        NUMSYT=IRPDPD(IRREP,ISYTYP(2,46))
        I001=1
        I002=I001+IINTFP*NUMSYT*DISSYT
        I003=I002+IINTFP*NUMSYT*DISSYT
        IF(.NOT.MBPT2) THEN
         I004=I003+IINTFP*NUMSYT*DISSYT
        ELSE
C
C WE NEED ONLY TWO TIMES THE LENGTH OF T2 FOR MBPT(2)
C
         I004=I003
        ENDIF
        IF(MIN(NUMSYT,DISSYT).NE.0) THEN
         I005=I004+3*IINTFP*MAX(DISSYT,NUMSYT)
         IF(I005.LE.MXCOR) THEN
C
C         IN CORE VERSION
C
          CALL DVVAB(ICORE(I001),ICORE(I002),ICORE(I003),DVV(IOFF),
     &               FACT,ISPIN,POP(1,ISPIN),
     &               POP(1,3-ISPIN),VRT(1,ISPIN),VRT(1,3-ISPIN), 
     &               DISSYT,NUMSYT,LISTT1,LISTT2,LISTT3,IRREP,
     &               ICORE(I004),IUHF,IFLAG)  
          IF(MBPT4) THEN
           CALL DVVAB(ICORE(I001),ICORE(I002),ICORE(I003),DVV(IOFF),
     &                FACT,ISPIN,POP(1,ISPIN),
     &                POP(1,3-ISPIN),VRT(1,ISPIN),VRT(1,3-ISPIN), 
     &                DISSYT,NUMSYT,LISTT4,LISTT5,LISTT3,IRREP,
     &                ICORE(I004),IUHF,4)  
          ENDIF
         ELSE
          CALL INSMEM('DVVAB',I005,MXCOR)
         ENDIF
        ELSE
C
C
        ENDIF
200    CONTINUE
#ifdef _DEBUG_LVL0
        Call checksum("T(im,ef)*L(jm,ef)->DVV:",DVV(1+(ISPIN-1)*
     &                 NF2(1)),NF2(ISPIN))
#endif
C
C  FOR PERTURBED CANONICAL ORBITALS, SET OFF-DIAGONAL
C  ELEMENTS TO ZERO
C
       IF(CANON) THEN
        CALL DENCAN(DVV(IOFF),ICORE,NF2(ISPIN),NIRREP,VRT(1,ISPIN))
       ENDIF
C
C  ADD HERE TRIPLE CONTRIBUTIONS IN MBPT(4)
C
       IF(TRIP1) THEN
cold only canonical perturbed orbitals allowed for triples.
ccc        IF(CANON) THEN
ccc         CALL ADDDT(DVV(IOFF),ICORE,NF2(ISPIN),NIRREP,VRT(1,ISPIN),
ccc     &              160,2+ISPIN)
ccc        ELSE
ccc         write(*,*)' Triple excitations require pert. canonical ',
ccc     &             'orbitals !'
ccc         CALL ERREX
ccc        ENDIF
cnew standard canonical orbitals now allowed.
         CALL ADDDT(DVV(IOFF),ICORE,NF2(ISPIN),NIRREP,VRT(1,ISPIN),
     &              160,2+ISPIN,CANON)
#ifdef _DEBUG_LVL0
        Call checksum("CCSD(T)->DVV          :",DVV(1+(ISPIN-1)*
     &                 NF2(ISPIN)),NF2(ISPIN))
#endif
       ENDIF
C
C  FOR ALL METHODS EXCEPT MBPT2 SYMMETRIZE DENSITY MATRIX
C     
      IF(.NOT.MBPT2)THEN
       CALL SYMMET5(DVV(IOFF),ICORE,VRT(1,ISPIN))
      ENDIF
C
1000  CONTINUE
      RETURN
      END
