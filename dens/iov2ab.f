      SUBROUTINE IOV2AB(G,W,MAXSIZE,AIOV,FACT,ISPIN,POP1,POP2,VRT1,VRT2,
     &                  DISSYT,NUMSYT,DISSYW,NUMSYW,LISTG,LISTW,IRREP,
     &                  TMP,IUHF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT,DISSYW,DISMAX,DISLEFT,DISREAD,DIRPRD,POP1,
     &        POP2,VRT1,VRT2
      DIMENSION G(DISSYT,1),W(DISSYW,1),AIOV(1),TMP(1),POP1(8),
     &          POP2(8),VRT1(8),VRT2(8),IPT(8) 
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      common /dropgeo/ ndrgeo
C
      DATA ONE, ONEM, TWO /1.0D0, -1.D0,2.D0/
C
C PICK UP FIRST THE G AMPLITUDES AND INTEGRALS,
C WE NEED THEM ANYWAY
C
      CALL GETLST(W,1,NUMSYW,2,IRREP,LISTW)
C
C SPIN ADAPTED CODE FOR RHF
C
      IF(IUHF.EQ.0) THEN
       CALL SPINAD3(IRREP,VRT1,DISSYW,NUMSYW,W,TMP,TMP(1+NUMSYW))
      ENDIF
C
C  DECIDE ABOUT THE ALGORITHM
C
      IF(MAXSIZE.GE.DISSYT*NUMSYT) THEN
C
C  IN CORE ALGORITHM
C 
C    GET GAMMA AMPLITUDES
C     
       if(ndrgeo.eq.0) then
         CALL GETLST(G,1,NUMSYT,1,IRREP,LISTG)
       else 
         CALL GETGV2(G,TMP,1,NUMSYT,1,IRREP,LISTG,ispin,listg,dissyt)
       endif 
C
C  TRANSPOSE THE LAST TWO INDICES IN THE AA CASE
C
       IF(ISPIN.EQ.1.AND.IUHF.EQ.1) THEN
        CALL SYMTR1(IRREP,VRT1,VRT2,DISSYT,G,TMP,TMP(1+DISSYT),
     &              TMP(1+2*DISSYT))
        CALL SYMTR1(IRREP,POP1,VRT2,DISSYW,W, TMP,TMP(1+DISSYW),
     &              TMP(1+2*DISSYW))
       ENDIF
C
C  PERFORM MULTIPLICATION
C
C  JOFFW AND JOFFG OFFSET IN THE VIRTUAL-VIRTUAL BLOCK OF G AND W
C  IOFF OFFSET IN AIVV
C
       IOFF=1
       JOFFW=1
       JOFFG=1
       DO 90 IRREPI=1,NIRREP
C          
C  GET NUMBER OF VIRTUAL ORBITALS FOR IRREPJ
C
        NVRTI=VRT1(IRREPI)
        NOCCI=POP1(IRREPI)
C
C  DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH IRREPJ GIVES IRREP
C
        IRREPJ=DIRPRD(IRREP,IRREPI)
C
C  GET NUMBER OF VIRTUAL ORBITALS FOR KRREP
C
        NVRTJ=VRT2(IRREPJ)
C
C  IF NVRTI OR NVRTJ EQUAL ZERO, NOTHING TO COMPUTE
C
        IF(MIN(NVRTJ,NVRTI,NOCCI).NE.0) THEN
C
          CALL XGEMM('T','N',NVRTI,NOCCI,NUMSYT*NVRTJ,FACT,
     &              G(1,JOFFG),NVRTJ*NUMSYT,W(1,JOFFW),
     &              NVRTJ*NUMSYT,ONE,AIOV(IOFF),NVRTI)
        ENDIF
C
C  UPDATE THE OFFSETS
C
        JOFFW=JOFFW+NOCCI*NVRTJ
        JOFFG=JOFFG+NVRTJ*NVRTI
        IOFF=IOFF+NVRTI*NOCCI
90     CONTINUE
C
      ELSE
C
C  OUT OF CORE ALGORITHM
C
      NTDIS=NUMSYT
      IF (NDRGEO.NE.0) THEN
       CALL GETINV2(TMP,NUMSYT,DISSYT,LISTG,IRREP)
       ITIN = 1 + NUMSYT+1 
       NIKI = 1
       IODRSET = 1
      ENDIF 
C   DIFFER HERE BETWEEN THE VARIOUS SPIN CASES
C
       IF(ISPIN.EQ.2.OR.IUHF.EQ.0) THEN
C
C   DETERMINE MAXIMUM NUMBER OF DISTRIBUTIONS WHICH FIT INTO CORE
C
        MAXDIS=MAXSIZE/DISSYT
C
C   OFFSET FOR GAMMA LIST, INTEGRALS, AND INTERMEDIATE IOV
C
        IOFFSET=1
        JOFFW=1
        IOFF1=1
C
C   LOOP OVER THE IRREPS OF THE LAST INDEX
C
        DO 200 IRREPJ=1,NIRREP
C
         NOCCJ=POP1(IRREPJ)
         NVRTJ=VRT1(IRREPJ)
         IRREPI=DIRPRD(IRREP,IRREPJ)
         NOCCI=POP1(IRREPI)
         NVRTI=VRT2(IRREPI)
CJDW 3/10/97. Error detected by JG. NOCCI should not be checked.
cold     IF(MIN(NOCCI,NVRTI,NOCCJ).NE.0) THEN
         IF(MIN(NVRTI,NVRTJ,NOCCJ).NE.0) THEN
C
C   TRY FIRST N**3 OUT OF CORE ALGORITHM
C
          DISMAX=MAXDIS/NVRTI
          IF(DISMAX.GT.0) THEN
C
C   NUMBER OF (E,f,G) BLOCKS TO READ
C
           DISLEFT=NVRTJ
C
           IOFF=0
C
10         CONTINUE
C
C   NUMBER OF (Ef,G) BLOCKS WHICH ARE READ DURING THIS PASS
C
            DISREAD=MIN(DISLEFT,DISMAX)
            DISLEFT=DISLEFT-DISREAD
C
C   GET THE DISTRIBUTIONS FROM DISK
C
            if(ndrgeo.eq.0) then 
             CALL GETLST(G,IOFFSET,DISREAD*NVRTI,1,IRREP,LISTG)
            else
             CALL GETGV2O(G,TMP(ITIN),IODRSET,
     x         DISREAD*NVRTI,1,IRREP,LISTG,ispin,listg,dissyt,TMP,NIKI)
            endif 
C
C   UPDATE OFFSETS
C
            IOFFSET=IOFFSET+DISREAD*NVRTI
C
C  PERFORM MULTIPLICATION
C
            CALL XGEMM('T','N',DISREAD,NOCCJ,NUMSYT*NVRTI,FACT,
     &                 G,NVRTI*NUMSYT,W(1,JOFFW),NVRTI*NUMSYT,
     &                 ONE,AIOV(IOFF1+IOFF),NVRTJ)
C
C UPDATE IOFF
C
            IOFF=IOFF+DISREAD
C
C  IF NOT ALL (Ef,G) BLOCKS HAVE BEEN PROCESSED GO BACK TO 10
C
           IF(DISLEFT.NE.0) GO TO 10
C
          ELSE
           STOP 'IOV2AB'
          ENDIF
         ELSE
C
C  UPDATE OFFSETS IN THE CASE WE HAVE DONE NOTHING
C
          IOFFSET=IOFFSET+NVRTJ*NVRTI
         ENDIF
C
C UPDATE JOFFW
C
         IOFF1=IOFF1+NOCCJ*NVRTJ
         JOFFW=JOFFW+NOCCJ*NVRTI
C
200     CONTINUE
C
C  SECOND SPIN CASE
C
       ELSE IF(ISPIN.EQ.1.AND.IUHF.NE.0) THEN
C
C  DETERMINE FIRST POINTER FOR AIOV
C
        IPT(1)=1
        DO 280 IRREPJ=1,NIRREP-1
         IPT(IRREPJ+1)=IPT(IRREPJ)+POP1(IRREPJ)*VRT1(IRREPJ)
280     CONTINUE
C
C  DETERMINE MAXIMUM NUMBER OF DISTRIBUTIONS WHICH CAN BE HELD IN CORE
C
        MAXDIS=MAXSIZE/DISSYT
C
C  SET OFFSET FOR GAMMA LIST AND INTEGRALS
C
        IOFFSET=1
        JOFFW=1
C
C  LOOP OVER THE IRREPS OF THE LAST INDEX
C
        DO 300 IRREPJ=1,NIRREP
C
         NVRTJ=VRT2(IRREPJ)
         IRREPI=DIRPRD(IRREP,IRREPJ)
         NOCCI=POP1(IRREPI)
         NVRTI=VRT1(IRREPI)
         IF(MIN(NVRTI,NOCCI,NVRTJ).NE.0) THEN
          IOFF=IPT(IRREPI)
C
C   TRY FIRST AN N**3 ALGORITHM
C
          DISMAX=MAXDIS/NVRTI
          IF(DISMAX.GT.0) THEN
C
C  SET NUMBER OF (Ef,A) BLOCKS TO READ
C
           DISLEFT=NVRTJ
C
20         CONTINUE
C
C  DETERMINE NUMBER OF (Ef,A) BLOCKS WHICH ARE READ DURINg THIS PASS
C
            DISREAD=MIN(DISMAX,DISLEFT)
            DISLEFT=DISLEFT-DISREAD
C 
C  GET THE DISTRIBUTIONS FROM DISK
C
            if(ndrgeo.eq.0) then
               CALL GETLST(G,IOFFSET,DISREAD*NVRTI,2,IRREP,LISTG)
            else
              CALL GETGV2O(G,TMP(ITIN),IODRSET,DISREAD*NVRTI,2,
     x                     IRREP,LISTG,ispin,listg,dissyt,TMP,NIKI)
            endif 
C
C  UPDATE OFFSET
C
            IOFFSET=IOFFSET+DISREAD*NVRTI
            JOFFG=1 
C
C  LOOP OVER ALL DISTRIBUTIONS AND PERFORM MULTIPLICATION
C
            DO 250 NUM=1,DISREAD
C
              CALL XGEMM('T','N',NVRTI,NOCCI,DISSYT,FACT,
     &                  G(1,JOFFG),DISSYT,W(1,JOFFW),DISSYT,
     &                  ONE,AIOV(IOFF),NVRTI)
C
C  UPDATE OFFSETS
C
             JOFFW=JOFFW+NOCCI
             JOFFG=JOFFG+NVRTI
C  
250         CONTINUE
C 
C  IF NOT ALL (Ef,A) BLOCKS HAVE BEEN PROCESSED, GO BACK TO 20
C
           IF(DISLEFT.NE.0) GO TO 20
C
          ELSE
           STOP 'IOV2AB'
          ENDIF
         ELSE
C
          JOFFW=JOFFW+NOCCI*NVRTJ
          IOFFSET=IOFFSET+NVRTI*NVRTJ
         ENDIF
300     CONTINUE
       ENDIF
      ENDIF
C
      RETURN
      END
