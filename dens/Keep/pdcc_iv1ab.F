      SUBROUTINE PDCC_IV1AB(G,W,T,AIVV,FACT,ISPIN,POP1,POP2,VRT1,VRT2,
     &                 DISSYT,NUMSYT,LISTG,LISTW,IRREP,TMP,IUHF,
     &                 LARGE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL LARGE
      INTEGER DISSYT,DIRPRD,POP1,POP2,VRT1,VRT2
      DIMENSION G(NUMSYT,1),W(NUMSYT,2),T(DISSYT,1),AIVV(1),TMP(1)
      DIMENSION POP1(8),POP2(8),VRT1(8),VRT2(8) 
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      common /dropgeo/ ndrgeo
C
      DATA ONE,ONEM,HALF,TWO /1.0D0,-1.0D0,0.5D0,2.0D+0/
C
C      PICK UP FIRST THE G AMPLITUDES AND INTEGRALS
C
       IF(LARGE) THEN
        if (ndrgeo.eq.0) then
          CALL GETLST(T,1,NUMSYT,1,IRREP,LISTG)
        else 
          CALL GETGO1(T,G,1,NUMSYT,1,IRREP,LISTG,ispin,listw,dissyt)
        endif 
        CALL TRANSP(T,G,NUMSYT,DISSYT)
       ELSE
        if (ndrgeo.eq.0) then 
          CALL GETTRN(G,TMP,DISSYT,NUMSYT,1,IRREP,LISTG)
        else  
          CALL GETGO1T(G,TMP,DISSYT,NUMSYT,1,IRREP,LISTG,ispin) 
        endif 
       ENDIF
C  SPIN ADAPTED CODE FOR RHF
C
       IF(IUHF.EQ.0) THEN
         CALL PDCC_SPINAD1(IRREP,VRT1,NUMSYT,G,TMP,TMP(1+NUMSYT))
       ENDIF
C
       IF(LARGE) THEN
        CALL GETLST(T,1,NUMSYT,2,IRREP,LISTW)
        CALL TRANSP(T,W,NUMSYT,DISSYT)
       ELSE
        CALL GETTRN(W,TMP,DISSYT,NUMSYT,1,IRREP,LISTW)
       ENDIF
C
C  TRANSPOSE THE LAST TWO INDICES IN THE AA CASE
C
C  HOWEVER, IN RHF TAKE ADVANTAGE IF THE SPIN SYMMETRY
C
      IF(IUHF.EQ.1.AND.ISPIN.EQ.1) THEN
        CALL SYMTR1(IRREP,VRT1,VRT2,NUMSYT,G,TMP,TMP(1+NUMSYT),
     &              TMP(1+2*NUMSYT))
        CALL SYMTR1(IRREP,VRT1,VRT2,NUMSYT,W,TMP,TMP(1+NUMSYT),
     &              TMP(1+2*NUMSYT))
      ENDIF
C
C  PERFORM MULTIPLICATION
C
C  JOFF OFFSET IN THE VIRTUAL-VIRTUAL BLOCK OF G AND W
C  IOFF OFFSET IN AIVV
C
      IOFF=1
      JOFF=1
      DO 90 IRREPI=1,NIRREP
C          
C        GET NUMBER OF VIRTUAL ORBITALS FOR IRREPJ
C
       NVRTI=VRT1(IRREPI)
C
C        DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH IRREPJ GIVES IRREP
C
       IRREPJ=DIRPRD(IRREP,IRREPI)
C
C        GET NUMBER OF VIRTUAL ORBITALS FOR KRREP
C
       NVRTJ=VRT2(IRREPJ)
C
C        IF NVRTI OR NVRTJ EQUAL ZERO, NOTHING TO COMPUTE
C
       IF(MIN(NVRTJ,NVRTI).NE.0) THEN
          call checksum("iv1ab-befor",aivv,nvrti*nvrtj)
C
          CALL XGEMM('T','N',NVRTI,NVRTI,NUMSYT*NVRTJ,FACT,
     &               W(1,JOFF),NVRTJ*NUMSYT,G(1,JOFF),
     &               NVRTJ*NUMSYT,ONE,AIVV(IOFF),NVRTI)
       ENDIF
C
          call checksum("iv1ab-after",aivv,nvrti*nvrtj)
C  UPDATE THE OFFSETS
C
       JOFF=JOFF+NVRTJ*NVRTI
       IOFF=IOFF+NVRTI**2
90    CONTINUE
C
      RETURN
      END
