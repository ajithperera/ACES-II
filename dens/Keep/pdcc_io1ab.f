










      SUBROUTINE PDCC_IO1AB(G,W,AIOO,FACT,ISPIN,POP1,POP2,VRT1,VRT2,
     &            DISSYT,NUMSYT,LISTG,LISTW,IRREP,TMP,IUHF,igtype)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT,DIRPRD,POP1,POP2,VRT1,VRT2
      DIMENSION G(DISSYT,1),W(DISSYT,1),AIOO(1),TMP(1)
      DIMENSION POP1(8),POP2(8),VRT1(8),VRT2(8) 
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
      common /dropgeo/ ndrgeo 
C
      DATA ONE /1.0D0/,HALF /0.5D0/,ONEM /-1.0D+0/,TWO /2.0D+0/
C
C      PICK UP FIRST THE G AMPLITUDES AND THE INTEGRALS
C
      if (ndrgeo.eq.0) CALL GETLST(G,1,NUMSYT,1,IRREP,LISTG)

      if (ndrgeo.eq.1) then
        if (igtype.eq.1) 
     x     CALL GETGO1(G,W,1,NUMSYT,1,IRREP,LISTG,ISPIN,listw,dissyt)
        if (igtype.eq.2) 
     x     CALL GETGO2(G,W,1,NUMSYT,1,IRREP,LISTG,ISPIN,listw,dissyt)
      endif 
C
       CALL GETLST(W,1,NUMSYT,2,IRREP,LISTW)
C
C SPIN ADAPTED CODE FOR RHF
C
      IF(IUHF.EQ.0) THEN
          CALL PDCC_SPINAD1(IRREP,POP1,DISSYT,W,TMP,TMP(1+DISSYT))
      ENDIF
C
C TRANSPOSE THE LAST TWO INDICES IN THE AA CASE
C
C HOWEVER, IN RHF TAKE ADVANTAGE OF THE SPIN SYMMETRY
C
      IF(IUHF.EQ.1.AND.ISPIN.EQ.1) THEN 
       CALL SYMTR1(IRREP,POP1,POP2,DISSYT,G,TMP,TMP(1+DISSYT),
     &             TMP(1+2*DISSYT))
       CALL SYMTR1(IRREP,POP1,POP2,DISSYT,W,TMP,TMP(1+DISSYT),
     &             TMP(1+2*DISSYT))
      ENDIF
C
C  PERFORM MULTIPLICATION
C
C  JOFF OFFSET IN THE OCCUPIED-OCCUPIED BLOCK OF G AND W
C  IOFF OFFSET IN DOO
C
      JOFF=1
      IOFF=1
      DO 90 IRREPI=1,NIRREP
C          
C        GET OCCUPATION NUMBER FOR JRREP     
C
       NOCCI=POP1(IRREPI)
C
C        DETERMINE IRREPJ WHOSE DIRECT PRODUCT WITH IRREPI GIVES IRREP
C
       IRREPJ=DIRPRD(IRREP,IRREPI)
C
C        GET OCCUPATION NUMBER FOR IRREPJ
C
       NOCCJ=POP2(IRREPJ)
C
C        IF ZERO, NOTHING TO COMPUTE
C
       IF(MIN(NOCCI,NOCCJ).NE.0) THEN
C
        call checksum("io1ab-befor",aioo,nocci*nocci)
        CALL XGEMM('T','N',NOCCI,NOCCI,DISSYT*NOCCJ,FACT,
     &             W(1,JOFF),NOCCJ*DISSYT,G(1,JOFF),      
     &             NOCCJ*DISSYT,ONE,AIOO(IOFF),NOCCI)
        call checksum("io1ab-after",aioo,nocci*nocci)
C
       ENDIF
C
C  UODATE OFFSETS
C
       JOFF=JOFF+NOCCJ*NOCCI
       IOFF=IOFF+NOCCI*NOCCI
90    CONTINUE
C
      RETURN
      END
