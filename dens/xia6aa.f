      SUBROUTINE XIA6AA(G,W,W1,MAXSIZE,XIA,FACT,ISPIN,POP,VRT,
     &                  DISSYT,NUMSYT,DISSYW,NUMSYW,NVRTSQ,
     &                  LISTG,LISTW,IRREP,TMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT,DISSYW,DISMAX,DISLEFT,DISREAD,DIRPRD,POP,VRT
      DIMENSION G(DISSYT,1),W(DISSYW,1),W1(NVRTSQ,1),XIA(1),
     &          POP(8),VRT(8),TMP(1)
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      common /dropgeo/ ndrgeo
C
      DATA ONE /1.D0/
C
C PICK UP THE G AMPLITUDES  REQUIRED
C
      if (ndrgeo.eq.0) then
        CALL GETLST(G,1,NUMSYT,1,IRREP,LISTG)
      else 
        CALL GETGO4U(G,W,1,NUMSYT,1,IRREP,LISTG,ispin,listg,dissyt)
      endif 
C
C DECIDE ABOUT THE ALGORITHM BY CHECKING MAXCOR
C
      IF(MAXSIZE.GT.DISSYW*NVRTSQ) THEN
C
C FULL IN CORE ALGORITHM
C
       CALL GETLST(W,1,NUMSYW,2,IRREP,LISTW)   
C
C EXPAND THE VIRT. VIRT. BLOCK SO THAT WE HAVE E<F,G A
C
       CALL SYMEXP(IRREP,VRT,DISSYW,W)
C
C PERFORM MULTIPLICATION 
C
C JOFFG AND JOFFW OFFSET IN THE RIGHTMOST BLOCKS OF G AND W
C IOFF OFFSET IN IOV
C
       IOFF=1
       JOFFG=1
       JOFFW=1
       DO 90 IRREPJ=1,NIRREP
C          
C GET NUMBER OF OCCUPIED AND VIRTUAL ORBITALS FOR IRREPJ     
C
        NOCCJ=POP(IRREPJ)
        NVRTJ=VRT(IRREPJ)
C
C DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH IRREPJ GIVES IRREP
C
        IRREPI=DIRPRD(IRREP,IRREPJ)
C
C GET NUMBER OF VIRTUALORBITALS FOR IRREPI
C
        NVRTI=VRT(IRREPI)
C
C IF NVRTI OR NVRTJ EQUAL ZERO, NOTHING TO COMPUTE
C
        IF(MIN(NVRTI,NVRTJ,NOCCJ).NE.0) THEN
C
         CALL XGEMM('T','N',NVRTJ,NOCCJ,NVRTI*DISSYT,FACT,
     &              W(1,JOFFW),NVRTI*DISSYT,G(1,JOFFG),
     &              NVRTI*DISSYT,ONE,XIA(IOFF),NVRTJ)
        ENDIF
C
C UPDATE OFFSETS
C
        JOFFG=JOFFG+NVRTI*NOCCJ
        JOFFW=JOFFW+NVRTI*NVRTJ
        IOFF=IOFF+NVRTJ*NOCCJ
90     CONTINUE
C
      ELSE
C
C   OUT OF CORE ALGORITHM
C
C  DETERMINE MAXIMUM NUMBER OF DISTRIBUTIONS WHICH FIT INTO CORE 
C
       DISMAX=MAXSIZE/NVRTSQ
       IF(DISMAX.LE.0) STOP 'XIA6AA'
C
C  SET OFFSET FOR GAMMA AND INTEGRAL LIST
C
       IOFFSET=1
       IOFFG=0
C
C  SET NUMBER OF DISTRIBUTIONS TO READ
C
       DISLEFT=NUMSYW
C
10     CONTINUE
C
C  DETERMINE NUMBER OF DISTRIBUTION READ DURING THIS PASS
C
        DISREAD=MIN(DISMAX,DISLEFT)
        DISLEFT=DISLEFT-DISREAD
C
C  GET THE DISTRIBUTIONS FROM DISK
C
        CALL GETLST(W,IOFFSET,DISREAD,2,IRREP,LISTW)
C
C  UPDATE IOFFSET
C
        IOFFSET=IOFFSET+DISREAD
C
C EXPAND THE LEFT VIRTUAL-VIRTUAL BLOCK OF W   
C
        CALL SYMEXP2(IRREP,VRT,NVRTSQ,DISSYW,DISREAD,W1,W)
C
C  LOOP OVER ALL DISTRIBUTIONS IN CORE
C
        DO 100 NUM=1,DISREAD
C
         IOFFG=IOFFG+1
C
C  COPY THE REQUIRED PART OF G TO TMP IN ORDER TO PERFORM MULTIPLICATION
C
         CALL SCOPY(NUMSYT,G(IOFFG,1),DISSYT,TMP,1)
C
C  LOOP OVER IRRE{S OF A AND I
C
         IOFF=1
         JOFFW=1
         JOFFG=1
         DO 190 IRREPJ=1,NIRREP
          NOCCJ=POP(IRREPJ)
          NVRTJ=VRT(IRREPJ)
          IRREPI=DIRPRD(IRREP,IRREPJ)
          NVRTI=VRT(IRREPI)
          IF(MIN(NOCCJ,NVRTJ,NVRTI).NE.0) THEN
           CALL XGEMM('T','N',NVRTJ,NOCCJ,NVRTI,FACT,
     &                 W1(JOFFW,NUM),NVRTI,TMP(JOFFG),
     &                 NVRTI,ONE,XIA(IOFF),NVRTJ)
          ENDIF
C
C  UPDATE OFFSETS
C
          JOFFG=JOFFG+NVRTI*NOCCJ
          JOFFW=JOFFW+NVRTI*NVRTJ
          IOFF=IOFF+NVRTJ*NOCCJ
190      CONTINUE
100     CONTINUE
C
C IF SOME DISTRIBUTIONS ARE LEFT On DISK, GO BACK TO 10
C 
       IF(DISLEFT.NE.0) GO TO 10
      ENDIF
C
      RETURN
      END
