      SUBROUTINE G6AA(T2,T,G,T1,T1A,GIK,FACT,LAMBDA,CCSD,TRIP,
     &                ISPIN,POP,VRT,NT,DISSYT,NUMSYT,DISSYG,
     &                NUMSYG,LISTT,LISTL,LISTG,IRREP,TMP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL LAMBDA,CCSD,TRIP
      INTEGER DIRPRD,DISSYT,DISSYG,POP,VRT
      DIMENSION T2(NUMSYT,1),T(DISSYT,1),G(DISSYG,1),T1(NT,2),TMP(1) 
      DIMENSION POP(8),VRT(8),T1A(1),GIK(1)
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
C
      DATA AZERO,ONE,HALF/0.D0,1.D0,0.5D0/
C
      IF(CCSD.OR.TRIP) THEN
       CALL GETLST(G,1,NUMSYG,1,IRREP,LISTG)
       CALL SYMTR1(IRREP,POP,VRT,DISSYG,G,TMP,TMP(1+DISSYG),
     &             TMP(1+2*DISSYG))
      ELSE
       CALL ZERO(G,NUMSYG*DISSYG)
      ENDIF
C
      IPASS=1
C
C     IPASS=1 CORRESPONDS TO LAMBDA(K,E) T(IJ,EA)
C     IPASS=2 CORRESPONDS TO T(K,E) LAMBDA(IJ,EA)
C
1     CONTINUE
C
C  SET PARAMETERS FOR LOOP
C
      IF(IPASS.EQ.1) THEN
       LIST1=LISTT
      ELSE
       LIST1=LISTL
      ENDIF
C
C    GET FIRST T2 AMPLITUDES FROM DISK
C    TRANSPOSE AB AND IJ
C    AND EXPAND THE VIRTUAL-VIRTUAL BLOCK
C
      CALL GETLST(T,1,NUMSYT,1,IRREP,LIST1)
C
C FOR CCSD FORM ON THE FIRST PASS TAU AMPLITUDES
C
      IF(IPASS.EQ.1.AND.CCSD) THEN
       CALL FTAU(T,T1A,T1A,DISSYT,NUMSYT,POP,POP,VRT,VRT,
     &           IRREP,ISPIN,ONE)
      ENDIF
      CALL TRANSP(T,T2,NUMSYT,DISSYT)
      CALL SYMEXP(IRREP,VRT,NUMSYT,T2)
C
C     NOW PERFORM MULTIPLICATION
C
C  IOFF OFFSET IN T1
C  JOFFT2 OFFSET IN OCC. OCC. BLOCK OF T2
C  JOFFG OFFSET IN OCC VIRT BLOCK OF G
C
      IOFF=1
      JOFFT2=1
      JOFFG=1
C
      DO 100 IRREPJ=1,NIRREP
C
C  OCCUPIED AND VIRTUAL ORBITALS FOR MULTIPLICATION
C
      NOCCJ=POP(IRREPJ)
      NVRTJ=VRT(IRREPJ) 
      IRREPI=DIRPRD(IRREP,IRREPJ)
      NVRTI=VRT(IRREPI)
C
C  IF ANY OF THE POPULATION IS ZERO, SKIP LOOP
C
      IF(MIN(NVRTI,NVRTJ,NOCCJ).NE.0) THEN
C
       CALL XGEMM('N','N',NUMSYT*NVRTI,NOCCJ,NVRTJ,FACT,T2(1,JOFFT2),
     &            NUMSYT*NVRTI,T1(IOFF,IPASS),NVRTJ,ONE,G(1,JOFFG),
     &            NUMSYT*NVRTI)
      ENDIF
C
C   UPDATE POINTERS
C
      IOFF=IOFF+NVRTJ*NOCCJ
      JOFFT2=JOFFT2+NVRTI*NVRTJ
      JOFFG=JOFFG+NOCCJ*NVRTI
C
100   CONTINUE
C
      IPASS=IPASS+1
C
C  ONLY FOR QCISD AND CCSD TWO PASSES ARE REQUIRED
C
      IF(LAMBDA.AND.IPASS.EQ.2) GO TO 1
C
C  TRANSPOSE INDICES SINCE WE HAVE CALCULATES -G(IJ,AK) = G(IJ,KA)
C  WITH AN ORDERING OF  I J A K
C
      CALL SYMTR1(IRREP,VRT,POP,DISSYG,G,TMP,TMP(1+DISSYG),
     &            TMP(1+2*DISSYG))
C
C ADDITIONAL TERMS FOR CCSD
C
      IF(CCSD) THEN
C
C  GET V(IJ,KM) INTERMEDIATES
C
       CALL GETLST(T2,1,NUMSYT,1,IRREP,150+ISPIN)
C
C EXPAND V(IJ,KM)
C 
       CALL SYMEXP(IRREP,POP,NUMSYT,T2)
C
       IOFFT=1
       IOFFV=1
       IOFFG=1
       DO 200 IRREPJ=1,NIRREP
C
C   GET ORBITAL OCCUPATIONS FOR MULTIPLICATION     
C
        NOCCJ=POP(IRREPJ)
        NVRTJ=VRT(IRREPJ) 
        IRREPI=DIRPRD(IRREP,IRREPJ)
        NOCCI=POP(IRREPI)
C
C DO NOTHING IF ANY OF THE ORBITAL OCCUPATIONS IS ZERO
C
        IF(MIN(NVRTJ,NOCCI,NOCCJ).NE.0) THEN
         CALL XGEMM('N','T',NUMSYT*NOCCI,NVRTJ,NOCCJ,HALF,
     &              T2(1,IOFFV),NUMSYT*NOCCI,T1A(IOFFT),NVRTJ,
     &              ONE,G(1,IOFFG),DISSYG*NOCCI)
        ENDIF
C
C   UPDATE OFFSETS
C
        IOFFT=IOFFT+NOCCJ*NVRTJ
        IOFFV=IOFFV+NOCCI*NOCCJ
        IOFFG=IOFFG+NOCCI*NVRTJ
C
200    CONTINUE
C
C  ADD THE CONTRIBUTION   -P(IJ) G(IK) T(JA)
C
C  GET GIK FROM DISK
C
       CALL GETLST(GIK,1,1,1,ISPIN,191)
C
C CALL G6TAU IN ORDER TO CALCULATE THIS CONTRIBUTION
C
       CALL G6TAU(G,GIK,T1A,DISSYG,NUMSYG,POP,POP,VRT,
     &            IRREP,ISPIN)
C
      ENDIF 
C
C  SAVE GAMMA ON LIST
C
      CALL PUTLST(G,1,NUMSYG,2,IRREP,LISTG)
C
      RETURN
      END
