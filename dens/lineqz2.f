      SUBROUTINE LINEQZ2(AMAT,XIA,XIANEW,XUPDATE,ASMALL,ASQUARE,
     &                   EVALA,EVALB,FAB,FIJ,FAJ,WMATOA,WMATVA,
     &                   WMATOB,WMATVB,XSCR,LENAB,LENIJ,LENAJ,IMOA,
     &                   IMVA,IMOB,IMVB,CONV,NA,NB,KMAX,NOCCA,NOCCB,
     &                   INCORE,IQRHF,ROHF)
C
C  THIS PROGRAM SOLVES THE LINEAR EQUATION
C
C  SUM B,J Z(B,J) (A(BJ,AI) + (EA-EI) DELTA(BA) DELTA(IJ)) = X(AI)
C
C  USING AN ITERATIVE EXPANSION IN A SUBSPACE SPANNED BY THE
C  VECTORS X(BJ) A'**N (BJ,AI). THE METHOD HAS BEEN FIRST USED
C  BY POPLE AND COWORKERS FOR SOLVING THE CPHF-EQUATIONS AND
C  IS HERE USED TO SOLVE THE Z-VECTOR EQUATION WITHIN CPHF
C  THEORY. THE PROGRAM FOLLOWS CLOSELY THE IMPLEMENTATION OF
C  POPLE AND COWORKERS IN G82 AND IMPLEMENTATION OF J. GAUSS FOR
C  SOLVING THE Z-VECTOR EQUATION IN COLOGNE.
C 
C  THIS VERSION USES EXPLICITELY SYMMETRY (ONLY THE BLOCK OF 
C  THE A-MATRIX WHICH CORRESPONDS TO IRREP 1 IS NEEDED) AND
C  IS EFFICIENTLY VECTORIZED. 
C
C  THIS IS THE VERSION FOR UHF, ROHF, AND QRHF !
C
C  AMAT .... CONTAINS THE MODIFIED A-MATRIX AS PROVIDED BY MKARHF
C  XIA  .... X(AI) AS INPUT, D(AI) AS OUTPUT
C  XIANEW .. SCRATCH VECTOR OF LENGTH MAX(N,2*KMAX)
C  XUPDATE . CONTAINS ALL THE EXPANSION VECTOR (LENGTH KMAX*N)
C  ASMALL .. THE A MATRIX WITHIN THE ITERATIVE SUBSPACE ( LENGTH KMAX**2)
C  ASQUARE . A VECTOR OF LENGTH KMAX+1 WHICH HOLDS THE NORMS OF THE 
C            EXPANSION VECTORS
C  EVALA .... EIGENVALUES (ALPHA)
C  EVALB .... EIGENVALUES (BETA)
C  CONV .... CONVERGENCE CRITERION
C  NA ....... NUMBER OF ELEMENTS IN X(AI) OR D(AI) (ALPHA)
C  NB ....... NUMBER OF ELEMENTS IN X(AI) OR D(AI) (BETA)
C  KMAX .... MAXIMUM NUMBER OF ITERATION ALLOWED IN THE ITERATIVE EXPANSION
C  NOCCA .... NUMBER OF OCCUPIED ORBITALS (ALPHA)
C  NOCCB .... NUMBER OF OCCUPIED ORBITALS (BETA)
C  INCORE ... LOGICAL VARIABLE WHICH TELLS IF INCORE ALGORITHM IS POSSIBLE
C  IQRHF .... QRHF FLAG ( = 0 UHF, =1 M/M+ QRHF, =2 M/M- QRHF)
C  ROHF ..... ROHF FLAG ( TRUE IF ROHF REFERENCE FUNCTION IS USED)
C
CEND
C 
C CODED AUGUST/90  JG
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL INCORE,ROHF,SEMI
      INTEGER DIRPRD,POP,VRT
      DIMENSION DET(2)
      DIMENSION AMAT(1),XIA(NA+NB), XIANEW(NA+NB),XUPDATE(NA+NB,KMAX),
     &          ASMALL(KMAX,KMAX),ASQUARE(KMAX+1),EVALA(1),XSCR(1),
     &          EVALB(1),FAB(LENAB),FIJ(LENIJ),FAJ(LENAJ)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON/SYM2/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
      COMMON /FLAGS/ IFLAGS(100)
      COMMON /SHIFT/ ISHIFT 
      common /dropgeo/ ndrgeo
C
C
      DATA AZERO,ONE,ONEM,TWO/0.D+0,1.0D+0,-1.0D+0,2.D+0/
C
      SEMI=.FALSE.
      IF(IFLAGS(39).EQ.1) SEMI=.TRUE.
      CUTOFF=CONV*CONV
      TOL=AZERO
      N=NA+NB
C
C   IOFF .... OFFSETS FOR A MATRIX
C             
C             = 1     UHF, ROHF
C             = 0     QRHF
C
      IOFF=1
      IF(IQRHF.NE.0) IOFF=0
C
C     CLEAR SMALL A MATRIX
C
      CALL ZERO(ASMALL,KMAX*KMAX)
C
C     NORMALIZE INITIAL VECTOR XIA AND COPY INTIAL VECTOR TO XUPDATE
C
      ANORM=SDOT(N,XIA,1,XIA,1)
C
C     DETERMINE SCALE FACTOR
C
      ASCALE=SQRT(ANORM)
C
C  IF INITIAL VECTOR EQUAL ZERO, WRITE WARNING
C
      IF(ASCALE/N.LT.CUTOFF) THEN
       WRITE(6,*) ' Warning form lineqz2 : the initial vector is zero.'
       ASCALE=ONE
      ENDIF
C
C     SCALE INITIAL VECTOR WITH ASCALE
C
      SCALE=ONE/ASCALE
      CALL SSCAL(N,SCALE,XIA,1)
C
      ASQUARE(1)=ONE
C
c YAU : old
c     CALL ICOPY(IINTFP*N,XIA,1,XUPDATE(1,1),1)
c YAU : new
      CALL DCOPY(N,XIA,1,XUPDATE(1,1),1)
c YAU : end
C
C  Now pick up the fock matrix elements needed for ADDFX.
C
      IF(ROHF.AND.SEMI) THEN
        CALL GETREC(20,'JOBARC','STANFIJA',NF1(1)*IINTFP,FIJ)
        CALL GETREC(20,'JOBARC','STANFIJB',NF1(2)*IINTFP,
     &              FIJ(NF1(1)+1))
        CALL GETREC(20,'JOBARC','STANFABA',NF2(1)*IINTFP,FAB)
        CALL GETREC(20,'JOBARC','STANFABB',NF2(2)*IINTFP,
     &              FAB(NF2(1)+1))
        CALL GETREC(20,'JOBARC','STANFAJB',NT(2)*IINTFP,FAJ)
c
      ELSEIF(ROHF) THEN
          CALL GETLST(FIJ(1),1,1,1,5,91+ISHIFT)
          CALL GETLST(FIJ(NF1(1)+1),1,1,1,6,91+ISHIFT)
          CALL GETLST(FAB(1),1,1,1,5,92+ISHIFT)
          CALL GETLST(FAB(NF2(1)+1),1,1,1,6,92+ISHIFT)
cJDW 10/4/95. this worries me a bit. is list same on parts 5 and 6 ??
c experiment. was         CALL GETLST(FAJ,1,1,1,5,93+ISHIFT)
c or should it be         CALL GETLST(FAJ,1,1,1,6,93+ISHIFT)       ?
cJDW 8/14/96. Yes, it should. With "5,93" ROHF with standard orbitals
c             fails. Thanks to Dan Crawford for reporting a bad gradient
c             and to JFS for detecting and fixing the error.
         CALL GETLST(FAJ,1,1,1,6,93+ISHIFT)
CJDW KKB stuff. PS code has the following.
c        CALL GETLST(FIJ(1),1,1,1,5,91)
c        CALL GETLST(FIJ(NF1(1)+1),1,1,1,6,91)
c        CALL GETLST(FAB(1),1,1,1,5,92)
c        CALL GETLST(FAB(NF2(1)+1),1,1,1,6,92)
c        CALL GETLST(FAJ,1,1,1,5,93)
C KKB had
c          CALL GETLST(FIJ(1),1,1,1,3,91+ISHIFT)
c          CALL GETLST(FIJ(NF1(1)+1),1,1,1,4,91+ISHIFT)
c          CALL GETLST(FAB(1),1,1,1,3,92+ISHIFT)
c          CALL GETLST(FAB(NF2(1)+1),1,1,1,4,92+ISHIFT)
c          CALL GETLST(FAJ,1,1,1,4,93+ISHIFT)
CJDW END
      ENDIF
C
C    LOOP OVER K UNTIL THE NEW VECTOR IS LINEAR DEPENDENT OR
C    KMAX IS REACHED
C
      DO 1000 K=1,KMAX
C
C  HERE THE LOGIC IS A LITTLE BIT MORE COMPLICATED
C
C  ACTUALLY WE HAVE TO DO FOUR MULTIPLICATION
C
      IF(INCORE) THEN
        IF(SEMI) CALL WTRANS(XIA,WMATOA,WMATVA,WMATOB,WMATVB,XSCR,0)
        CALL XGEMM('N','N',1,NA,NA,ONE,XIA,1,AMAT,NA,AZERO,XIANEW,1)
        CALL XGEMM('N','N',1,NB,NB,ONE,XIA(1+NA),1,AMAT(1+IOFF*NA*NA),
     &             NB,AZERO,XIANEW(1+NA),1)
        CALL XGEMM('N','T',1,NA,NB,ONE,XIA(1+NA),1,AMAT(1+IOFF*NA*NA+
     &             NB*NB),NA,ONE,XIANEW,1)
        CALL XGEMM('N','N',1,NB,NA,ONE,XIA,1,AMAT(1+IOFF*NA*NA+NB*NB),
     &             NA,ONE,XIANEW(1+NA),1)
        IF(SEMI) CALL WTRANS(XIA,WMATOA,WMATVA,WMATOB,WMATVB,XSCR,1)
        IF(SEMI) CALL WTRANS(XIANEW,WMATOA,WMATVA,WMATOB,WMATVB,XSCR,1)
        IF(ROHF) CALL ADDFX(XIA,XIANEW,FAB,FIJ,FAJ,LENAB,LENIJ,LENAJ,
     &                      NA,NB)
      ELSE
       DO 90 ISPIN=1,2
       IF(ISPIN.EQ.1) THEN
        N1=NA 
       ELSE
        N1=NB
       ENDIF
       LISTW=18+ISPIN + ISHIFT 
       CALL GETLST(AMAT,1,N1,2,1,LISTW)
       LISTW=22+ISPIN + ISHIFT 
       IOFFA=1+N1*N1
       CALL GETLST(AMAT(IOFFA),1,N1,2,1,LISTW)
       CALL SAXPY(N1*N1,ONEM,AMAT(IOFFA),1,AMAT,1)
       CALL XGEMM('N','N',1,N1,N1,ONE,XIA(1+(ISPIN-1)*NA),1,AMAT,N1,
     &            AZERO,XIANEW(1+(ISPIN-1)*NA),1)
90     CONTINUE
       LISTW=18 + ISHIFT 
       CALL GETLST(AMAT,1,NB,2,1,LISTW)
       CALL XGEMM('N','T',1,NA,NB,TWO,XIA(1+NA),1,AMAT,
     &            NA,ONE,XIANEW,1)
       CALL XGEMM('N','N',1,NB,NA,TWO,XIA,1,AMAT,NA,
     &            ONE,XIANEW(1+NA),1)
      ENDIF
      IF(ROHF) THEN
C
C ROHF CASE
C
       CALL ROHFZ(XIANEW,XIANEW(1+NA),EVALA,EVALB,POP(1,1),
     &            POP(1,2),VRT(1,1),VRT(1,2),NOCCA,NOCCB)
      ELSE
       IF(IQRHF.EQ.0) THEN
C
C  UHF CASE
C
        CALL FORMZ(XIANEW,EVALA,POP(1,1),VRT(1,1),NOCCA)
        CALL FORMZ(XIANEW(1+NA),EVALB,POP(1,2),VRT(1,2),NOCCB)
       ELSE
C
C  QRHF CASE
C
        CALL FORMZ(XIANEW,EVALA,POP(1,IQRHF),VRT(1,IQRHF),NOCCA)
        CALL FORMZ(XIANEW(1+NA),EVALB,POP(1,IQRHF),VRT(1,IQRHF),NOCCB)
       ENDIF
      ENDIF 
C
C    FORM ELEMENTS OF MATRIX ASMALL
C
      DO 100 L=1,K
      ASMALL(L,K)=SDOT(N,XUPDATE(1,L),1,XIANEW,1)
100   CONTINUE
      IF(K.GT.1) ASMALL(K,K-1)=ASQUARE(K)
C
C    ORTHOGONALIZE XIANEW TO PREVIOUS VECTORS
C
      DO 200 L=1,K
      SCALE=-ASMALL(L,K)/ASQUARE(L)
      CALL SAXPY(N,SCALE,XUPDATE(1,L),1,XIANEW,1)
200   CONTINUE
C
      ASQUARE(K+1)=SDOT(N,XIANEW,1,XIANEW,1)
c YAU : old
c     CALL ICOPY(IINTFP*N,XIANEW,1,XIA,1)
c     CALL ICOPY(IINTFP*N,XIANEW,1,XUPDATE(1,K+1),1)
c YAU : new
      CALL DCOPY(N,XIANEW,1,XIA,1)
      CALL DCOPY(N,XIANEW,1,XUPDATE(1,K+1),1)
c YAU : end
C
C  CHECK FOR CONVERGENCE OF THE CREATED ITERATIVE SUBSPACE
C
      TEST=ASQUARE(K+1)/N
      IF(TEST.LE.CUTOFF) THEN
       ASQUARE(K+1)=ONE
C
C      ITERATIVE EXPANSION HAS CONVERGED, EXIT THE LOOP
C
       GO TO 300
      ENDIF
1000  CONTINUE
C
C  IF WE REACH THIS POINT, THE ITERATIVE EXPANSION HAS NOT CONVERGED
C
      WRITE(6,3000)
3000  FORMAT('  The iterative expansion of D(ai) did not ',
     &           'converge, abort !')
      WRITE(6,3001)TEST
3001  FORMAT('  The convergence is : ',E20.10) 
      CALL ERREX
C
C   NOW INVERT THE ASMALL MATRIX
C
  300 CONTINUE
C
      WRITE(6,3002) K 
3002  FORMAT('  The iterative expansion of D(ai) ',
     &           'converged after ',I3,' iterations.')
C
C  SUBTRACT THE DIAGONAL PART 
C
C  NOTE THE ASMALL MATRIX CONSISTS OF SEVERAL PARTS
C
C  FIRST THE UPPER TRIANGLE WITH L LT K
C 
C    THAT'S SIMPLY    Y(L)  A Y(K)
C
C  THE DIAGONAL ELEMENTS
C
C   THAT'S   Y(K) A Y(K) - Y(K) Y(K)
C
C  THE LOWER TRIANGLE WITH L GT K+1
C
C  THESE ARE ZERO SINCE Y(L) SPANS A DIMENSION NOT COVERED BY A Y(K)
C
C  THE LOWER TRIANGLE WITH L EQ K+1
C
C  THESE ARE  Y(K+1) A(K) Y(K) =  Y(K+1) Y(K+1) = ASQUARE(K+1)
C
      DO 310 I=1,K
       ASMALL(I,I)=ASMALL(I,I)-ASQUARE(I)
310   CONTINUE
C
C  INVERT A (XIANEW IS HERE USED AS SCRATCH AND NO LONGER USED
C  FOR HOLDING A*Y
C
      CALL MINV(ASMALL,K,KMAX,XIANEW,DET,TOL,0,1)
C
      DO 330 I=1,K
       ASQUARE(I)=-ASCALE*ASMALL(I,1)
330   CONTINUE
C
C     NOW FORM SOLUTION IN XIA
C
      CALL ZERO(XIA,N)
      DO 340 I=1,K
       CALL SAXPY(N,ASQUARE(I),XUPDATE(1,I),1,XIA,1)
340   CONTINUE
C
C  The solution in XIA is in terms of standard (canonical) orbitals.
C  Call WTRANS one more time to rotate XIA to semicanonical orbitals.
C
      IF(SEMI) CALL WTRANS(XIA,WMATOA,WMATVA,WMATOB,WMATVB,XSCR,0)
C
C   ALL DONE, RETURN
C
      RETURN
      END
