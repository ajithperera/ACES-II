      SUBROUTINE XIA6AB(G,W,MAXSIZE,XIA,FACT,ISPIN,POP1,POP2,
     &                  VRT1,VRT2,DISSYT,NUMSYT,DISSYW,NUMSYW,
     &                  LISTG,LISTW,IRREP,TMP,IUHF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT,DISSYW,DISMAX,DISLEFT,DISREAD,DIRPRD,POP1,
     &        POP2,VRT1,VRT2
      DIMENSION G(DISSYT,1),W(DISSYW,1),XIA(1),TMP(1)
      DIMENSION POP1(8),POP2(8),VRT1(8),VRT2(8),IPX(8) 
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      common /dropgeo/ ndrgeo
C
      DATA ONE,ONEM,TWO /1.0D0,-1.D0,2.D0/
C
C PICK UP FIRST THE G AMPLITUDES 
C
      if (ndrgeo.eq.0) then
        CALL GETLST(G,1,NUMSYT,1,IRREP,LISTG)
      else  
       if (iuhf.eq.1 .and. ispin.eq.1) then 
        CALL GETGO4R(G,W,1,NUMSYT,1,IRREP,LISTG,ispin,listg,dissyt)
       else  
        CALL GETGO4(G,W,1,NUMSYT,1,IRREP,LISTG,ispin,listg,dissyt)
       endif 
      endif 
C
C SPIN ADAPTED CODE FOR RHF
C
      IF(IUHF.EQ.0) THEN
C
       CALL SPINAD3(IRREP,VRT1,DISSYT,NUMSYT,G,TMP,TMP(1+NUMSYT))
      ENDIF
C
C CHECK IF WE CAN DO THE CONTRACTION IN CORE
C
      IF(MAXSIZE.GT.DISSYW*NUMSYW) THEN
C
C FULL IN CORE ALGORITHM
C
       CALL GETLST(W,1,NUMSYW,2,IRREP,LISTW)   
C
C TRANSPOSE THE LAST TWO INDICES IN THE AA CASE (UHF ONLY)
C
       IF(ISPIN.EQ.1.AND.IUHF.EQ.1) THEN
        CALL SYMTR1(IRREP,POP1,VRT2,DISSYT,G,TMP,TMP(1+DISSYT),
     &              TMP(1+2*DISSYT))
        CALL SYMTR1(IRREP,VRT1,VRT2,DISSYW,W,TMP,TMP(1+DISSYW),
     &              TMP(1+2*DISSYW))
       ENDIF
C
C  PERFORM MULTIPLICATION
C
C  JOFFW AND JOFFG OFFSET IN THE RIGHTMOST BLOCK OF G AND W
C  IOFF OFFSET IN AIOV
C
       IOFF=1
       JOFFW=1
       JOFFG=1
       DO 90 IRREPI=1,NIRREP
C          
C  GET NUMBER OF OCUPIED AND VIRTUAL ORBITALS FOR IRREPJ
C
        NVRTI=VRT1(IRREPI)
        NOCCI=POP1(IRREPI)
C
C DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH IRREPJ GIVES IRREP
C
        IRREPJ=DIRPRD(IRREP,IRREPI)
C
C GET NUMBER OF VIRTUAL ORBITALS FOR IRREPJ
C
        NVRTJ=VRT2(IRREPJ)
C
C IF NVRTI OR NVRTJ EQUAL ZERO, NOTHING TO COMPUTE
C
        IF(MIN(NVRTJ,NVRTI,NOCCI).NE.0) THEN
C
          CALL XGEMM('T','N',NVRTI,NOCCI,DISSYT*NVRTJ,FACT,
     &              W(1,JOFFW),NVRTJ*DISSYT,G(1,JOFFG),
     &              NVRTJ*DISSYT,ONE,XIA(IOFF),NVRTI)
        ENDIF
C
C  UPDATE THE OFFSETS
C
        JOFFW=JOFFW+NVRTI*NVRTJ
        JOFFG=JOFFG+NOCCI*NVRTJ
        IOFF=IOFF+NVRTI*NOCCI
90     CONTINUE
C
      ELSE
C
C  THE CONTRACTION MUST BE DONE USINg AN OUT OF CORE ALGORITHM
C
       IF(ISPIN.EQ.1.AND.IUHF.EQ.1) THEN
C
C   AA CASE UHF ONLY
C
C      <Ef//Ag> G(Ef,Ig>
C
C   CALCULATE FIRST POINTERS FOR X(AI)
C
        IPX(1)=1
        DO 50 IRREPJ=1,NIRREP-1
         IRREPI=DIRPRD(IRREP,IRREPJ)
         IPX(IRREPJ+1)=IPX(IRREPJ)+POP1(IRREPJ)*VRT1(IRREPJ)
50      CONTINUE
C
C  DETERMINE MAXIMUM NUMBER OF DISTRIBUTIONS WHICH CAN BE HELD IN CORE
C
        MAXDIS=MAXSIZE/DISSYW 
C
C  SET OFFSET FOR INTEGRAL LIST AND FOR G LIST
C
        IOFFSET=1
        JOFFG=1
C
C  LOOP OVER ALL IRREPS OF THE LAST INDEX
C
        DO 200 IRREPJ=1,NIRREP
C
         NVRTJ=VRT2(IRREPJ)
         IRREPI=DIRPRD(IRREP,IRREPJ)
         NOCCI=POP1(IRREPI) 
         NVRTI=VRT1(IRREPI)
         IF(MIN(NOCCI,NVRTI,NVRTJ).NE.0) THEN
C
C  GET MAXIMUM NUMBER OF (Ef,A) BLOCKS WHICH CAN BE HELD IN CORE
C
         DISMAX=MAXDIS/NVRTI
         IF(DISMAX.LE.0) STOP 'XIA6AB'
C
C  DETERMINE NUMBER OF (Ef,A) BLOCKS WHICH MUST BE READ
C
          DISLEFT=NVRTJ
C
10        CONTINUE
C
C  GET NUMBER OF (Ef,A) BLOCKS WHICH ARE READ IN DURING THIS PASS
C
           DISREAD=MIN(DISLEFT,DISMAX)
           DISLEFT=DISLEFT-DISREAD
C
C  GET THE DISTRIBUTIONS FROM DISK
C
            CALL GETLST(W,IOFFSET,DISREAD*NVRTI,2,IRREP,LISTW)
C
C  UPDATE IOFFSET
C
            IOFFSET=IOFFSET+DISREAD*NVRTI
C
C  LOOP OVER ALL DISTRIBUTIONS AND PERFORM MULTIPLICATION
C
            IOFFW=1
            IOFF=IPX(IRREPI)
C
            DO 250 NUM=1,DISREAD
C
             CALL XGEMM('T','N',NVRTI,NOCCI,DISSYT,FACT,
     &                  W(1,IOFFW),DISSYW,G(1,JOFFG),
     &                  DISSYT,ONE,XIA(IOFF),NVRTI)
C
C UPDATE OFFSETS
C
             IOFFW=IOFFW+NVRTI
             JOFFG=JOFFG+NOCCI
C
250         CONTINUE
C
C  IF NOT ALL (Ef,A) BLOCKS HAVE BEEn PROCESSED, GO BACK TO 10
C
           IF(DISLEFT.NE.0) GO TO 10
C
          ELSE
C
C  UPDATE OFFSETS IN TEH CASE NOTHING HAS BEEN DONE
C
           JOFFG=JOFFG+NOCCI*NVRTJ
           IOFFSET=IOFFSET+NVRTI*NVRTJ
          ENDIF
200     CONTINUE
C
       ELSE IF(ISPIN.EQ.2.OR.IUHF.EQ.0) THEN
C
C   CALCULATE HERE
C
C      <Ef//Ga>  G(Ef,Gi)
C
C   DETERMINE MAXIMUM NUMBER OF DISTRIBUTIONS WHICH CAN BE HELD IN CORE
C
        MAXDIS=MAXSIZE/DISSYW
C
C   OFFSET FOR INTEGRAL LIST AND G AMPLITUDES
C
        IOFFSET=1
        JOFFG=1
        IOFF1=1
C
C  LOOP OVER IRREPS OF THE LAST INDEX
C
        DO 300 IRREPJ=1,NIRREP
C
         NOCCJ=POP1(IRREPJ)
         NVRTJ=VRT1(IRREPJ)
         IRREPI=DIRPRD(IRREP,IRREPJ)
         NVRTI=VRT2(IRREPI)
         IF(MIN(NVRTI,NVRTJ,NOCCJ).NE.0) THEN
C
C  MAXIMUM NUMBER OF (Ef,G) BLOCKS WHICH CAn BE HELD IN CORE
C
         DISMAX=MAXDIS/NVRTI
C
C  NUMBER OF (Ef,G) BLOCKS TO BE READ DURING THIS PASS
C
         DISLEFT=NVRTJ
C
         IOFF=0
C
20       CONTINUE 
C
C  NUMBER OF (Ef,G) BLOCKS WHICH ARE READ IN DURING THIS PASS
C
          DISREAD=MIN(DISLEFT,DISMAX)
          DISLEFT=DISLEFT-DISREAD
C
C  GET THE DISTRIBUTIONS FROM DISK
C
          CALL GETLST(W,IOFFSET,DISREAD*NVRTI,2,IRREP,LISTW)
C
C  UPDATE IOFFSET
C
          IOFFSET=IOFFSET+DISREAD*NVRTI
C
C  PERFORM MULTIPLICATION
C
          CALL XGEMM('T','N',DISREAD,NOCCJ,DISSYW*NVRTI,FACT,
     &               W,DISSYW*NVRTI,G(1,JOFFG),DISSYW*NVRTI, 
     &               ONE,XIA(IOFF1+IOFF),NVRTJ)
C
          IOFF=IOFF+DISREAD
C
C  IF NOT ALL (Ef,G) BLOCKS HAVE BEEN PROCESSED, GO BACK TO 20
C
          IF(DISLEFT.NE.0) GO TO 20
C
         ELSE
C
C  UPDATE OFFSETS IN THE CASE NOTHING HAS BEEN DONE
C 
          IOFFSET=IOFFSET+NVRTJ*NVRTI
         ENDIF
C
C  UPDATE OFFSETS
C
         IOFF1=IOFF1+NVRTJ*NOCCJ
         JOFFG=JOFFG+NOCCJ*NVRTI
300     CONTINUE
C
       ENDIF
      ENDIF
C   
      RETURN
      END
