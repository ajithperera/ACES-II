      SUBROUTINE IOV3AB(G,W,AIOV,FACT,ISPIN,POP1,POP2,VRT1,VRT2,
     &                  DISSYT,NUMSYT,DISSYW,NUMSYW,LISTG,LISTW,
     &                  IRREP,TMP,IUHF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT,DISSYW,DIRPRD,POP1,POP2,VRT1,VRT2
      DIMENSION G(DISSYT,1),W(NUMSYW,1),AIOV(1),POP1(8),POP2(8),
     &          VRT1(8),VRT2(8),TMP(1)
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      common /dropgeo/ ndrgeo
C
      DATA ONE /1.D0/
C
C      PICK UP THE INTEGRALS REQUIRED
C
      CALL GETLST(G,1,NUMSYW,2,IRREP,LISTW)
C
C  ISPIN=1   THE INTEGRALS ARE <Im//En> (ORDERING I,m,E,n)
C            CHANGE THE ORDERING TO  (E,n,m,I)
C            THIS INVOLVES A TRANSPOSITION OF (E,n) AND (I,m)
C            AND A TRANSPOSITION OF I and m
C  ISPIN=2   THE INTEGRALS ARE <Mi//Ne) (ORDERING M,i,N,e)
C            CHANGE THE ORDERING TO (e,N,M,i)
C            THIS INVOLVES A TRANSPOSITION OF N and e
C            AND A TRANSPOSITION OF (m,I) and (e,N)
C
C  RHF       THE INTEGRALS ARE <mI//nE> (ORDERING m,I,n,E)
C            CHANGE THE OREDERING TO (E,n,m,I)
C            THIS INVOLVES A TRANSPOSITION OF n and E 
C            AND A TRANSPOSITION OF (m,I) AND (N,e)
C            (THIS PREPARATION IS IDENTICAL TO ISPIN = 2)
C
      IF(ISPIN.EQ.2.OR.IUHF.EQ.0) THEN
      CALL SYMTR1(IRREP,POP2,VRT1,DISSYW,G,TMP,TMP(1+DISSYW),
     &            TMP(1+2*DISSYW))
      ENDIF
C
C  CHANGE OREDERING OF LIST FROM MI,EN TO EN MI
C 
      CALL TRANSP(G,W,NUMSYW,DISSYW)
C
      IF(ISPIN.EQ.1.AND.IUHF.EQ.1) THEN
       CALL SYMTR1(IRREP,POP1,POP2,NUMSYW,W,TMP,TMP(1+NUMSYW),
     &             TMP(1+2*NUMSYW))
      ENDIF
C
C  CHANGE ORDERING FROM En,Am TO En,Ma OR FROM eN, aM TO eN, Ma
C  
      if (ndrgeo.eq.0) CALL GETLST(G,1,NUMSYT,1,IRREP,LISTG)
      if (ndrgeo.eq.1) 
     x  CALL GETGO3R(G,TMP,1,NUMSYT,1,IRREP,LISTG,ispin,listg,dissyt,2)
      CALL SYMTR1(IRREP,VRT1,POP2,DISSYT,G,TMP,TMP(1+DISSYT),
     &            TMP(1+2*DISSYT))
C
C  NOW ALL ARRAYS HAVE BEEN SET UP FOR THE MULTIPLICATION
C
C  PERFORM MULTIPLICATION 
C
C  JOFFG OFFSET IN THE OCCUPIED-VIRTUAL BLOCK OF G 
C  JOFFW OFFSET IN THE OCCUPIED-OCCUPIED BLOCK OF W
C  IOFF OFFSET IN IOV
C
      IOFF=1
      JOFFG=1
      JOFFW=1
      DO 90 IRREPJ=1,NIRREP
C          
C        GET NUMBER OF VIRTUAL ORBITALS FOR IRREPJ     
C
       NOCCJ=POP1(IRREPJ)
       NVRTJ=VRT1(IRREPJ)
C
C        DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH IRREPJ GIVES IRREP
C
       IRREPI=DIRPRD(IRREP,IRREPJ)
C
C        GET NUMBER OF OCCUPIED ORBITALS FOR IRREPI
C
       NOCCI=POP2(IRREPI)
C
C        IF NOCCI, NOCCJ, OR NVRTJ EQUAL ZERO, NOTHING TO COMPUTE
C
       IF(MIN(NOCCI,NVRTJ,NOCCJ).NE.0) THEN
C
          CALL XGEMM('T','N',NVRTJ,NOCCJ,NOCCI*NUMSYT,FACT,
     &             G(1,JOFFG),NOCCI*NUMSYT,W(1,JOFFW),
     &             NOCCI*NUMSYT,ONE,AIOV(IOFF),NVRTJ)
       ENDIF
C
C  UPDATE OFFSETS
C
       JOFFG=JOFFG+NOCCI*NVRTJ
       JOFFW=JOFFW+NOCCI*NOCCJ
       IOFF=IOFF+NVRTJ*NOCCJ
90    CONTINUE
C
      RETURN
      END
