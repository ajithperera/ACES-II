      SUBROUTINE IOV4AB(G,MAXSIZE,W,AIOV,FACT,ISPIN,POP1,POP2,
     &                  VRT1,VRT2,DISSYT,NUMSYT,DISSYW,NUMSYW,
     &                  LISTG,LISTW,IRREP,TMP,IUHF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT,DISSYW,DISMAX,DISLEFT,DISREAD,DIRPRD,POP1,
     &        POP2,VRT1,VRT2
      DIMENSION G(DISSYT,1),W(DISSYW,1),AIOV(1),TMP(1)
      DIMENSION POP1(8),POP2(8),VRT1(8),VRT2(8),IPT(8)
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      common /dropgeo/ ndrgeo
C
      DATA ONE,ONEM,TWO /1.0D0,-1.D0,2.D0/
C
C      PICK UP FIRST INTEGRALS
C
      CALL GETLST(W,1,NUMSYW,2,IRREP,LISTW)
C
C  SPIN ADAPTED CODE FOR RHF
C
      IF(IUHF.EQ.0) THEN
       CALL SPINAD1(IRREP,POP1,DISSYW,W,TMP,TMP(1+DISSYW))
      ENDIF
C
C  DECIDE ABOUT THE ALGORITHM
C
      IF(MAXSIZE.GE.DISSYT*NUMSYT) THEN
C
C  FULL IN CORE ALGORITHM
C
       if (ndrgeo.eq.0) then
         CALL GETLST(G,1,NUMSYT,1,IRREP,LISTG)
       else 
        if (iuhf.eq.1 .and. ispin.eq.2) then 
         CALL GETGO4R(G,TMP,1,NUMSYT,1,IRREP,LISTG,ispin,listg,dissyt)
        else 
         CALL GETGO4(G,TMP,1,NUMSYT,1,IRREP,LISTG,ispin,listg,dissyt)
        endif 
       endif 
C
C  TRANSPOSE THE LAST TWO INDICES IN THE AA CASE
C
       IF(ISPIN.EQ.1) THEN
         CALL SYMTR1(IRREP,VRT1,POP2,DISSYT,G,TMP,TMP(1+DISSYT),
     &               TMP(1+2*DISSYT))
         CALL SYMTR1(IRREP,POP1,POP2,DISSYW,W,TMP,TMP(1+DISSYW),
     &               TMP(1+2*DISSYW))
       ENDIF
C
C  PERFORM MULTIPLICATION
C
C  JOFFW AND JOFFG OFFSET IN THE RIGHTMOST BLOCK OF G AND W
C  IOFF OFFSET IN AIVV
C
       IOFF=1
       JOFFW=1
       JOFFG=1
       DO 90 IRREPI=1,NIRREP
C          
C GET NUMBER OF VIRTUAL AND OCCUPIED ORBITALS FOR IRREPJ
C
        NVRTI=VRT1(IRREPI)
        NOCCI=POP1(IRREPI)
C
C DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH IRREPJ GIVES IRREP
C
        IRREPJ=DIRPRD(IRREP,IRREPI)
C
C GET NUMBER OF OCCUPIED ORBITALS FOR KRREP
C
        NOCCJ=POP2(IRREPJ)
C
C IF NVRTI, NOCCI, OR NOCCJ EQUAL ZERO, NOTHING TO COMPUTE
C
        IF(MIN(NOCCJ,NVRTI,NOCCI).NE.0) THEN
C
         CALL XGEMM('T','N',NVRTI,NOCCI,DISSYT*NOCCJ,FACT,
     &              G(1,JOFFG),NOCCJ*DISSYT,W(1,JOFFW),
     &              NOCCJ*DISSYT,ONE,AIOV(IOFF),NVRTI)
        ENDIF
C
C  UPDATE THE OFFSETS
C
        JOFFW=JOFFW+NOCCI*NOCCJ
        JOFFG=JOFFG+NOCCJ*NVRTI
        IOFF=IOFF+NVRTI*NOCCI
90     CONTINUE
C
      ELSE
C
C  WE HAVE TO DO IT OUT OF CORE
C
      IF (NDRGEO.NE.0) THEN
        if (iuhf.eq.1 .and. ispin.eq.2) then 
         CALL GETINO4R(TMP,NUMSYT,DISSYT,LISTG,IRREP)
        else 
         CALL GETINO4 (TMP,NUMSYT,DISSYT,LISTG,IRREP)
        endif 
        ITIN = 1 + NUMSYT+1 
        NIKI = 1
        IODRSET = 1
       ENDIF 
C      
C
C  DIFFER BETWEEN THE TWO SPIN CASES
C
       IF(ISPIN.EQ.1) THEN
C
C  GET OFFSETS FOR AIOV
C
        IPT(1)=1
        DO 150 IRREPJ=1,NIRREP-1
         IPT(IRREPJ+1)=IPT(IRREPJ)+POP1(IRREPJ)*VRT1(IRREPJ)
150     CONTINUE
C
C  DETERMINE MAXIMUM NUMBER OF DISTRIBUTIONS WHICH FIT INTO CORE
C
        MAXDIS=MAXSIZE/DISSYT
C
C  SET OFFSETS FOR GAMMA LIST AND INTEGRALS
C
        IOFFSET=1
        JOFFW=1
C
C  LOOP OVER IORREPS OF THE LAST INDEX
C
        DO 200 IRREPJ=1,NIRREP
C
         NOCCJ=POP2(IRREPJ) 
         IRREPI=DIRPRD(IRREP,IRREPJ)
         NOCCI=POP1(IRREPI)
         NVRTI=VRT1(IRREPI)
         IF(MIN(NOCCJ,NOCCI,NVRTI).NE.0) THEN
C
C  DETERMINE MAXIMUM NUMBER OF (Ef,A) BLOCKS WHCIH CAN BE HELD IN CORE
C 
          DISMAX=MAXDIS/NVRTI
          IF(DISMAX.LE.0) STOP 'IOV4AB'
C
C  GET NUMBER OF (Ef,A) BLOCKS WHICH HAVE TO BE READ IN
C
          DISLEFT=NOCCJ
C
10        CONTINUE
C
C DETERMINE NUMBER OF (Ef,A) BLOCKS WHICH ARE READ DURING THIS PASS
C
           DISREAD=MIN(DISLEFT,DISMAX)
           DISLEFT=DISLEFT-DISREAD
C
C GET THE DISTRIBUTIONS FROM DISK
C
          if (ndrgeo.eq.0) then 
           CALL GETLST(G,IOFFSET,DISREAD*NVRTI,1,IRREP,LISTG)
          else 
           CALL GETGO4O(G,TMP(ITIN),IODRSET,DISREAD*NVRTI,1,IRREP,LISTG,
     x                      ispin,listg,dissyt,TMP,NIKI)
          endif 
C
C UPDATE OFFSETS
C
           IOFFSET=IOFFSET+DISREAD*NVRTI
C
C LOPP OVER ALL DISTRIBUTIONS AND PERFORM MULTIPLICATION
C
           IOFF=IPT(IRREPI)
           JOFFG=1
C
           DO 250 NUM=1,DISREAD
C
             CALL XGEMM('T','N',NVRTI,NOCCI,DISSYW,FACT,
     &                 G(1,JOFFG),DISSYW,W(1,JOFFW),DISSYW,
     &                 ONE,AIOV(IOFF),NVRTI)
C
C  UPDATE OFFSETS
C
            JOFFW=JOFFW+NOCCI
            JOFFG=JOFFG+NVRTI
C
250        CONTINUE
C
C IF NOT ALL (Ef,A) BLOCKS HAVE BEEN PROCESSED, GO BACK TO 10
C
          IF(DISLEFT.NE.0) GO TO 10 
C
         ELSE
C
C  UPDATE OFFSETS IN TEH CASE NOTHING HAS BEEN DONE
C
          JOFFW=JOFFW+NOCCI*NOCCJ
          IOFFSET=IOFFSET+NOCCJ*NVRTI
         ENDIF
C
200     CONTINUE
C
C  SECOND SPIN CASE
C
       ELSE    
C
C DETERMINE MAXIMUM NUMBER OF DISTRIBUTIONS WHICH FIT INTO CORE
C
        MAXDIS=MAXSIZE/DISSYT
C
C OFFSET FOR GAMMA LIST, INTEGRALS, AND AIOV
C
        IOFFSET=1
        JOFFW=1
        IOFF1=1
C
C LOOP OVER IRREPS OF THE LAST INDEX
C
        DO 300 IRREPJ=1,NIRREP
C 
         NOCCJ=POP1(IRREPJ)
         NVRTJ=VRT1(IRREPJ)
         IRREPI=DIRPRD(IRREP,IRREPJ)
         NOCCI=POP2(IRREPI)
         IF(MIN(NOCCI,NOCCJ,NVRTJ).NE.0) THEN
C
C  MAXIMUM NUMBER OF (Ef,M) BLOCKS WHICH CAN BE HELD IN CORE
C
          DISMAX=MAXDIS/NOCCI
C
C  NUMBER OF (Ef,M) BLOCKS TO READ
C
          DISLEFT=NVRTJ
C
          IOFF=0 
C
20        CONTINUE
C
C  NUMBER OF (ef,M) BLOCKS WHICH ARE READ IN DURING THIS PASS
C
           DISREAD=MIN(DISLEFT,DISMAX)
           DISLEFT=DISLEFT-DISREAD
C
C  GET THE DISTRIBUTIONS FROM DISK
C
          if (ndrgeo.eq.0) then
            CALL GETLST(G,IOFFSET,DISREAD*NOCCI,1,IRREP,LISTG)
          else
           CALL GETGO4O(G,TMP(ITIN),IODRSET,DISREAD*NOCCI,1,IRREP,LISTG,
     x           ispin,listg,dissyt,TMP,NIKI)
          endif 
C
C  UPDATE IOFFSET
C
           IOFFSET=IOFFSET+DISREAD*NOCCI
C
C  PERFORM MULTIPLICATION 
C
           CALL XGEMM('T','N',DISREAD,NOCCJ,DISSYW*NOCCI,FACT,
     &                G,DISSYW*NOCCI,W(1,JOFFW),DISSYW*NOCCI,
     &                ONE,AIOV(IOFF1+IOFF),NVRTJ)
C
           IOFF=IOFF+DISREAD
C
C IF NOT ALL (Ef,M) BLOCKS HAVE BEEN PROCESSED, GO BACK TO 20
C
          IF(DISLEFT.NE.0) GO TO 20
C
         ELSE
C
C UPDATE OFFSETS IN THE CASE NOTHING HAS BEEN DONE
C
          IOFFSET=IOFFSET+NVRTJ*NOCCI
         ENDIF
C
C  UPDATE OFFSETS
C
         IOFF1=IOFF1+NOCCJ*NVRTJ
         JOFFW=JOFFW+NOCCJ*NOCCI
C  
300     CONTINUE
C
       ENDIF
C
      ENDIF
C 
      RETURN
      END
