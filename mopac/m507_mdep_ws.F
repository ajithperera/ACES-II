      SUBROUTINE POWSQ(XPARAM, NVAR, FUNCT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
C
      DIMENSION XPARAM(*)
      COMMON /MESAGE/ IFLEPO,ISCF
**********************************************************************
*
*   POWSQ OPTIMIZES THE GEOMETRY BY MINIMISING THE GRADIENT NORM.
*         THUS BOTH GROUND AND TRANSITION STATE GEOMETRIES CAN BE
*         CALCULATED. IT IS ROUGHLY EQUIVALENT TO FLEPO, FLEPO MINIMIZES
*         THE ENERGY, POWSQ MINIMIZES THE GRADIENT NORM.
*
*  ON ENTRY XPARAM = VALUES OF PARAMETERS TO BE OPTIMIZED.
*           NVAR   = NUMBER OF PARAMETERS TO BE OPTIMIZED.
*
*  ON EXIT  XPARAM = OPTIMIZED PARAMETERS.
*           FUNCT  = HEAT OF FORMATION IN KCALS.
*
**********************************************************************
C        *****  ROUTINE PERFORMS  A LEAST SQUARES MINIMIZATION  *****
C        *****  OF A FUNCTION WHICH IS A SUM OF SQUARES.        *****
C        *****  INITIALLY WRITTEN BY J.W. MCIVER JR. AT SUNY/   *****
C        *****  BUFFALO, SUMMER 1971.  REWRITTEN AND MODIFIED   *****
C        *****  BY A.K. AT SUNY BUFFALO AND THE UNIVERSITY OF   *****
C        *****  TEXAS.  DECEMBER 1973                           *****
C
      COMMON /GEOVAR/ XDUMMY(MAXPAR),NDUM,LOC(2,MAXPAR)                 IR0394
      COMMON /GEOM  / GEO(3,NUMATM)
      COMMON /LAST  / LAST
      COMMON /KEYWRD/ KEYWRD
      COMMON /TIMER / TIME0
      COMMON /NUMSCF/ NSCF
      COMMON /GEOSYM/ NDEP,LOCPAR(MAXPAR),IDEPFN(MAXPAR),LOCDEP(MAXPAR)
      COMMON /GRADNT/ GRAD(MAXPAR),GNFINA
      COMMON /GEOKST/ NATOMS,LABELS(NUMATM),
     1                NA(NUMATM),NB(NUMATM),NC(NUMATM)
C Common MOLKST splitted in MOLKSI and MOLKSR    Ivan Rossi 0394   &8)
      COMMON /MOLKSI/ NUMAT,NAT(NUMATM),NFIRST(NUMATM),
     1                NMIDLE(NUMATM),NLAST(NUMATM), NORBS,
     2                NELECS,NALPHA,NBETA,NCLOSE,NOPEN
     3       /MOLKSR/ FRACT
      COMMON /NUMCAL/ NUMCAL
      COMMON /SIGMA1/ GNEXT, AMIN, ANEXT
      COMMON /SIGMA2/ GNEXT1(MAXPAR), GMIN1(MAXPAR)
      COMMON /NLLCOM/ HESS(MAXPAR,MAXPAR),BMAT(MAXPAR,MAXPAR),
     1                PMAT(MAXPAR*MAXPAR)
      COMMON /SCRACH/ PVEC
      DIMENSION IPOW(9), SIG(MAXPAR),
     1          E1(MAXPAR), E2(MAXPAR),
     2          P(MAXPAR), WORK(MAXPAR),
     3          PVEC(MAXPAR*MAXPAR), EIG(MAXPAR), Q(MAXPAR)
      DIMENSION ISWAP(3)
      LOGICAL DEBUG, RESTRT, TIMES, OKC, OKF, ROUGH, SCF1, RESFIL
      CHARACTER*80 KEYWRD
      CHARACTER SPACE*1, CHDOT*1, ZERO*1, NINE*1, CH*1
         SAVE                                                           GL0892
      DATA SPACE,CHDOT,ZERO,NINE /' ','.','0','9'/
      DATA  ICALCN /0/, ISWAP /2,3,1/
      IF(ICALCN.NE.NUMCAL) THEN
         ICALCN=NUMCAL
         RESTRT=(INDEX(KEYWRD,'RESTART') .NE. 0)
         SCF1=(INDEX(KEYWRD,'1SCF') .NE. 0)
         ROUGH=.FALSE.
cmgc         TIME1=SECOND()
         TIME2=TIME1
         ICYC=0
         TIMES=(INDEX(KEYWRD,'TIME') .NE. 0)
         TOTIME=MAXTIM
         I=INDEX(KEYWRD,' T=')
         IF(I.NE.0) THEN
            TIM=READA(KEYWRD,I)
            DO 10 J=I+3,80
               CH=KEYWRD(J+1:J+1)
               IF( CH .EQ.' ') THEN
                  CH=KEYWRD(J:J)
                  IF( CH .EQ. 'M') TIM=TIM*60
                  IF( CH .EQ. 'H') TIM=TIM*3600
                  IF( CH .EQ. 'D') TIM=TIM*86400
                  GOTO 20
               ENDIF
   10       CONTINUE
   20       TOTIME=TIM
            WRITE(6,'(//10X,'' TIME FOR THIS STEP ='',F10.2,
     1'' SECONDS'')')TOTIME
         ENDIF
         TLEFT=TOTIME
         TLAST=TOTIME
         TDUMP=MAXDMP
         I=INDEX(KEYWRD,' DUMP')
         IF(I.NE.0) THEN
            TDUMP=READA(KEYWRD,I)
            DO 30 J=I+7,80
               CH=KEYWRD(J:J)
               IF( CH .NE. CHDOT .AND. (CH .LT. ZERO .OR. CH .GT. NINE))
     1 THEN
                  IF( CH .EQ. 'M') TDUMP=TDUMP*60
                  GOTO 40
               ENDIF
   30       CONTINUE
   40       CONTINUE
         ENDIF
         RESFIL=.FALSE.
         STEP=0.02D0
         LAST=0
         ILOOP=1
         NAT3=NUMAT*3
         XINC=0.00529167D0
         RHO2=1.D-4
         TOL2=4.D-1
         IF(INDEX(KEYWRD,'PREC') .NE. 0) TOL2=1.D-2
         IF(INDEX(KEYWRD,'GNORM') .NE. 0) THEN
            TOL2=READA(KEYWRD,INDEX(KEYWRD,'GNORM'))
            IF(TOL2.LT.0.001.AND.INDEX(KEYWRD,'LET').EQ.0)THEN
               WRITE(6,'(/,A)')'  GNORM HAS BEEN SET TOO LOW, RESET TO 0
     1.001'
               TOL2=0.001D0
            ENDIF
         ENDIF
         DEBUG = (INDEX(KEYWRD,'POWSQ') .NE. 0)
         IF(RESTRT) THEN
C
C   RESTORE STORED DATA
C
            IPOW(9)=0
            CALL POWSAV(HESS,GMIN1,XPARAM,PMAT,ILOOP,BMAT,IPOW)
            NSCF=IPOW(8)
            DO 50 I=1,NVAR
               GRAD(I)=GMIN1(I)
   50       GNEXT1(I)=GMIN1(I)
            WRITE(6,'('' XPARAM'',6F10.6)')(XPARAM(I),I=1,NVAR)
            IF(ILOOP .GT. 0) THEN
C#               ILOOP=ILOOP+1
               WRITE(6,'(//10X,'' RESTARTING AT POINT'',I3)')ILOOP
            ELSE
               WRITE(6,'(//10X,''RESTARTING IN OPTIMISATION'',
     1         '' ROUTINES'')')
            ENDIF
         ENDIF
*
*   DEFINITIONS:   NVAR   = NUMBER OF GEOMETRIC VARIABLES = 3*NUMAT-6
*
      ENDIF
      NVAR=ABS(NVAR)
      IF(DEBUG) THEN
         WRITE(6,'('' XPARAM'')')
         WRITE(6,'(5(2I3,F10.4))')(LOC(1,I),LOC(2,I),XPARAM(I),I=1,NVAR)
      ENDIF
      IF( .NOT. RESTRT) THEN
         DO 60 I=1,NVAR
   60    GRAD(I)=0.D0
         CALL COMPFG(XPARAM, .TRUE., FUNCT, .TRUE., GRAD, .TRUE.)
      ENDIF
      IF(DEBUG) THEN
         WRITE(6,'('' STARTING GRADIENTS'')')
         WRITE(6,'(3X,8F9.4)')(GRAD(I),I=1,NVAR)
      ENDIF
      GMIN=SQRT(ddot(nvar,grad,1,grad,1))
      GLAST=GMIN
      DO 70 I=1,NVAR
         GNEXT1(I)=GRAD(I)
         GMIN1(I)=GNEXT1(I)
   70 CONTINUE
C
C    NOW TO CALCULATE THE HESSIAN MATRIX.
C
      IF(ILOOP.LT.0) GOTO 180
C
C   CHECK THAT HESSIAN HAS NOT ALREADY BEEN CALCULATED.
C
      ILPR=ILOOP
      DO 90 ILOOP=ILPR,NVAR
cmgc         TIME1=SECOND()
         XPARAM(ILOOP)=XPARAM(ILOOP) + XINC
         CALL COMPFG(XPARAM, .TRUE., FUNCT, .TRUE., GRAD, .TRUE.)
         IF(SCF1) GOTO 430
         IF(DEBUG)WRITE(6,'(I3,12(8F9.4,/3X))')
     1    ILOOP,(GRAD(IF),IF=1,NVAR)
         GRAD(ILOOP)=GRAD(ILOOP)+1.D-5
         XPARAM(ILOOP)=XPARAM(ILOOP) - XINC
         DO 80 J=1,NVAR
   80    HESS(ILOOP,J)=-(GRAD(J)-GNEXT1(J))/XINC
cmgc         TIME2=SECOND()
         TSTEP=TIME2-TIME1
         IF(TIMES)WRITE(6,'('' TIME FOR STEP:'',F8.2,'' LEFT'',F8.2)')
     1    TSTEP, TLEFT
         IF(TLAST-TLEFT.GT.TDUMP)THEN
            TLAST=TLEFT
            RESFIL=.TRUE.
            IPOW(9)=2
            I=ILOOP
            IPOW(8)=NSCF
            CALL POWSAV(HESS,GMIN1,XPARAM,PMAT,I,BMAT,IPOW)
         ENDIF
         IF( TLEFT .LT. TSTEP*2.D0) THEN
C
C  STORE RESULTS TO DATE.
C
            IPOW(9)=1
            I=ILOOP
            IPOW(8)=NSCF
            CALL POWSAV(HESS,GMIN1,XPARAM,PMAT,I,BMAT,IPOW)
            STOP
         ENDIF
   90 CONTINUE
C        *****  SCALE -HESSIAN- MATRIX                           *****
      IF( DEBUG) THEN
         WRITE(6,'(//10X,''UN-NORMALIZED HESSIAN MATRIX'')')
         DO 100 I=1,NVAR
  100    WRITE(6,'(8F10.4)')(HESS(J,I),J=1,NVAR)
      ENDIF
      DO 120 I=1,NVAR
         SUM = 0.0D0
         DO 110 J=1,NVAR
  110    SUM = SUM+HESS(I,J)**2
  120 WORK(I) = 1.0D0/SQRT(SUM)
      DO 130 I=1,NVAR
         DO 130 J=1,NVAR
  130 HESS(I,J) = HESS(I,J)*WORK(I)
      IF( DEBUG) THEN
         WRITE(6,'(//10X,''HESSIAN MATRIX'')')
         DO 140 I=1,NVAR
  140    WRITE(6,'(8F10.4)')(HESS(J,I),J=1,NVAR)
      ENDIF
C        *****  INITIALIZE B MATIRX                        *****
      DO 160 I=1,NVAR
         DO 150 J=1,NVAR
  150    BMAT(I,J) = 0.0D0
  160 BMAT(I,I) = WORK(I)*2.D0
************************************************************************
*
*  THIS IS THE START OF THE BIG LOOP TO OPTIMIZE THE GEOMETRY
*
************************************************************************
      ILOOP=-99
      TSTEP=TSTEP*4
  170 CONTINUE
      IF(TLAST-TLEFT.GT.TDUMP)THEN
         TLAST=TLEFT
         RESFIL=.TRUE.
         IPOW(9)=2
         I=ILOOP
         IPOW(8)=NSCF
         CALL POWSAV(HESS,GMIN1,XPARAM,PMAT,I,BMAT,IPOW)
      ENDIF
      IF( TLEFT .LT. TSTEP*2.D0) THEN
C
C  STORE RESULTS TO DATE.
C
         IPOW(9)=1
         I=ILOOP
         IPOW(8)=NSCF
         CALL POWSAV(HESS,GMIN1,XPARAM,PMAT,I,BMAT,IPOW)
         STOP
      ENDIF
  180 CONTINUE
C        *****  FORM-A- DAGGER-A- IN PA SLONG WITH -P-     *****
      IJ=0
      DO 200 J=1,NVAR
         DO 200 I=1,J
            IJ=IJ+1
            SUM = 0.0D0
            DO 190 K=1,NVAR
  190       SUM = SUM + HESS(I,K)*HESS(J,K)
  200 PMAT(IJ) = SUM
      DO 220 I=1,NVAR
         SUM = 0.0D0
         DO 210 K=1,NVAR
  210    SUM = SUM-HESS(I,K)*GMIN1(K)
  220 P(I) = -SUM
      L=0
      IF(DEBUG) THEN
         WRITE(6,'(/10X,''P MATRIX IN POWSQ'')')
         CALL VECPRT(PMAT,NVAR)
      ENDIF
      CALL HQRII(PMAT,NVAR,NVAR,EIG,PVEC)
C        *****  CHECK FOR ZERO EIGENVALUE                  *****
C#      WRITE(6,'(''  EIGS IN POWSQ:'')')
C#      WRITE(6,'(6F13.8)')(EIG(I),I=1,NVAR)
      IF(EIG(1).LT.RHO2) GO TO 280
      INDC = 2
C        *****  IF MATRIX IS NOT SINGULAR FORM INVERSE     *****
C        *****  BY BACK TRANSFORMING THE EIGENVECTORS      *****
      IJ=0
      DO 240 I=1,NVAR
         DO 240 J=1,I
            IJ=IJ+1
            SUM = 0.0D0
            DO 230 K=1,NVAR
  230       SUM = SUM+PVEC((K-1)*NVAR+J)*PVEC((K-1)*NVAR+I)/EIG(K)
  240 PMAT(IJ) = SUM
C        *****  FIND -Q- VECTOR                            *****
      L=0
      IL=L+1
      L=IL+I-1
      DO 270 I=1,NVAR
         SUM = 0.0D0
         DO 250 K=1,I
            IK=(I*(I-1))/2+K
  250    SUM = SUM+PMAT(IK)*P(K)
         IP1=I+1
         DO 260 K=IP1,NVAR
            IK=(K*(K-1))/2+I
  260    SUM=SUM+PMAT(IK)*P(K)
  270 Q(I) = SUM
      GO TO 300
  280 CONTINUE
C        *****  TAKE  -Q- VECTOR AS EIGENVECTOR OF ZERO     *****
C        *****  EIGENVALUE                                 *****
      DO 290 I=1,NVAR
  290 Q(I) = PVEC(I)
  300 CONTINUE
C        *****  FIND SEARCH DIRECTION                      *****
      DO 310 I=1,NVAR
         SIG(I) = 0.0D0
         DO 310 J=1,NVAR
  310 SIG(I) = SIG(I) + Q(J)*BMAT(I,J)
C        *****  DO A ONE DIMENSIONAL SEARCH                *****
      IF (DEBUG) THEN
         WRITE(6,'('' SEARCH VECTOR'')')
         WRITE(6,'(8F10.5)')(SIG(I),I=1,NVAR)
      ENDIF
      CALL SEARCH(XPARAM, ALPHA, SIG, NVAR, GMIN, OKC, OKF, FUNCT)
      IF( NVAR .EQ. 1) GOTO 430
C
C  FIRST WE ATTEMPT TO OPTIMIZE GEOMETRY USING SEARCH.
C  IF THIS DOES NOT WORK, THEN SWITCH TO LINMIN, WHICH ALWAYS WORKS,
C  BUT IS TWICE AS SLOW AS SEARCH.
C
      ROUGH=  (   .NOT.  OKF)
      rmx = abs(gmin1(idamax(nvar,gmin1,1)))
      IF(RMX.LT.TOL2) GO TO 430
C        *****  TWO STEP ESTIMATION OF DERIVATIVES         *****
      DO 330 K=1,NVAR
  330 E1(K) = (GMIN1(K)-GNEXT1(K))/(AMIN-ANEXT)
      RMU = ddot(nvar,E1,1,GMIN1,1)/ddot(nvar,gmin1,1,gmin1,1)
      DO 340 K=1,NVAR
  340 E2(K) = E1(K) - RMU*GMIN1(K)
C        *****  SCALE -E2- AND -SIG-                       *****
      SK = 1.0D0/SQRT(ddot(nvar,E2,1,E2,1))
      DO 350 K=1,NVAR
  350 SIG(K) = SK*SIG(K)
      DO 360 K=1,NVAR
  360 E2(K) = SK*E2(K)
C        *****  FIND INDEX OF REPLACEMENT DIRECTION        *****
      PMAX = -1.0D+20
      DO 370 I=1,NVAR
         IF(ABS(P(I)*Q(I)).LE.PMAX) GO TO 370
         PMAX = ABS(P(I)*Q(I))
         ID = I
  370 CONTINUE
C        *****  REPLACE APPROPRIATE DIRECTION AND DERIVATIVE ***
      DO 380 K=1,NVAR
  380 HESS(ID,K) = -E2(K)
C        *****  REPLACE STARTING POINT                     *****
      DO 390 K=1,NVAR
  390 BMAT(K,ID) = SIG(K)/0.529167D0
      DO 400 K=1,NVAR
  400 GNEXT1(K) = GMIN1(K)
      GLAST = GMIN
      INDC = 1
      TIME1=TIME2
cmgc      TIME2=SECOND()
      TLEFT=TOTIME-TIME2+TIME0
      TSTEP=TIME2-TIME1
      ICYC=ICYC+1
      IF(RESFIL)THEN
         WRITE(6,410)TLEFT,GMIN,FUNCT
  410    FORMAT('  RESTART FILE WRITTEN,  TIME LEFT:',F9.1,
     1' GRAD.:',F10.3,' HEAT:',G14.7)
         RESFIL=.FALSE.
      ELSE
         WRITE(6,420)ICYC,TSTEP,TLEFT,GMIN,FUNCT
  420    FORMAT(' CYCLE:',I5,' TIME:',F6.1,' TIME LEFT:',F9.1,
     1' GRAD.:',F10.3,' HEAT:',G14.7)
      ENDIF
      IF(TIMES)WRITE(6,'('' TIME FOR STEP:'',F8.2,'' LEFT'',F8.2)')
     1TSTEP, TLEFT
      GO TO 170
  430 CONTINUE
      DO 440 I=1,NVAR
  440 GRAD(I)=0.D0
      LAST=1
      CALL COMPFG(XPARAM, .TRUE., FUNCT, .TRUE., GRAD, .TRUE.)
      DO 450 I=1,NVAR
  450 GRAD(I)=GMIN1(I)
      GNFINA=SQRT(ddot(nvar,grad,1,grad,1))
      IFLEPO=11
      RETURN
      END
      SUBROUTINE DIAG(FAO,VECTOR,NOCC,EIG,MDIM,N)
C***********************************************************************
C
C   "FAST" DIAGONALISATION PROCEDURE.
C
C             ************************************************
C             * CRAY VERSION: CONVERTS FAO FROM PACKED FORM  *
C             * TO SQUARE MATRIX FORM, DESTROYING ORIGINAL   *
C             * FORM OF FAO IN THE PROCESS (BEWARE!!!)       *
C             ************************************************
C
C    ON INPUT FAO CONTAINS THE LOWER HALF TRIANGLE OF THE MATRIX
C             TO BE DIAGONALIZED, IN PACKED FORM.
C             VECTOR  CONTAINS THE OLD EIGENVECTORS ON INPUT, THE NEW
C             VECTORS ON EXITING.
C             NOCC = NUMBER OF OCCUPIED MOLECULAR ORBITALS.
C             EIG  = EIGENVALUES FROM AN EXACT DIAGONALISATION
C             MDIM = DECLARED SIZE OF MATRIX "C".
C             N = NUMBER OF ATOMIC ORBITALS IN BASIS SET
C
C  DIAG IS A PSEUDO-DIAGONALISATION PROCEDURE, IN THAT THE VECTORS THAT
C       ARE GENERATED BY IT ARE MORE NEARLY ABLE TO BLOCK-DIAGONALISE
C       THE FOCK MATRIX OVER MOLECULAR ORBITALS THAN THE STARTING
C       VECTORS. IT MUST BE CONSIDERED PSEUDO FOR SEVERAL REASONS:
C       (A) IT DOES NOT GENERATE EIGENVECTORS - THE SECULAR DETERMINANT
C           IS NOT DIAGONALISED, ONLY THE OCCUPIED-VIRTUAL INTERSECTION.
C       (B) MANY SMALL ELEMENTS IN THE SEC.DET. ARE IGNORED AS BEING TOO
C           SMALL COMPARED WITH THE LARGEST ELEMENT.
C       (C) WHEN ELEMENTS ARE ELIMINATED BY ROTATION, THE REST OF THE
C           SEC. DET. IS ASSUMED NOT TO CHANGE, I.E. ELEMENTS CREATED
C           ARE IGNORED.
C       (D) THE ROTATION REQUIRED TO ELIMINATE THOSE ELEMENTS CONSIDERED
C           SIGNIFICANT IS APPROXIMATED TO USING THE EIGENVALUES OF THE
C           EXACT DIAGONALISATION THROUGHOUT THE REST OF THE ITERATIVE
C           PROCEDURE.
C
C  (NOTE:- IN AN ITERATIVE PROCEDURE ALL THE APPROXIMATIONS PRESENT IN
C          DIAG BECOME VALID AT SELF-CONSISTENCY, SELF-CONSISTENCY IS
C          NOT SLOWED DOWN BY USE OF THESE APPROXIMATIONS)
C
C    REFERENCE:
C             "FAST SEMIEMPIRICAL CALCULATIONS",
C             STEWART. J.J.P., CSASZAR, P., PULAY, P., J. COMP. CHEM.,
C             3, 227, (1982)
C
C***********************************************************************
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
#include "mopcvar.par"
C
************************************************************************
      DIMENSION FAO(*),VECTOR(MDIM,*),EIG(*)
C---WORKSPACE ARRAYS
      DIMENSION WS(MAXORB), SQFAO(MAXORB,MAXORB)
      COMMON /SCRACH/ FMO(MAXORB,MAXORB), XDUMY(MAXPAR**2-MORB2)
      COMMON /ETAEPS/ ETA, EPS
         SAVE                                                           GL0892
************************************************************************
*
*   TAKES A PACKED LOWER-TRIANGULAR MATRIX IN ARRAY FAO AND
*   RE-ARRANGES IT INTO A PACKED SQUARE MATRIX IN THE SAME SPACE.
*
************************************************************************
C
C  FIRST FILL ONE HALF OF THE SQUARE MATRIX.
C
      L=(N*(N+1))/2+1
      DO 10 I=N,1,-1
         DO 10 J=I,1,-1
            L=L-1
   10 SQFAO(j,i) = FAO(l)
C
C  NOW FILL OTHER HALF OF THE SQUARE MATRIX.
C
      DO 20 I=1,N
         DO 20 J=I+1,N
   20 SQFAO(j,i)= SQFAO(i,j)
************************************************************************
      TINY = 0.0
C--- EPS IS THE SMALLEST NUMBER WHICH, WHEN ADDED TO 1.0,
C--- IS NOT EQUAL TO 1.0.  BIGEPS ACCOUNTS FOR ROUND-OFF
      BIGEPS = 100.0*EPS
      LUMO=NOCC+1
C---THIS LOOP REDONE BY ERICH WIMMER (CRAY RESEARCH)
      DO 90 I=LUMO,N
C
         DO 30 M=1,N
            WS(M) = SQFAO(M,1)*VECTOR(1,I)
   30    CONTINUE
C
         DO 50 K=2,N
            DO 40 M=1,N
               WS(M) = WS(M) + SQFAO(M,K)*VECTOR(K,I)
   40       CONTINUE
   50    CONTINUE
C
         DO 60 J=1,NOCC
            FMO(J,I) = VECTOR(1,J)*WS(1)
   60    CONTINUE
C
         DO 80 M=2,N
            DO 70 J=1,NOCC
               FMO(J,I) = FMO(J,I) + VECTOR(M,J)*WS(M)
   70       CONTINUE
   80    CONTINUE
         km=idamax(nocc,fmo(1,i),1)
         tiny=max(tiny,abs(fmo(km,i)))
C
   90 CONTINUE
      TINY = 0.04D0*TINY
C***********************************************************************
C
C   NOW DO A CRUDE 2 BY 2 ROTATION TO "ELIMINATE" SIGNIFICANT ELEMENTS
C
C***********************************************************************
      DO 120 I=LUMO,N
         DO 110 J=1,NOCC
            IF(ABS(FMO(J,I)) .LT. TINY) GO TO 110
C
C      BEGIN 2 X 2 ROTATIONS
C
            A=EIG(J)
            B=EIG(I)
            C=FMO(J,I)
            D=A-B
C
C   Jeff:  I've modified the following lines so that the round-off
C          error is minimized.
            E = MIN((C/D)**2,0.5D0)
C
C    USE BIGEPS TO DETERMINE WHETHER TO DO A 2 BY 2 ROTATION
C
            IF(E.LT.BIGEPS) GOTO 110
            IF(E.LT.-0.01D0)THEN
C
C    ANGLE IS VERY SMALL, THEREFORE USE APPROXIMATE METHODS TO DETERMINE
C    ALPHA AND BETA.  TRUNCATE SERIES AT E**2
C
               ALPHA=1.D0-E*0.5D0-E*E*0.125D0
               BETA=-SIGN(SQRT(E),C)
            ELSE
C
C    ANGLE IS LARGE, GREATER THAN 0.573 DEGREES, THEREFORE USE EXACT
C    METHOD
C
               E=SIGN(MAX(D,SQRT(4.D0*C*C+D*D)),D)
               ALPHA=SQRT(0.5D0*(1.D0+D/E))
               BETA=-SIGN(SQRT(1.D0-ALPHA*ALPHA),C)
            ENDIF
C
C   End of modification
C
C
C      ROTATION OF PSEUDO-EIGENVECTORS
C
            DO 100 M=1,N
               A=VECTOR(M,J)
               B=VECTOR(M,I)
               VECTOR(M,J)=ALPHA*A +BETA*B
               VECTOR(M,I)=ALPHA*B -BETA*A
  100       continue
  110    CONTINUE
  120 CONTINUE
      RETURN
      END
      SUBROUTINE FLEPO (XPARAM,NVAR,FUNCT1)
***************************************************************
*                                                             *
* THIS SUBROUTINE USES THE BFGS UPDATE TO THE INVERSE HESSIAN *
* THE NAME FLEPO IS KEPT IN ORDER TO ALLOW COMPATABILITY WITH *
* OTHER PROGRAMS.   THE DFP FORMULA IS NOTED IN THE COMMENTS. *
*                                                             *
***************************************************************
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
C
      DIMENSION XPARAM(*)
      COMMON /KEYWRD/ KEYWRD
      COMMON /GRAVEC/ COSINE
      COMMON /LAST  / LAST
C    changed common path for portability  (IR)
      COMMON /PATHI / LATOM,LPARAM
      COMMON /PATHR / REACT(200)
      COMMON /GRADNT/ GRAD(MAXPAR),GNORM
      COMMON /MESAGE/ IFLEPO,ISCF
      COMMON /NUMSCF/ NSCF
      COMMON /TIMER / TIME0
      COMMON /FMATRX/ HESINV(MAXHES)
      COMMON /NUMCAL/ NUMCAL
      CHARACTER*80 KEYWRD
      CHARACTER SPACE*1, CHDOT*1, ZERO*1, NINE*1, CH*1
C
C     *
C     THIS SUBROUTINE ATTEMPTS TO MINIMIZE A REAL-VALUED FUNCTION OF
C     THE N-COMPONENT REAL VECTOR XPARAM ACCORDING TO THE
C     BFGS FORMULA. RELEVANT REFERENCES ARE
C
C     BROYDEN, C.G., JOURNAL OF THE INSTITUTE FOR MATHEMATICS AND
C                     APPLICATIONS, VOL. 6 PP 222-231, 1970.
C     FLETCHER, R., COMPUTER JOURNAL, VOL. 13, PP 317-322, 1970.
C
C     GOLDFARB, D. MATHEMATICS OF COMPUTATION, VOL. 24, PP 23-26, 1970.
C
C     SHANNO, D.F. MATHEMATICS OF COMPUTATION, VOL. 24, PP 647-656
C                    1970.
C
C   SEE ALSO SUMMARY IN
C
C    SHANNO, D.F., J. OF OPTIMIZATION THEORY AND APPLICATIONS
C          VOL.46, NO 1 PP 87-94 1985.
C     THE USER MUST SUPPLY THE SUBROUTINE
C     COMPFG(NVAR,XPARAM,FUNCT,GRAD,1)WHICH
C     COMPUTES FUNCTION VALUES  FUNCT  AND GRADIENTS  GRAD AT GIVEN
C     VALUES FOR THE VARIABLES XPARAM.  THE MINIMIZATION PROCEEDS BY ONE
C     OR MORE BINARY CHOPS WHICH FINDS AN IMPROVED VALUE OF THE
C     FUNCTION IN THE DIRECTION   XPARAM+ALPHA*PVECT,
C     WHERE XPARAM
C     IS THE VECTOR OF CURRENT VARIABLE VALUES,  ALPHA IS A SCALAR
C     VARIABLE, AND  PVECT  IS A SEARCH-DIRECTION VECTOR PROVIDED BY THE
C     BFGS ALGORITHM.  A SEQUENCE OF FUNCT VALUES CONVERGING TO SOME
C     LOCAL MINIMUM VALUE AND A SEQUENCE OF
C     XPARAM VECTORS CONVERGING TO THE CORRESPONDING MINIMUM POINT
C     ARE PRODUCED.
C                          CONVERGENCE TESTS.
C
C     HERBERTS TEST: THE ESTIMATED DISTANCE FROM THE CURRENT POINT
C                    POINT TO THE MINIMUM IS LESS THAN TOLERA.
C
C                    "HERBERTS TEST SATISFIED - GEOMETRY OPTIMIZED"
C
C     GRADIENT TEST: THE GRADIENT NORM HAS BECOME LESS THAN TOLERG
C                    TIMES THE SQUARE ROOT OF THE NUMBER OF VARIABLES.
C
C                    "TEST ON GRADIENT SATISFIED".
C
C     XPARAM TEST:  THE RELATIVE CHANGE IN XPARAM, MEASURED BY ITS NORM,
C                   OVER ANY TWO SUCCESSIVE ITERATION STEPS DROPS BELOW
C                   TOLERX.
C
C                    "TEST ON XPARAM SATISFIED".
C
C     FUNCTION TEST: THE CALCULATED VALUE OF THE HEAT OF FORMATION
C                    BETWEEN ANY TWO CYCLES IS WITHIN TOLERF OF
C                    EACH OTHER.
C
C                    "HEAT OF FORMATION TEST SATISFIED"
C
C     FOR THE GRADIENT, FUNCTION, AND XPARAM TESTS A FURTHER CONDITION,
C     THAT NO INDIVIDUAL COMPONENT OF THE GRADIENT IS GREATER
C     THAN TOLERG, MUST BE SATISFIED, IN WHICH CASE THE
C     CALCULATION EXITS WITH THE MESSAGE
C
C                     "PETERS TEST SATISFIED"
C
C     WILL BE PRINTED, AND FUNCT AND XPARAM WILL CONTAIN THE LAST
C     FUNCTION VALUE CUM VARIABLE VALUES REACHED.
C
C     SIMILAR UNSUCCESSFUL TERMINATIONS WILL TAKE PLACE IF THE COSINE OF
C     THE SEARCH DIRECTION TO GRADIENT VECTOR IS LESS THAN RST ON TWO
C     CONSECUTIVE ITERATIONS.
C
C     THE BROYDEN-FLETCHER-GOLDFARB-SHANNO ALGORITHM CHOOSES SEARCH
C     DIRECTIONS ON THE BASIS OF LOCAL PROPERTIES OF THE FUNCTION.
C     A MATRIX  H, WHICH IN FLEPO IS PRESET WITH THE IDENTITY, IS
C     MAINTAINED AND UPDATED AT EACH ITERATION STEP.
C     THE MATRIX DESCRIBES A LOCAL METRIC ON THE SURFACE OF FUNCTION
C     VALUES ABOVE THE POINT XPARAM.  THE SEARCH-DIRECTION VECTOR
C     PVECT  IS SIMPLY A TRANSFORMATION OF THE GRADIENT  GRAD
C     BY THE MATRIX H.  THE USER THROWS OUT H AND STARTS AGAIN
C     WHENEVER THE COSINE OF THE ANGLE BETWEEN  GRAD  AND PVECT BECOMES
C     LESS THAN RST.
C
      DIMENSION XD(MAXPAR), GD(MAXPAR), GLAST(MAXPAR), MDFP(9),XDFP(9),
     1          XLAST(MAXPAR), GG(MAXPAR), PVECT(MAXPAR)
      LOGICAL OKF, OKC, PRINT,  ISTIME, RESTRT, MINPRT, SADDLE, GEOOK
     1        ,RESET, RESFIL, DFP
      EQUIVALENCE (MDFP(1),JCYC  ),(MDFP(2),JNRST),(MDFP(3),NCOUNT),
     1            (MDFP(4),LNSTOP),(XDFP(1),ALPHA),(XDFP(2),COS   ),
     2            (XDFP(3),PNORM ),(XDFP(4),DROP ),(XDFP(5),DEL   ),
     3            (XDFP(6),FREPF ),(XDFP(7),CYCMX),(XDFP(8),TOTIME)
         SAVE                                                           GL0892
      DATA ICALCN /0/
      DATA SPACE,CHDOT,ZERO,NINE /' ','.','0','9'/
      IF (ICALCN.NE.NUMCAL) THEN
C
C   THE FOLLOWING CONSTANTS SHOULD BE SET BY THE USER.
C
         RST   = 0.05D0
         TDEL  = 6.D0
         SFACT=1.5
         PMSTE = 0.1D0
         DELL  = 0.01D0
         EINC  = 0.3D0
         IGG1  = 3
         DEL=DELL
C
C    THESE CONSTANTS SHOULD BE SET BY THE PROGRAM.
C
         RESTRT = (INDEX(KEYWRD,'RESTART').NE.0)
         GEOOK  = (INDEX(KEYWRD,'GEO-OK').NE.0)
         ISTIME   = (INDEX(KEYWRD,'TIME').NE.0)
C
C   THE DAVIDON-FLETCHER-POWELL METHOD IS NOT RECOMMENDED
C   BUT CAN BE INVOKED BY USING THE KEY-WORD 'DFP'
C
         DFP   = (INDEX(KEYWRD,'DFP').NE.0)
         TLEFT=MAXTIM
         TOLERG=1.0D0
         CONST=1.D0
         MINPRT=(INDEX(KEYWRD,'SADDLE')+INDEX(KEYWRD,'SADDLE') .EQ.0)
         SADDLE=(INDEX(KEYWRD,'SADDLE') .NE.0)
         IF( .NOT. MINPRT) MINPRT=(INDEX(KEYWRD,'DEBUG') .NE. 0)
         I=INDEX(KEYWRD,' T=')
         IF(I.NE.0) THEN
            TIM=READA(KEYWRD,I)
            DO 10 J=I+3,80
            IF( KEYWRD(J+1:J+1).EQ.' ') THEN
               CH=KEYWRD(J:J)
               IF( CH .EQ. 'M') TIM=TIM*60
               IF( CH .EQ. 'H') TIM=TIM*3600
               IF( CH .EQ. 'D') TIM=TIM*86400
               GOTO 20
            ENDIF
   10       CONTINUE
C
C   LIMIT JOB TIME TO MAX. OF ONE YEAR, LARGE JOBTIMES STOP
C   DUMPS WORKING CORRECTLY AS TLEFT-(CYCLE TIME) = TLEFT!
C
            TIM=MIN(31557600.D0,TIM)
   20       TLEFT=TIM
         ENDIF
         TLAST=TLEFT
         TDUMP=MAXDMP
         I=INDEX(KEYWRD,' DUMP=')
         IF(I.NE.0) THEN
            TDUMP=READA(KEYWRD,I)
            DO 30 J=I+6,80
            IF( KEYWRD(J+1:J+1).EQ.' ') THEN
               CH=KEYWRD(J:J)
               IF( CH .EQ. 'M') TDUMP=TDUMP*60
               IF( CH .EQ. 'H') TDUMP=TDUMP*3600
               IF( CH .EQ. 'D') TDUMP=TDUMP*86400
                  GOTO 40
               ENDIF
   30       CONTINUE
   40       CONTINUE
         ENDIF
cmgc         TX2=SECOND()
         TLEFT=TLEFT-TX2+TIME0
         IF(INDEX(KEYWRD,'GNORM=').NE.0) THEN
            ROOTV=1.D0
            CONST=1.D-20
         ELSE
            ROOTV=SQRT(NVAR+1.D-5)
         ENDIF
         PRINT  = (INDEX(KEYWRD,'FLEPO').NE.0)
         TOLERX = 0.0001D0*CONST
         DELHOF  = 0.0010D0*CONST
         TOLERF = 0.002D0*CONST
         TOLRG  = TOLERG
         IF (INDEX(KEYWRD,'FORCE') .NE. 0) THEN
            TOLERX = 0.00001D0
            TOLERF = 0.0002D0
            TOLERG = 0.1D0
            DELHOF  = 0.00010D0
         ENDIF
         IF(INDEX(KEYWRD,'PREC') .NE. 0) THEN
            TOLERX=TOLERX*0.01D0
            DELHOF=DELHOF*0.01D0
            TOLERF=TOLERF*0.01D0
            TOLERG=TOLERG*0.1D0
            EINC=EINC*0.01
         ENDIF
         IF(INDEX(KEYWRD,'GNORM=').NE.0) THEN
            TOLERG=READA(KEYWRD,INDEX(KEYWRD,'GNORM='))
            IF(.NOT.GEOOK.AND.INDEX(KEYWRD,'LET').EQ.0.AND.
     1TOLERG.LT.1.D-4)THEN
               WRITE(6,'(/,A)')'  GNORM HAS BEEN SET TOO LOW, RESET TO 0
     1.0001'
               TOLERG=1.D-4
               TOLRG=TOLERG
            ENDIF
         ELSE
            TOLERG=TOLERG/ROOTV
         ENDIF
      ENDIF
C
C   THE FOLLOWING CONSTANTS SHOULD BE SET TO SOME ARBITARY LARGE VALUE.
C
      DROP  = 1.D15
      FREPF = 1.D15
C
C     AND FINALLY, THE FOLLOWING CONSTANTS ARE CALCULATED.
C
      IHDIM=(NVAR*(NVAR+1))/2
      CNCADD=1.0D00/ROOTV
      IF (CNCADD.GT.0.15D00) CNCADD=0.15D00
C
C     FIRST, WE INITIALIZE THE VARIABLES.
C
      ABSMIN=1.D6
      ITRY1=0
      ITRY2=0
      OKC=.TRUE.
      OKF=.TRUE.
      JCYC=0
      LNSTOP=1
      IREPET=1
      ALPHA = 1.0D00
      PNORM=1.0D00
      JNRST=0
      CYCMX=0.D0
      COS=0.0D00
      TOTIME=0.D0
      NCOUNT=1
      RESFIL=.FALSE.
      IF( SADDLE) THEN
*
*   WE DON'T NEED HIGH PRECISION DURING A SADDLE-POINT CALCULATION.
*
         IF(NVAR.GT.0)GNORM=SQRT(ddot(nvar,grad,1,grad,1))-3.D0
         IF(GNORM.GT.10.D0)GNORM =10.D0
         IF(GNORM.GT.1.D0) TOLERG=TOLRG*GNORM
         WRITE(6,'('' GRADIENT CRITERION IN FLEPO ='',F12.5)')TOLERG
      ENDIF
      IF (RESTRT .AND. ICALCN .NE. NUMCAL) THEN
         MDFP(9)=0
         CALL DFPSAV(TOTIME,XPARAM,GD,XLAST,FUNCT1,MDFP,XDFP)
         I=nint(TOTIME/1000000.0)
         TOTIME=TOTIME-I*1000000
         WRITE(6,'(//10X,''TOTAL TIME USED SO FAR:'',
     1    F13.2,'' SECONDS'')')TOTIME
         NSCF=MDFP(5)
         IF(INDEX(KEYWRD,'1SCF') .NE. 0) THEN
            CALL COMPFG (XPARAM, .TRUE., FUNCT1,.TRUE.,GRAD,.TRUE.)
            ICALCN=NUMCAL
            IFLEPO=1
            TIME0=TIME0-TOTIME
            TOTIME=0.D0
            RETURN
         ENDIF
      ELSE
         TOTIME=0.D0
C
C CALCULATE THE VALUE OF THE FUNCTION -> FUNCT1, AND GRADIENTS -> GRAD.
C NORMAL SET-UP OF FUNCT1 AND GRAD, DONE ONCE ONLY.
C
         CALL COMPFG (XPARAM, .TRUE., FUNCT1,.TRUE.,GRAD,.TRUE.)
         DO 50 I=1,NVAR
   50    GD(I)=GRAD(I)
      ENDIF
      ICALCN=NUMCAL
      IF(NVAR.NE.0)GNORM=SQRT(ddot(nvar,grad,1,grad,1))
      IFLEPO=1
      IF(INDEX(KEYWRD,'1SCF') .NE. 0) THEN
         WRITE(6,'(1X,/,30H   BFGS GEOMETRY OPTIMIZATION,/)')
      END IF
      IF(INDEX(KEYWRD,'1SCF') .NE. 0) RETURN
      IFLEPO=2
      IF(GNORM.LT.TOLERG.OR.NVAR.EQ.0) THEN
         LAST=1
         IF(RESTRT) THEN
            CALL COMPFG (XPARAM, .TRUE., FUNCT1,.TRUE.,GRAD,.TRUE.)
         ELSE
            CALL COMPFG (XPARAM, .TRUE., FUNCT1,.TRUE.,GRAD,.FALSE.)
         ENDIF
         RETURN
      ENDIF
cmgc      TX1 =  SECOND()
      TLEFT=TLEFT-TX1+TX2
C     *
C     START OF EACH ITERATION CYCLE ...
C     *
C
      RESET=.FALSE.
      GOTO 80
   60 CONTINUE
      IF(COS .LT. RST) THEN
         DO 70 I=1,NVAR
   70    GD(I)=0.5D0
      ENDIF
   80 CONTINUE
      JCYC=JCYC+1
      JNRST=JNRST+1
      IF (LNSTOP.NE.1 .AND. COS.GT.RST) GOTO 160
C
C     *
C     RESTART SECTION
C     *
C
   90 CONTINUE
      RESET=.TRUE.
      DO 100 I=1,NVAR
         XD(I)=XPARAM(I)-SIGN(DEL,GRAD(I))
  100 CONTINUE
C
C THIS CALL OF COMPFG IS USED TO CALCULATE THE SECOND-ORDER MATRIX IN H
C IF THE NEW POINT HAPPENS TO IMPROVE THE RESULT, THEN IT IS KEPT.
C OTHERWISE IT IS SCRAPPED, BUT STILL THE SECOND-ORDER MATRIX IS O.K.
C
      CALL COMPFG (XD, .TRUE., FUNCT2,.TRUE.,GD,.TRUE.)
      IF(.NOT. GEOOK .AND. SQRT(ddot(nvar,gd,1,gd,1))/GNORM.GT.10.
     1 AND.GNORM/ROOTV.GT.20.AND.JCYC.GT.2)THEN
C
C  THE GEOMETRY IS BADLY SPECIFIED IN THAT MINOR CHANGES IN INTERNAL
C  COORDINATES LEAD TO LARGE CHANGES IN CARTESIAN COORDINATES, AND THESE
C  LARGE CHANGES ARE BETWEEN PAIRS OF ATOMS THAT ARE CHEMICALLY BONDED
C  TOGETHER.
         WRITE(6,'('' GRADIENTS OF OLD GEOMETRY, GNORM='',F13.6)')GNORM
         WRITE(6,'(6F12.6)')(GRAD(I),I=1,NVAR)
         GDNORM=SQRT(ddot(nvar,gd,1,gd,1))
         WRITE(6,'('' GRADIENTS OF NEW GEOMETRY, GNORM='',F13.6)')GDNORM
         WRITE(6,'(6F12.6)')(GD(I),I=1,NVAR)
         WRITE(6,'(///20X,''CALCULATION ABANDONED AT THIS POINT!'')')
         WRITE(6,'(//10X,'' SMALL CHANGES IN INTERNAL COORDINATES ARE'',
     1/10X,'' CAUSING A LARGE CHANGE IN THE DISTANCE BETWEEN'')')
         WRITE(6,'(10X,'' CHEMICALLY-BOUND ATOMS. THE OPTIMISATION'',/
     110X,'' PROCEDURE WOULD LIKELY PRODUCE INCORRECT RESULTS'')')
         CALL GEOUT
         STOP
      ENDIF
      NCOUNT=NCOUNT+1
      DO 110 I=1,IHDIM
  110 HESINV(I)=0.0D00
      DO 120 I=1,NVAR
         II=(I*(I+1))/2
         DELTAG=GRAD(I)-GD(I)
         IF (ABS(DELTAG).LT.1.D-10) DELTAG = 1.D-10
         GGD=ABS(GRAD(I))
         IF (FUNCT2.LT.FUNCT1) GGD=ABS(GD(I))
         HESINV(II)=SIGN(DEL,GRAD(I))/DELTAG
         IF (HESINV(II).LT.0.0D00.AND.GGD.LT.1.D-12)HESINV(II)=0.01D00
         IF (HESINV(II).LT.0.D0) HESINV(II)=6.D0*DEL/GGD
         HESINV(II)=MIN(HESINV(II),ABS(PMSTE/MAX(1.D-12,GGD)))
  120 CONTINUE
      JNRST=0
      IF(JCYC.LT.2) COSINE=1.D0
      IF(FUNCT2 .GE. FUNCT1) THEN
         IF(PRINT)WRITE (6,130) FUNCT1,FUNCT2
  130    FORMAT (' FUNCTION VALUE=',F13.7,
     1 '  WILL NOT BE REPLACED BY VALUE=',F13.7,/10X,
     2 'CALCULATED BY RESTART PROCEDURE',/)
         CALL COMPFG (XPARAM, .TRUE., FUNCT1,.TRUE.,GD,.FALSE.)
         COSINE=1.D0
      ELSE
         IF( PRINT ) WRITE (6,140) FUNCT1,FUNCT2
  140    FORMAT (' FUNCTION VALUE=',F13.7,
     1' IS BEING REPLACED BY VALUE=',F13.7,/10X,
     2' FOUND IN RESTART PROCEDURE',/,6X,
     3'THE CORRESPONDING X VALUES AND GRADIENTS ARE ALSO BEING REPLACED'
     4,/)
         FUNCT1=FUNCT2
         GNORM=0.0D00
         DO 150 I=1,NVAR
            XPARAM(I)=XD(I)
            GRAD(I)=GD(I)
  150    GNORM=GNORM+GRAD(I)**2
         GNORM=SQRT(GNORM)
      ENDIF
      GO TO 210
C
C     *
C     UPDATE VARIABLE-METRIC MATRIX
C     *
C
  160 PTY=0.0D00
      JNRST=JNRST+1
      YHY=0.0D00
      DO 180 I=1,NVAR
         S=0.0D00
         DO 170 J=1,NVAR
            IF (J.GT.I) THEN
               K=(J*(J-1))/2+I
            ELSE
               K=(I*(I-1))/2+J
            ENDIF
  170    S=S+HESINV(K)*(GRAD(J)-GLAST(J))
         GG(I)=S
         Y=GRAD(I)-GLAST(I)
         YHY=YHY+GG(I)*Y
  180 PTY=PTY+(XPARAM(I)-XLAST(I))*Y
      IF(DFP)THEN
         DO 190 I=1,NVAR
            PT=XPARAM(I)-XLAST(I)
            DO 190 J=I,NVAR
               K=(J*(J-1))/2+I
               P=XPARAM(J)-XLAST(J)
C     START OF DAVIDON FLETCHER POWELL FORMULA
               HESINV(K)=HESINV(K)+PT*P/PTY-GG(I)*GG(J)/YHY
C     END OF DAVIDON FLETCHER POWELL FORMULA
  190    CONTINUE
      ELSE
C    BFGS FORMULA ON NEXT LINE
         YHY=1.D0+YHY/PTY
C    BFGS FORMULA ON LAST LINE
         DO 200 I=1,NVAR
            PT=XPARAM(I)-XLAST(I)
            DO 200 J=I,NVAR
               P=XPARAM(J)-XLAST(J)
               K=(J*(J-1))/2+I
C    START OF BFGS FORMULA ON NEXT LINE
               HESINV(K)=HESINV(K)-(GG(J)*PT+P*GG(I))/PTY+YHY*P*PT/PTY
C    END OF BFGS FORMULA
  200    CONTINUE
      ENDIF
C
C     *
C     ESTABLISH NEW SEARCH DIRECTION
C     *
  210 PNLAST=PNORM
      PNORM=0.0D00
      DOTT=0.0D00
      DO 230 K=1,NVAR
         S=0.0D00
         DO 220 I=1,NVAR
            IJ=MAX(I,K)
            S=S-HESINV((IJ*(IJ-1))/2+I+K-IJ)*GRAD(I)
  220    CONTINUE
         PVECT(K)=S
         PNORM=PNORM+PVECT(K)**2
  230 DOTT=DOTT+PVECT(K)*GRAD(K)
      PNORM=SQRT(PNORM)
      COS=-DOTT/(PNORM*GNORM)
      IF (JNRST.EQ.0) GO TO 260
      IF (COS.LE.CNCADD.AND.DROP.GT.1.0D00) GO TO 240
      IF (COS.LE.RST) GO TO 240
      GO TO 260
  240 PNORM=PNLAST
      IF( PRINT )WRITE (6,250) COS
  250 FORMAT (//,5X, 'SINCE COS=',F9.3,5X,'THE PROGRAM WILL GO TO RE',
     1'START SECTION',/)
      GO TO 90
  260 CONTINUE
      IF( PRINT )THEN
         WRITE (6,270)
  270    FORMAT ('  THE CURRENT POINT IS ...')
         NTO6=(NVAR-1)/6+1
         IINC1=-5
         DO 320 I=1,NTO6
            WRITE (6,'(/)')
            IINC1=IINC1+6
            IINC2=MIN(IINC1+5,NVAR)
            WRITE (6,280) (J,J=IINC1,IINC2)
            WRITE (6,290) (XPARAM(J),J=IINC1,IINC2)
            WRITE (6,300) (GRAD(J),J=IINC1,IINC2)
            WRITE (6,310) (ALPHA*PVECT(J),J=IINC1,IINC2)
  280       FORMAT (1H ,3X,  1HI,9X,I3,9(8X,I3))
  290       FORMAT (1H ,1X, 'XPARAM(I)',1X,F9.4,2X,9(F9.4,2X))
  300       FORMAT (1H ,1X, 'GRAD  (I)',F10.4,1X,9(F10.4,1X))
  310       FORMAT (1H ,1X, 'PVECT (I)',2X,F10.6,1X,9(F10.6,1X))
  320    CONTINUE
      ENDIF
      LNSTOP=0
      ALPHA=ALPHA*PNLAST/PNORM
      DO 330 I=1,NVAR
         GLAST(I)=GRAD(I)
  330 XLAST(I)=XPARAM(I)
      IF (JNRST.EQ.0) ALPHA=1.0D00
      DROP=ABS(ALPHA*DOTT)
      IF (JNRST.NE.0.AND.DROP.LT.DELHOF) THEN
         IF(MINPRT)WRITE (6,340)
  340    FORMAT(//,10X,'HERBERTS TEST SATISFIED - GEOMETRY OPTIMIZED')
C
C   FLEPO IS ENDING PROPERLY. THIS IS IMMEDIATELY BEFORE THE RETURN.
C
         LAST=1
         CALL COMPFG (XPARAM, .TRUE., FUNCT,.TRUE.,GRAD,.FALSE.)
         IFLEPO=3
         TIME0=TIME0-TOTIME
         TOTIME=0.D0
         RETURN
      ENDIF
      SMVAL=FUNCT1
      IF(GNORM.GT.1.D0.AND.PNORM.GT.1.D-3)THEN
         CALL LINMIN(XPARAM,ALPHA,PVECT,NVAR,FUNCT1,OKF,OKC)
      ELSE
C
C   DO A BINARY CHOP TO LOCATE THE MINIMUM
C
         ALPHA=1.D0
C
C   SOMETIMES PNORM IS TOO LARGE,  THEREFORE TRIM ALPHA BACK
C
         IF(PNORM.GT.0.1D0)ALPHA=0.1D0/PNORM
         LOOP=0
  350    CONTINUE
         DO 360 I=1,NVAR
  360    XPARAM(I)=XLAST(I)+PVECT(I)*ALPHA
         CALL COMPFG (XPARAM, .TRUE., FUNCT1,.TRUE.,GRAD,.FALSE.)
C
C   1.D-5 IS TO PREVENT LOOPING
C
         IF(FUNCT1.GT.SMVAL+1.D-5.AND.PNORM*ALPHA.GT.1.D-6.AND.LOOP.LT.1
     10)THEN
            LOOP=LOOP+1
            ALPHA=ALPHA*0.5D0
            GOTO 350
         ENDIF
      ENDIF
      NCOUNT=NCOUNT+1
      IF ( .NOT. OKF) THEN
         LNSTOP = 1
         IF(MINPRT)WRITE (6,370)
  370    FORMAT (1H ,///,20X, 'NO POINT LOWER IN ENERGY ',
     1    'THAN THE STARTING POINT',/,20X,'COULD BE FOUND ',
     2    'IN THE LINE MINIMIZATION')
         FUNCT1=SMVAL
         DO 380 I=1,NVAR
            GRAD(I)=GLAST(I)
            XPARAM(I)=XLAST(I)
  380    CONTINUE
         IF (JNRST.EQ.0)THEN
            WRITE (6,390)
  390       FORMAT (1H ,//,20X, 'SINCE COS WAS JUST RESET,THE SEARCH',
     1        ' IS BEING ENDED')
C
C          FLEPO IS ENDING BADLY. THIS IS IMMEDIATELY BEFORE THE RETURN.
C
            LAST=1
            CALL COMPFG (XPARAM, .TRUE., FUNCT,.TRUE.,GRAD,.TRUE.)
            IFLEPO=4
            TIME0=TIME0-TOTIME
            TOTIME=0.D0
            RETURN
         ENDIF
         IF(PRINT)WRITE (6,400)
  400    FORMAT (1H ,20X, 'COS WILL BE RESET AND ANOTHER '
     1    ,'ATTEMPT MADE')
         COS=0.0D00
         GO TO 560
      ENDIF
C   WE WANT ACCURATE DERIVATIVES AT THIS POINT
C
C   LINMIN DOES NOT GENERATE ANY DERIVATIVES, THEREFORE COMPFG MUST BE
C   CALLED TO END THE SEARCH
C
      IF(RESET) THEN
         DO 410 J=1,NVAR
  410    GRAD(J)=0.D0
         RESET=.FALSE.
      ENDIF
      CALL COMPFG (XPARAM, .TRUE., FUNCT1,.TRUE.,GRAD,.TRUE.)
      GNORM=SQRT(ddot(nvar,grad,1,grad,1))
      IF (.NOT. OKC .AND. MINPRT)WRITE (6,420) JCYC
  420 FORMAT ( 23H0LINMIN FAILED AT CYCLE,I5/,  1H0)
      XN=0.0D00
      DO 430 K=1,NVAR
  430 XN=XN+XPARAM(K)**2
      XN=SQRT(XN)
      TX=ABS(ALPHA*PNORM)
      IF (XN.NE.0.0D00) TX=TX/XN
      TF=SMVAL-FUNCT1
      IF (ALPHA.LT.0.01D0.OR.ABSMIN-SMVAL.LT.1.D-7)THEN
         ITRY2=ITRY2+1
         IF(COS.LT.RST)ITRY2=0
         IF(ITRY2.EQ.5)THEN
C
C   RE-CALCULATE ALL DERIVATIVES IF HALF-ELECTRON USED.
C
            COS=-1.D0
         ENDIF
      ELSE
         IF(ALPHA.GT.0.1D0)ITRY2=0
      ENDIF
      IF(ABSMIN-SMVAL.LT.1.D-7)THEN
         ITRY1=ITRY1+1
         IF(ITRY1.GT.10)THEN
            WRITE(6,'(//,'' HEAT OF FORMATION IS ESSENTIALLY STATIONARY'
     1')')
            GOTO 550
         ENDIF
      ELSE
         ITRY1=0
         ABSMIN=SMVAL
      ENDIF
      IF (PRINT) WRITE (6,440) NCOUNT,COS,TX*XN,ALPHA,-DROP,-TF,GNORM
  440 FORMAT (/,'           NUMBER OF COUNTS =',I6,
     1'         COS    =',F11.4,/,
     2        '  ABSOLUTE  CHANGE IN X     =',F13.6,
     3'  ALPHA  =',F11.4,/,
     4        '  PREDICTED CHANGE IN F     =  ',G11.4,
     5'  ACTUAL =  ',G11.4,/,
     6        '  GRADIENT NORM             =  ',G11.4,//)
  450 IF (TX.LE.TOLERX) THEN
         IF(MINPRT) WRITE (6,460)
  460    FORMAT ( 20H0TEST ON X SATISFIED)
         GO TO 490
      ENDIF
      IF (ABS(TF).LE.TOLERF) THEN
         IF(MINPRT) WRITE (6,470)
  470    FORMAT (' HEAT OF FORMATION TEST SATISFIED')
         GO TO 490
      ENDIF
      IF (GNORM.LE.TOLERG*ROOTV) THEN
         IF(MINPRT) WRITE (6,480)
  480    FORMAT ( 27H0TEST ON GRADIENT SATISFIED)
         GOTO 490
      ENDIF
      GOTO 560
  490 DO 530 I=1,NVAR
         IF (ABS(GRAD(I)).GT.TOLERG)THEN
            IREPET=IREPET+1
            IF (IREPET.GT.1) GO TO 500
            FREPF=FUNCT1
            COS=0.0D00
  500       CONTINUE
            IF(MINPRT) WRITE (6,510)TOLERG
  510       FORMAT (20X,'HOWEVER, A COMPONENT OF GRADIENT IS ',
     1     'LARGER THAN',F6.2 ,/)
            IF (ABS(FUNCT1-FREPF).GT.EINC) IREPET=0
            IF (IREPET.GT.IGG1) THEN
               WRITE (6,520)IGG1,EINC
  520          FORMAT ( 7X,' THERE HAVE BEEN',I2,' ATTEMPTS TO REDUCE TH
     1E ',' GRADIENT.',/7X,' DURING THESE ATTEMPTS THE ENERGY DROPPED',
     2' BY LESS THAN',F7.4,' KCAL/MOLE',/
     310X,' FURTHER CALCULATION IS NOT JUSTIFIED AT THIS POINT.')
               LAST=1
               CALL COMPFG (XPARAM, .TRUE., FUNCT,.TRUE.,GRAD,.FALSE.)
               IFLEPO=8
               TIME0=TIME0-TOTIME
               TOTIME=0.D0
               RETURN
            ELSE
               GOTO 560
            ENDIF
         ENDIF
  530 CONTINUE
      IF(MINPRT) WRITE (6,540)
  540 FORMAT ( 23H PETERS TEST SATISFIED )
  550 LAST=1
      CALL COMPFG (XPARAM, .TRUE., FUNCT,.TRUE.,GRAD,.FALSE.)
      IFLEPO=6
      TIME0=TIME0-TOTIME
      TOTIME=0.D0
      RETURN
C
C   ALL TESTS HAVE FAILED, WE NEED TO DO ANOTHER CYCLE.
C
  560 CONTINUE
      BSMVF=ABS(SMVAL-FUNCT1)
      IF (BSMVF.GT.10.D00) COS = 0.0D00
      DEL=0.002D00
      IF (BSMVF.GT.1.0D00) DEL=DELL/2.0D00
      IF (BSMVF.GT.5.0D00) DEL=DELL
cmgc      TX2 = SECOND()
      TCYCLE=TX2-TX1
      TX1=TX2
C
C END OF ITERATION LOOP, EVERYTHING IS STILL O.K. SO GO TO
C NEXT ITERATION, IF THERE IS ENOUGH TIME LEFT.
C
      IF(TCYCLE.LT.100000.D0)CYCMX=MAX(CYCMX*0.8D0,TCYCLE)
      TLEFT=TLEFT-TCYCLE
      IF(TLEFT.LT.0)TLEFT=-0.1D0
      IF(TCYCLE.GT.1.D5)TCYCLE=0.D0
      IF(TLAST-TLEFT.GT.TDUMP)THEN
cmgc         TOTIM=TOTIME   +   SECOND()-TIME0
         TLAST=TLEFT
         MDFP(9)=2
         RESFIL=.TRUE.
         MDFP(5)=NSCF
         CALL DFPSAV(TOTIM,XPARAM,GD,XLAST,FUNCT1,MDFP,XDFP)
      ENDIF
      IF(RESFIL)THEN
         IF(MINPRT) WRITE(6,570)MIN(TLEFT,9999999.9D0),
     1MIN(GNORM,999999.999D0),FUNCT1
  570    FORMAT(' RESTART FILE WRITTEN,   TIME LEFT:',F9.1,
     1' GRAD.:',F10.3,' HEAT:',G13.7)
         RESFIL=.FALSE.
      ELSE
         IF(MINPRT) WRITE(6,580)JCYC,MIN(TCYCLE,9999.99D0),
     1MIN(TLEFT,9999999.9D0),MIN(GNORM,999999.999D0),FUNCT1
  580     FORMAT('CYCLE:',I4,'  TIME:',F7.1,'  TIME LEFT:',F8.1,
     1'  GRAD.:',F7.3,'  HEAT:',G13.7)
      ENDIF
      IF (TLEFT.GT.SFACT*CYCMX) GO TO 60
      WRITE(6,590)
  590 FORMAT (20X, 42HTHERE IS NOT ENOUGH TIME FOR ANOTHER CYCLE,/,30X,
     118HNOW GOING TO FINAL)
cmgc      TOTIME=TOTIME   +   SECOND()-TIME0
      MDFP(9)=1
      MDFP(5)=NSCF
      CALL DFPSAV(TOTIME,XPARAM,GD,XLAST,FUNCT1,MDFP,XDFP)
      STOP
C
C
      END
      SUBROUTINE FMAT(FMATRX, NREAL, TSCF, TDER, DELDIP, HEAT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
C
      DIMENSION FMATRX(*), DELDIP(3,*),a(30,30)
***********************************************************************
*
*  VALUE CALCULATES THE SECOND-ORDER OF THE ENERGY WITH
*        RESPECT TO THE CARTESIAN COORDINATES I AND J AND PLACES IT
*        IN FMATRX
*
*  ON INPUT NATOMS  = NUMBER OF ATOMS IN THE SYSTEM.
*           XPARAM  = INTERNAL COORDINATES OF MOLECULE STORED LINEARLY
*
*  VARIABLES USED
*           COORDL  = ARRAY OF CARTESIAN COORDINATES, STORED LINEARLY.
*           I       = INDEX OF CARTESIAN COORDINATE.
*           J       = INDEX OF CARTESIAN COORDINATE.
*
*  ON OUTPUT FMATRX = SECOND DERIVATIVE OF THE ENERGY WITH RESPECT TO
*                    CARTESIAN COORDINATES I AND J.
***********************************************************************
      COMMON /KEYWRD/ KEYWRD
      COMMON /GEOKST/ NATOMS,LABELS(NUMATM),
     1                NA(NUMATM),NB(NUMATM),NC(NUMATM)
      COMMON /GEOVAR/ XDUMMY(MAXPAR),NVAR,LOC(2,MAXPAR)                 IR0394
      COMMON /DENSTY/ P(MPACK),PDUMY(2,MPACK)
      COMMON /ATMASS/ ATMASS(NUMATM)
      COMMON /TIMER / TIME0
      COMMON /CORE  / CORE(107)
C Common MOLKST splitted in MOLKSI and MOLKSR    Ivan Rossi 0394   &8)
      COMMON /MOLKSI/ NUMAT,NAT(NUMATM),NFIRST(NUMATM),
     1                NMIDLE(NUMATM),NLAST(NUMATM), NORBS,
     2                NELECS,NALPHA,NBETA,NCLOSE,NOPEN
     3       /MOLKSR/ FRACT
      COMMON /COORD / COORD(3,NUMATM)
      COMMON /SCRACH/ EVECS(MAXPAR*MAXPAR)
      DIMENSION COLD(MAXPAR), GRAD(MAXPAR),
     1GROLD(MAXPAR), COORDL(MAXPAR), Q(NUMATM), DEL2(3), G2OLD(MAXPAR)
     2, EIGS(MAXPAR), G2RAD(MAXPAR),
     3 FCONST(MAXPAR)
      CHARACTER*80 KEYWRD
      LOGICAL DEBUG, DERIV, RESTRT, PRNT, RESFIL, ANALYT, PRECIS
      CHARACTER SPACE*1, DOTT*1, ZERO*1, NINE*1, CH*1
      EQUIVALENCE (COORD(1,1),COORDL(1))
         SAVE                                                           GL0892
      DATA SPACE,DOTT,ZERO,NINE /' ','.','0','9'/
      DATA FACT/6.95125D-3/
      data angs/0.529177D0/
C
C    FACT IS THE CONVERSION FACTOR FROM KCAL/MOLE TO ERGS
C
C SET UP CONSTANTS AND FLAGS
      NA(1)=99
      KOUNTF=0
C
C  SET UP THE VARIABLES IN XPARAM ANDLOC,THESE ARE IN CARTESIAN COORDINA
C
      NUMAT=0
      DO 10 I=1,NATOMS
         IF(LABELS(I).NE.99.AND.LABELS(I).NE.107) THEN
            NUMAT=NUMAT+1
            LABELS(NUMAT)=LABELS(I)
         ENDIF
   10 CONTINUE
      NATOMS=NUMAT
C
C   THIS IS A QUICK, IF CLUMSY, WAY TO CALCULATE NUMAT, AND TO REMOVE TH
C   DUMMY ATOMS FROM THE ARRAY LABELS.
C
      NVAR=0
      DO 20 I=1,NUMAT
         DO 20 J=1,3
            NVAR=NVAR+1
            LOC(1,NVAR)=I
            LOC(2,NVAR)=J
   20 CONTINUE
      LIN=(NVAR*(NVAR+1))/2
      DO 30 I=1,LIN
   30 FMATRX(I)=0.D0
      PRNT   =(INDEX(KEYWRD,'IRC=') .EQ. 0)
      PRECIS =(INDEX(KEYWRD,'PRECIS') .NE. 0)
      ANALYT =(INDEX(KEYWRD,'ANALYT') .NE. 0)
      RESTRT =(INDEX(KEYWRD,'RESTART') .NE. 0)
      IF(INDEX(KEYWRD,'NLLSQ') .NE. 0) RESTRT=.FALSE.
      DEBUG =(INDEX(KEYWRD,'FMAT') .NE. 0)
      DERIV=(NCLOSE .EQ. NOPEN .AND. INDEX(KEYWRD,'C.I.') .EQ. 0)
      IF(PRNT)WRITE(6,'(//4X,''FIRST DERIVATIVES WILL BE USED IN THE''
     1,'' CALCULATION OF SECOND DERIVATIVES'')')
      TIME=MAXTIM
      I=INDEX(KEYWRD,' T=')
      IF(I.NE.0) THEN
         TIM=READA(KEYWRD,I)
         DO 40 J=I+3,80
            IF( KEYWRD(J+1:J+1).EQ.' ') THEN
               CH=KEYWRD(J:J)
               IF( CH .EQ. 'M') TIM=TIM*60
               IF( CH .EQ. 'H') TIM=TIM*3600
               IF( CH .EQ. 'D') TIM=TIM*86400
               GOTO 50
            ENDIF
   40    CONTINUE
   50    TIME=TIM
         IF(PRNT)WRITE(6,'(/10X,''TIME DEFINED FOR THIS STEP ='',F19.2,
     1    '' SECONDS'')')TIME
      ELSE
         IF(PRNT)WRITE(6,'(/10X,''DEFAULT TIME OF'',F8.2,
     1    '' SECONDS ALLOCATED FOR THIS STEP'')')TIME
      ENDIF
      TLEFT=TIME
      TLAST=TIME
      TDUMP=MAXDMP
      I=INDEX(KEYWRD,' DUMP')
      IF(I.NE.0) THEN
         TDUMP=READA(KEYWRD,I)
         DO 60 J=I+6,80
            IF( KEYWRD(J+1:J+1).EQ.' ') THEN
               CH=KEYWRD(J:J)
               IF( CH .EQ. 'M') TDUMP=TDUMP*60
               IF( CH .EQ. 'H') TDUMP=TDUMP*3600
               IF( CH .EQ. 'D') TDUMP=TDUMP*86400
               GOTO 70
            ENDIF
   60    CONTINUE
   70    CONTINUE
      ENDIF
      RESFIL=.FALSE.
      IF(RESTRT) THEN
         DO 80 I=1,NVAR
   80    COLD(I)=COORDL(I)
         ISTART = 0
         I=0
         CALL FORSAV(TOTIME,DELDIP,ISTART,I,FMATRX, COORD, NVAR,HEAT,
     1                EVECS,JSTART,FCONST)
         KOUNTF=(ISTART*(ISTART+1))/2
         ISTART=ISTART+1
         JSTART=JSTART+1
cmgc         TIME2 = SECOND()
         IF(ISTART.GT.NVAR) GOTO 200
      ELSE
         TOTIME=0.D0
         IF (TSCF.GT.0.D0)TLEFT=TLEFT-TSCF-TDER
         ISTART=1
      ENDIF
C CALCULATE FMATRX
      IF(ISTART.GT.1) THEN
         ESTIME=(NVAR-ISTART+1)*TOTIME/(ISTART-1.D0)
      ELSE
         ESTIME=NVAR*(TSCF+TDER)*2.D0
         IF (PRECIS) ESTIME=ESTIME*2.D0
      ENDIF
      IF(TSCF.GT.0)
     1WRITE(6,'(/10X,''ESTIMATED TIME TO COMPLETE CALCULATION =''
     2,F9.2,'' SECONDS'')')ESTIME
      IF(RESTRT) THEN
         IF(ISTART.LE.NVAR)
     1    WRITE(6,'(/10X,''STARTING AGAIN AT LINE'',18X,I4)')ISTART
         WRITE(6,'(/10X,''TIME USED UP TO RESTART ='',F22.2)')TOTIME
      ENDIF
      LU=KOUNTF
cmgc      TIME1 = SECOND()
      NUMAT=NVAR/3
      DO 160 I=ISTART,NVAR
cmgc         TIME2 = SECOND()
         DELTA = 1.D0/60.D0
         IF(PRECIS)THEN
C
C   DETERMINE A GOOD STEP SIZE
C
            G2OLD(1)=100.D0
            COORDL(I)=COORDL(I)+DELTA
            CALL COMPFG(COORDL, .TRUE., ESCF, .TRUE., G2OLD, .TRUE.)
            COORDL(I)=COORDL(I)-DELTA
            DELTA=DELTA*10.D0/SQRT(ddot(nvar,g2old,1,g2old,1))
C#         WRITE(6,'(A,F12.5)')' DELTA :',DELTA
            G2OLD(1)=100.D0
            COORDL(I)=COORDL(I)+DELTA
            CALL COMPFG(COORDL, .TRUE., ESCF, .TRUE., G2OLD, .TRUE.)
C#         WRITE(6,*)' GNORM:',SQRT(ddot(nvar,g2old,1,g2old,1))
            COORDL(I)=COORDL(I)-DELTA*2.D0
            G2RAD(1)=100.D0
            CALL COMPFG(COORDL, .TRUE., HEATAA, .TRUE., G2RAD, .TRUE.)
            COORDL(I)=COORDL(I)+DELTA
         ENDIF
         COORDL(I)=COORDL(I)+0.5D0*DELTA
         GROLD(1)=100.D0
         CALL COMPFG(COORDL, .TRUE., ESCF, .TRUE., GROLD, .TRUE.)
C#         WRITE(6,*)' GNORM:',SQRT(ddot(nvar,GROLD,1,GROLD,1))
         CALL CHRGE(P,Q)
         DO 90 II=1,NUMAT
   90    Q(II)=CORE(LABELS(II))-Q(II)
         SUM = DIPOLE(P,Q,COORDL,DELDIP(1,I))
         COORDL(I)=COORDL(I)-DELTA
         GRAD(1)=100.D0
         CALL COMPFG(COORDL, .TRUE., HEATAA, .TRUE., GRAD, .TRUE.)
         COORDL(I)=COORDL(I)+DELTA*0.5D0
         CALL CHRGE(P,Q)
         DO 100 II=1,NUMAT
  100    Q(II)=CORE(LABELS(II))-Q(II)
         SUM = DIPOLE(P,Q,COORDL,DEL2)
         DO 110 II=1,3
  110    DELDIP(II,I)=(DELDIP(II,I)-DEL2(II))*0.5D0/DELTA
         LL=LU+1
         LU=LL+I-1
         L=0
c*AG     write(6,*) kountf,i,istart
         IF(PRECIS)THEN
            DO 120 KOUNTF=LL,LU
               L=L+1
               FMATRX(KOUNTF)=FMATRX(KOUNTF)+
     1         (8.D0*(GROLD(L)-GRAD(L))-(G2OLD(L)-G2RAD(L)))
     2          *0.25D0/DELTA*FACT/6.D0
c*AG        if (kountf .eq. 42 .or. kountf .eq. 45) then
c*AG        write(6,*)i,kountf,fmatrx(kountf)*2/fact
c*AG        write(6,*)l,grold(l),grad(l)
c*AG        write(6,*)l,g2old(l),g2rad(l)
c*AG        write (6,*) delta
c*AG        end if
  120       CONTINUE
            L=L-1
            DO 130 K=I,NVAR
               L=L+1
               KK=(K*(K-1))/2+I
               FMATRX(KK)=FMATRX(KK)+
     1         (8.D0*(GROLD(L)-GRAD(L))-(G2OLD(L)-G2RAD(L)))
     2          *0.25D0/DELTA*FACT/6.D0
c*AG        if (kk .eq. 42 .or. kk .eq. 45) then
c*AG        write(6,*) i,kk,fmatrx(kk)*2/fact
c*AG        write(6,*)l,grold(l),grad(l)
c*AG        write(6,*)l,g2old(l),g2rad(l)
c*AG        write (6,*) delta
c*AG        end if
  130       CONTINUE
         ELSE
            DO 140 KOUNTF=LL,LU
               L=L+1
               FMATRX(KOUNTF)=FMATRX(KOUNTF)+
     1         ((GROLD(L)-GRAD(L)))
     2          *0.25D0/DELTA*FACT
  140       CONTINUE
            L=L-1
            DO 150 K=I,NVAR
               L=L+1
               KK=(K*(K-1))/2+I
               FMATRX(KK)=FMATRX(KK)+
     1         ((GROLD(L)-GRAD(L)))
     2          *0.25D0/DELTA*FACT
  150       CONTINUE
         ENDIF
cmgc         TIME3 = SECOND()
         TSTEP=TIME3-TIME2
         TOTIME= TOTIME+TSTEP
         TLEFT= TLEFT-TSTEP
         IF(RESFIL)THEN
            WRITE(6,'('' STEP:'',I4,'' RESTART FILE WRITTEN, INTEGRAL ='
     1',F10.2,'' TIME LEFT:'',F10.2)')I,TOTIME,TLEFT
            RESFIL=.FALSE.
         ELSE
            WRITE(6,'('' STEP:'',I4,'' TIME ='',F9.2,'' SECS, INTEGRAL =
     1'',F10.2,'' TIME LEFT:'',F10.2)')I,TSTEP,TOTIME,TLEFT
         ENDIF
         IF(DERIV) THEN
            ESTIM = TOTIME/I
         ELSE
            ESTIM = TOTIME*2.D0/I
         ENDIF
         IF(TLAST-TLEFT.GT.TDUMP)THEN
            TLAST=TLEFT
            RESFIL=.TRUE.
            JSTART=1
            II=I
            CALL FORSAV(TOTIME,DELDIP,II,NVAR,FMATRX, COORD,NVAR,HEAT,
     1                EVECS,JSTART,FCONST)
         ENDIF
         IF(I.NE.NVAR.AND.TLEFT-10.D0 .LT. ESTIM) THEN
            WRITE(6,'(//10X,''- - - - - - - TIME UP - - - - - - -'',//)'
     1)
            WRITE(6,'(/10X,'' POINT REACHED ='',I4)')I
            WRITE(6,'(/10X,'' RESTART USING KEY-WORD "RESTART"'')')
            WRITE(6,'(10X,''ESTIMATED TIME FOR THE NEXT STEP ='',F8.2,
     1'' SECONDS'')')ESTIM
            JSTART=1
            II=I
            CALL FORSAV(TOTIME,DELDIP,II,NVAR,FMATRX, COORD,NVAR,HEAT,
     1                EVECS,JSTART,FCONST)
            WRITE(6,'(//10X,''FORCE MATRIX WRITTEN TO DISK'')')
            STOP
         ENDIF
  160 CONTINUE
c*AG     l = 1
c*AG     do 111 i=1,nvar
c*AG      do 112 k=1,i
c*AG       a(i,k) = fmatrx(l)
c*AG       l = l + 1
c*AG112   continue
c*AG     write(6,113) (a(i,k)*2/fact,k=1,i)
c*AG111 continue
c*AG113  format(/,15F8.3)
C#      CALL FORSAV(TOTIME,DELDIP,NVAR,NVAR,FMATRX, COORD,NVAR,HEAT,
C#     +                EVECS,JSTART,FCONST)
      IF(DERIV) GOTO 290
      WRITE(6,'(//10X,'' STARTING TO CALCULATE FORCE CONSTANTS'',/)')
      CALL FRAME(FMATRX,NUMAT,0,EIGS)
      CALL RSP(FMATRX,NVAR,NVAR,EIGS,EVECS)
      IF(DEBUG) THEN
         WRITE(6,'(''   EIGENVECTORS FROM FIRST CALCULATION'')')
         CALL MATOUT(EVECS,EIGS,NVAR,NVAR,NVAR)
      ENDIF
      L=0
      DO 180 I=1,NVAR
         DO 180 J=1,I
            L=L+1
            SUM=0.D0
            DO 170 K=1,NREAL
               K1=(K-1)*NVAR+I
               K2=(K-1)*NVAR+J
  170       SUM=SUM+EVECS(K1)*EIGS(K)*EVECS(K2)
  180 FMATRX(L)=SUM
      CALL FRAME(FMATRX,NUMAT,0,EIGS)
      CALL RSP(FMATRX,NVAR,NVAR,EIGS,EVECS)
C     CALL MATOUT(EVECS,EIGS,NVAR,NVAR,NVAR)
      JSTART=1
      DO 190 I=1,NVAR
  190 COLD(I)=COORDL(I)
  200 IF(DERIV) GOTO 290
      L=(JSTART-1)*NVAR
      DO 250 ILOOP=JSTART,NVAR
C
C   MAKE THE STEP-SIZE ROUGHLY INVERSELY PROPORTIONAL TO THE EIGENVALUE
C
         IF(ILOOP.LE.NREAL)THEN
            DELTA=MAX(0.02D0,MIN(0.2D0,0.25D0/ABS(EIGS(ILOOP))))
         ELSEIF(ILOOP.LE.NREAL+3)THEN
            DELTA=0.2D0
         ELSE
            DELTA=0.1D0
         ENDIF
C#      WRITE(6,*)'DELTA:',DELTA
         J=L
         CALL COMPFG(COLD, .TRUE., HEAT, .TRUE., GRAD, .FALSE.)
         DO 210 I=1,NVAR
            J=J+1
  210    COORDL(I)=COLD(I)+EVECS(J)*DELTA
         CALL COMPFG(COORDL, .TRUE., HEATA, .TRUE., GRAD, .FALSE.)
         HEATA=HEATA-HEAT
         J=L
         DO 220 I=1,NVAR
            J=J+1
  220    COORDL(I)=COLD(I)-EVECS(J)*DELTA
         CALL COMPFG(COORDL, .TRUE., HEATB, .TRUE., GRAD, .FALSE.)
         HEATB=HEATB-HEAT
         J=L
         DO 230 I=1,NVAR
            J=J+1
  230    COORDL(I)=COLD(I)+EVECS(J)*DELTA*2
         CALL COMPFG(COORDL, .TRUE., HEATAA, .TRUE., GRAD, .FALSE.)
         HEATAA=HEATAA-HEAT
         J=L
         DO 240 I=1,NVAR
            J=J+1
  240    COORDL(I)=COLD(I)-EVECS(J)*DELTA*2
         CALL COMPFG(COORDL, .TRUE., HEATBB, .TRUE., GRAD, .FALSE.)
         HEATBB=HEATBB-HEAT
         SUM=( (HEATA+HEATB)*16 - (HEATAA+HEATBB) )/12.D0
     1/DELTA*FACT/DELTA*0.5D0
C#      WRITE(6,'(5F12.6)')HEATAA+HEAT,HEATA+HEAT,HEAT,HEATB+HEAT,
C#     +HEATBB+HEAT
C#      WRITE(6,'(5F12.6)')HEATAA,HEATA,0.D0,HEATB,HEATBB
         FCONST(ILOOP)=SUM*0.5D0
         L=L+NVAR
cmgc         TIME3 = SECOND()
         TSTEP=TIME3-TIME2
         IF(TSTEP.GT.1.D5)THEN
            TSTEP=TSTEP-1000000.D0
            TIME3=TIME3-1000000.D0
            TLEFT=-1.D0
         ENDIF
         TIME2=TIME3
         TOTIME= TOTIME+TSTEP
         TLEFT= MAX(-1.D0,TLEFT-TSTEP)
         WRITE(6,'('' STEP:'',I4,'' TIME ='',F9.2,'' SECS, INTEGRAL ='',
     1F10.2,'' TIME LEFT:'',F10.2)')ILOOP,TSTEP,TOTIME,TLEFT
         ESTIM = TSTEP*5.D0
C
C    5.0 IS A SAFETY FACTOR
C
         IF(TLAST-TLEFT.GT.TDUMP)THEN
            TLAST=TLEFT
            RESFIL=.TRUE.
            IFOR=ILOOP
            IX=NVAR+2
*
* VALUE OF IX IS NOT IMPORTANT. SHOULD NOT BE 0 OR NVAR
*
            CALL FORSAV(TOTIME,DELDIP,IX,NVAR,FMATRX, COORD,NVAR,HEAT,
     1                EVECS,IFOR,FCONST)
         ENDIF
         IF(ILOOP.NE.NVAR.AND.TLEFT-10.D0 .LT. ESTIM) THEN
            WRITE(6,'(//10X,''- - - - -  TIME  LIMIT - - - - -'')')
            WRITE(6,'(/10X,'' POINT REACHED ='',I4)')ILOOP
            WRITE(6,'(/10X,'' RESTART USING KEY-WORD "RESTART"'')')
            WRITE(6,'(10X,''ESTIMATED TIME FOR THE NEXT STEP ='',F8.2,
     1'' SECONDS'')')ESTIM
            IFOR=ILOOP
            IX=NVAR+2
*
* VALUE OF IX IS NOT IMPORTANT. SHOULD NOT BE 0 OR NVAR
*
            CALL FORSAV(TOTIME,DELDIP,IX,NVAR,FMATRX, COORD,NVAR,HEAT,
     1                EVECS,IFOR,FCONST)
         ENDIF
  250 CONTINUE
      L=0
      DO 270 I=1,NVAR
         DO 270 J=1,I
            L=L+1
            SUM=0.D0
            DO 260 K=1,NVAR
               K1=(K-1)*NVAR+I
               K2=(K-1)*NVAR+J
  260       SUM=SUM+EVECS(K1)*FCONST(K)*EVECS(K2)
  270 FMATRX(L)=SUM*2.D0
      DO 280 I=1,NVAR
  280 COORDL(I)=COLD(I)
  290 CONTINUE
      DO 300 I=1,NUMAT
         IF(ATMASS(I).LT.1.D-20)THEN
            CALL FORSAV(TOTIME,DELDIP,NVAR,NVAR,FMATRX, COORD,NVAR,HEAT,
     1                EVECS,ILOOP,FCONST)
            WRITE(6,'(A)')' AT LEAST ONE ATOM HAS A ZERO MASS. A RESTART
     1'
            WRITE(6,'(A)')' FILE HAS BEEN WRITTEN AND THE JOB STOPPED'
            STOP
         ENDIF
  300 CONTINUE
      IF(ISTART.LE.NVAR .AND. INDEX(KEYWRD,'ISOTOPE') .NE. 0)
     1CALL FORSAV(TOTIME,DELDIP,NVAR,NVAR,FMATRX, COORD,NVAR,HEAT,
     2                EVECS,ILOOP,FCONST)
      RETURN
      END
      SUBROUTINE FORCE
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
C
      PARAMETER (MAXPA2=MAXPAR**2)
      COMMON /GEOVAR/ XDUMMY(MAXPAR),NVAR,LOC(2,MAXPAR)                 IR0394
      COMMON /GEOSYM/ NDEP,LOCPAR(MAXPAR),IDEPFN(MAXPAR),LOCDEP(MAXPAR)
      COMMON /GEOKST/ NATOMS,LABELS(NUMATM),
     1NA(NUMATM),NB(NUMATM),NC(NUMATM)
      COMMON /FMATRX/ FMATRX(MAXHES)
      COMMON /KEYWRD/ KEYWRD
      COMMON /GRADNT/ GRAD(MAXPAR),GNORM
      PARAMETER (IPADD=2*MORB2+2*MAXORB-MAXPAR-MAXPA2)
      COMMON /VECTOR/ CNORML(MAXPA2),FREQ(MAXPAR),DUMMY(IPADD)
      COMMON /ELEMTS/ ELEMNT(107)
      COMMON /LAST  / LAST
      COMMON /GEOM  / GEO(3,NUMATM)
      COMMON /COORD / COORD(3,NUMATM)
***********************************************************************
*
*   FORCE CALCULATES THE FORCE CONSTANTS FOR THE MOLECULE, AND THE
*         VIBRATIONAL FREQUENCIES.  ISOTOPIC SUBSTITUTION IS ALLOWED.
*
***********************************************************************
      COMMON /EULER / TVEC(3,3), ID
      COMMON /SCRACH/ STORE(MAXPAR**2)
      DIMENSION XPARAM(MAXPAR), GR(3,NUMATM),
     1DELDIP(3,MAXPAR), TRDIP(3,MAXPAR),LOCOLD(2,MAXPAR)
     2,REDMAS(MAXPAR), SHIFT(6), DIPT(MAXPAR), TRAVEL(MAXPAR)
     3, ROT(3,3)
      CHARACTER KEYWRD*80, KEYS(80)*1, ELEMNT*2
cmgc
      character*5 FILENM
cmgc
      LOGICAL RESTRT, LINEAR, DEBUG, BARTEL, PRNT, LARGE
      EQUIVALENCE (GRAD(1), GR(1,1)), (KEYWRD,KEYS(1))
         SAVE                                                           GL0892
C
C TEST GEOMETRY TO SEE IF IT IS OPTIMIZED
      TIME2=-1.D9
      CALL GMETRY(GEO,COORD)
      NVAOLD=NVAR
      DO 10 I=1,NVAR
         LOCOLD(1,I)=LOC(1,I)
   10 LOCOLD(2,I)=LOC(2,I)
      NVAR=0
      NUMAT=0
      IF(LABELS(1) .NE. 99) NUMAT=1
      DO 30 I=2,NATOMS
         IF(LABELS(I).EQ.99.OR.LABELS(I).EQ.107) GOTO 30
         NUMAT=NUMAT+1
         IF(I.EQ.2)ILIM=1
         IF(I.EQ.3)ILIM=2
         IF(I.GT.3)ILIM=3
         DO 20 J=1,ILIM
            NVAR=NVAR+1
            LOC(1,NVAR)=I
            LOC(2,NVAR)=J
   20    XPARAM(NVAR)=GEO(J,I)
   30 CONTINUE
C
C   IF A RESTART, THEN TSCF AND TDER WILL BE FAULTY, THEREFORE SET TO -1
C
      TSCF=-1.D0
      TDER=-1.D0
      PRNT=(INDEX(KEYWRD,'RC=') .EQ. 0)
      DEBUG=(INDEX(KEYWRD,'DFORCE') .NE. 0)
      LARGE=(INDEX(KEYWRD,'LARGE') .NE. 0)
      BARTEL=((INDEX(KEYWRD,'NLLSQ') .NE. 0)                             IR1094
     1         .OR. (INDEX(KEYWRD,' EF') .NE. 0)
     2         .OR. (INDEX(KEYWRD,' TS') .NE. 0))
      RESTRT=(INDEX(KEYWRD,'RESTART') .NE. 0)
cmgc      TIME1=SECOND()
      IF (RESTRT) THEN
C
C   CHECK TO SEE IF CALCULATION IS IN NLLSQ OR FORCE.
C
         IF(BARTEL)GOTO 50
C
C   CALCULATION IS IN FORCE
C
         GOTO 70
      ENDIF
      CALL COMPFG( XPARAM, .TRUE., ESCF, .TRUE., GRAD, .FALSE.)
      IF(PRNT)WRITE(6,'(//10X,''HEAT OF FORMATION ='',F12.6,
     1'' KCALS/MOLE'')')ESCF
cmgc      TIME2=SECOND()
      TSCF=TIME2-TIME1
      CALL COMPFG( XPARAM, .TRUE., ESCF1, .FALSE., GRAD, .TRUE.)
cmgc      TIME3=SECOND()
      TDER=TIME3-TIME2
      IF(PRNT)WRITE(6,'(//10X,''INTERNAL COORDINATE DERIVATIVES'',//3X,
     1''ATOM  AT. NO.'',2X,''BOND'',9X,''ANGLE'',8X,''DIHEDRAL'',/)')
      L=0
      IU=0
      DO 40 I=1,NATOMS
         IF(LABELS(I).EQ.99) GOTO 40
         L=L+1
         IL=IU+1
         IF(I .EQ. 1) IU=IL-1
         IF(I .EQ. 2) IU=IL
         IF(I .EQ. 3) IU=IL+1
         IF(I .GT. 3) IU=IL+2
         IF(PRNT)WRITE(6,'(I6,4X,A2,F13.6,2F10.6)')
     1L,ELEMNT(LABELS(I)),(GRAD(J),J=IL,IU)
   40 CONTINUE
C   TEST SUM OF GRADIENTS
      I=INDEX(KEYWRD,' GNORM=')                                          IR1094
      IF (I .ne. 0) THEN                                                 IR1094
         GNTOL=READA(KEYWRD, I)                                          IR1094
      ELSE                                                               IR1094
         GNTOL=10.0D0                                                    IR1094
      ENDIF                                                              IR1094
      GNORM=SQRT(ddot(nvar,grad,1,grad,1))
      IF(PRNT)WRITE(6,'(//10X,''GRADIENT NORM ='',F10.5)') GNORM
      IF(GNORM .LT. GNTOL) GOTO 60                                       IR1094
      IF(INDEX(KEYWRD,' LET ') .NE. 0) THEN
         WRITE(6,'(///1X,''** GRADIENT IS VERY LARGE, BUT SINCE "LET"'',
     1'' IS USED, CALCULATION WILL CONTINUE'')')
         GOTO 70
      ENDIF
      WRITE(6,'(///1X,''** GRADIENT IS TOO LARGE TO ALLOW '',
     1    ''FORCE MATRIX TO BE CALCULATED, (LIMIT=10) **'',//)')
   50 CONTINUE
      WRITE(6,'(//10X,'' GEOMETRY WILL BE OPTIMIZED FIRST'')')
      IF(BARTEL) THEN
         IF( (INDEX(KEYWRD,' EF') + INDEX(KEYWRD,' TS')) .NE. 0) THEN    IR1094
             WRITE(6,'(15X,''USING EIGENVECTOR FOLLOWING'')')            IR1094
             CALL EF (XPARAM,NVAR,ESCF)                                  IR1094
         ELSE                                                            IR1094
             WRITE(6,'(15X,''USING NLLSQ'')')
             CALL NLLSQ(XPARAM,NVAR)
         ENDIF
      ELSE
         WRITE(6,'(15X,''USING FLEPO'')')
         CALL FLEPO(XPARAM,NVAR,ESCF)
      ENDIF
      CALL COMPFG( XPARAM, .TRUE., ESCF, .TRUE., GRAD, .TRUE.)
      CALL WRITMO(TIME1,ESCF)
      WRITE(6,'(//10X,''GRADIENT NORM ='',F10.7)') GNORM
      CALL GMETRY(GEO,COORD)
   60 CONTINUE
C
C NOW TO CALCULATE THE FORCE MATRIX
C
C CHECK OUT SYMMETRY
   70 CONTINUE
C
C   NEED TO ENSURE THAT XYZINT WILL WORK CORRECTLY BEFORE CALL
C   TO DRC.
C
      L=0
      DO 80 I=1,NATOMS
         IF(LABELS(I).NE.99)THEN
            L=L+1
            LABELS(L)=LABELS(I)
         ENDIF
   80 CONTINUE
      NATOMS=NUMAT
      CALL XYZINT(COORD,NUMAT,NA,NB,NC,1.D0,GEO)
      CALL GMETRY(GEO,COORD)
      IF(INDEX(KEYWRD,'THERMO').NE.0 .AND.GNORM.GT.1.D0) THEN
         WRITE(6,'(//30X,''**** WARNING ****'',//
     110X,'' GRADIENT IS VERY LARGE FOR A THERMO CALCULATION'',/
     210X,'' RESULTS ARE LIKELY TO BE INACCURATE IF THERE ARE'')')
         WRITE(6,'(10X,'' ANY LOW-LYING VIBRATIONS (LESS THAN ABOUT ''
     1,''400CM-1)'')')
         WRITE(6,'(10X,'' GRADIENT NORM SHOULD BE LESS THAN ABOUT '',
     1''0.2 FOR THERMO'',/10X,'' TO GIVE ACCURATE RESULTS'')')
      ENDIF
      IF(TSCF.GT.0.D0) THEN
         WRITE(6,'(//10X,''TIME FOR SCF CALCULATION ='',F12.5)')TSCF
         WRITE(6,'(//10X,''TIME FOR DERIVATIVES     ='',F12.5)')TDER
      ENDIF
      IF(NDEP.GT.0) THEN
         WRITE(6,'(//10X,''SYMMETRY WAS SPECIFIED, BUT '',
     1''CANNOT BE USED HERE'')')
         NDEP=0
      ENDIF
      IF(PRNT)CALL AXIS(COORD,NUMAT,A,B,C,WTMOL,2,ROT)
      NVIB=3*NUMAT-6
      IF(ABS(C).LT.1.D-20)NVIB=NVIB+1
      IF(ID.NE.0)NVIB=3*NUMAT-3
      IF(PRNT) THEN
         WRITE(6,'(/9X,''ORIENTATION OF MOLECULE IN FORCE CALCULATION'')
     1')
         WRITE(6,'(/,4X,''NO.'',7X,''ATOM'',9X,''X'',
     19X,''Y'',9X,''Z'',/)')
      ENDIF
      L=0
cmgc-start
      open(unit=5,form='formatted',status='old',file='HINP')
      rewind 5
      read(5,'(a)') filenm
      read(5,'(a)') filenm
      read(5,'(a)') filenm
cmgc-end
      DO 90 I=1,NATOMS
         IF(LABELS(I) .EQ. 99) GOTO 90
         L=L+1
cmgc-start
      read (5,*) filenm,coord(1,l),idum,coord(2,l),idum,coord(3,l),idum
cmgc-end
         IF(PRNT)WRITE(6,'(I6,7X,I3,4X,6F10.4)')
     1    L,LABELS(I),(COORD(J,L),J=1,3)

   90 CONTINUE
cmgc-start
      close(unit=5,status='keep')
cmgc-end
      CALL FMAT(FMATRX, NVIB, TSCF, TDER, DELDIP,ESCF)
C
C   THE FORCE MATRIX IS PRINTED AS AN ATOM-ATOM MATRIX RATHER THAN
C   AS A 3N*3N MATRIX, AS THE 3N MATRIX IS VERY CONFUSING!
C
      IJ=0
      IU=0
      DO 120 I=1,NUMAT
         IL=IU+1
         IU=IL+2
         IM1=I-1
         JU=0
         DO 110 J=1,IM1
            JL=JU+1
            JU=JL+2
            SUM=0.D0
            DO 100 II=IL,IU
               DO 100 JJ=JL,JU
  100       SUM=SUM+FMATRX((II*(II-1))/2+JJ)**2
            IJ=IJ+1
  110    STORE(IJ)=SQRT(SUM)
         IJ=IJ+1
  120 STORE(IJ)=SQRT(
     1FMATRX(((IL+0)*(IL+1))/2)**2+
     2FMATRX(((IL+1)*(IL+2))/2)**2+
     3FMATRX(((IL+2)*(IL+3))/2)**2+2.D0*(
     4FMATRX(((IL+1)*(IL+2))/2-1)**2+
     5FMATRX(((IL+2)*(IL+3))/2-2)**2+
     6FMATRX(((IL+2)*(IL+3))/2-1)**2))
      IF(DEBUG) THEN
         WRITE(6,'(//10X,'' FULL FORCE MATRIX, INVOKED BY "DFORCE"'')')
         I=-NVAR
         CALL VECPRT(FMATRX,I)
      ENDIF
cmgc
cmgc      open(unit=71,form='formatted',status='unknown',
cmgc     .                             file='NDDO_HES')

      open(unit=71,form='unformatted',status='unknown',
     .                             file='NDDO_HES')
      rewind 71

      idim = natoms*3
      iidim = idim*(idim+1)/2

cmgc      write(71,'(3e20.13)')(fmatrx(imgc), imgc=1,iidim)  
      write(71)(fmatrx(imgc), imgc=1,iidim)  

      close(unit=71,status='keep')
      call Aces_ja_Fin
      call exit(0)
      
cmgc
      IF(PRNT)THEN
         WRITE(6,'(//10X,'' FORCE MATRIX IN MILLIDYNES/ANGSTROM'')')
         CALL VECPRT(STORE,NUMAT)
      ENDIF
      L=(NVAR*(NVAR+1))/2
      DO 130 I=1,L
  130 STORE(I)=FMATRX(I)
      IF(PRNT) CALL AXIS(COORD,NUMAT,A,B,C,SUM,0,ROT)
      IF(PRNT)WRITE(6,'(//10X,''HEAT OF FORMATION ='',F12.6,
     1'' KCALS/MOLE'')')ESCF
      IF(LARGE)THEN
         CALL FRAME(STORE,NUMAT,0, SHIFT)
         CALL RSP(STORE,NVAR,NVAR,FREQ,CNORML)
         DO 140 I=NVIB+1,NVAR
            J=(FREQ(I)+50.D0)*0.01D0
  140    FREQ(I)=FREQ(I)-J*100
         IF(PRNT)THEN
            WRITE(6,'(//10X,''TRIVIAL VIBRATIONS, SHOULD BE ZERO'')')
            WRITE(6,'(/, F9.4,''=TX'',F9.4,''=TY'',F9.4,''=TZ'',
     1             F9.4,''=RX'',F9.4,''=RY'',F9.4,''=RZ'')')
     2(FREQ(I),I=NVIB+1,NVAR)
            WRITE(6,'(//10X,''FORCE CONSTANTS IN MILLIDYNES/ANGSTROM''
     1,'' (= 10**5 DYNES/CM)'',/)')
            WRITE(6,'(8F10.5)')(FREQ(I),I=1,NVIB)
C CONVERT TO WEIGHTED FMAT
            WRITE(6,'(//10X,'' ASSOCIATED EIGENVECTORS'')')
            I=-NVAR
            CALL MATOUT(CNORML,FREQ,NVIB,I,NVAR)
         ENDIF
      ENDIF
      CALL FREQCY(FMATRX,FREQ,CNORML,REDMAS,TRAVEL,.TRUE.)
C
C  CALCULATE ZERO POINT ENERGY
C
C
C  THESE CONSTANTS TAKEN FROM HANDBOOK OF CHEMISTRY AND PHYSICS 62ND ED.
C   N AVOGADRO'S NUMBER = 6.022045*10**23
C   H PLANCK'S CONSTANT = 6.626176*10**(-34)JHZ
C   C SPEED OF LIGHT    = 2.99792458*10**10 CM/SEC
C   CONST=0.5*N*H*C/(1000*4.184)
      CONST=1.4295718D-3
      SUM=0.D0
      DO 150 I=1,NVAR
  150 SUM=SUM+FREQ(I)
      SUM=SUM*CONST
      IF(PRNT)
     1WRITE(6,'(//10X,'' ZERO POINT ENERGY''
     2, F12.3,'' KILOCALORIES PER MOLE'')')SUM
      SUMM=0.D0
      DO 200 I=1,NVAR
         SUM1=1.D-20
         DO 160 J=1,NVAR
  160    SUM1=SUM1+CNORML(J+(I-1)*NVAR)**2
         SUM1=1.D0/SQRT(SUM1)
         DO 170 K=1,3
  170    GRAD(K)=0.D0
         DO 190 K=1,3
            SUM=0.D0
            DO 180 J=1,NVAR
  180       SUM=SUM+CNORML(J+(I-1)*NVAR)*DELDIP(K,J)
            SUMM=SUMM+ABS(SUM)
  190    TRDIP(K,I)=SUM*SUM1
         DIPT(I)=SQRT(TRDIP(1,I)**2+TRDIP(2,I)**2+TRDIP(3,I)**2)
  200 CONTINUE
      IF(PRNT)THEN
         WRITE(6,'(//3X,'' THE LAST'',I2,'' VIBRATIONS ARE THE'',
     1'' TRANSLATION AND ROTATION MODES'')')NVAR-NVIB
         WRITE(6,'(3X,'' THE FIRST THREE OF THESE BEING TRANSLATIONS'',
     1'' IN X, Y, AND Z, RESPECTIVELY'')')
      ENDIF
      IF(PRNT.AND.LARGE)THEN
         WRITE(6,'(//10X,'' FREQUENCIES, REDUCED MASSES AND '',
     1''VIBRATIONAL DIPOLES''/)')
         NTO6=NVAR/6
         NREM6=NVAR-NTO6*6
         IINC1=-5
         IF (NTO6.LT.1) GO TO 220
         DO 210 I=1,NTO6
            WRITE (6,'(/)')
            IINC1=IINC1+6
            IINC2=IINC1+5
            WRITE (6,'(3X,''I'',10I10)') (J,J=IINC1,IINC2)
            WRITE (6,'('' FREQ(I)'',6F10.4,/)') (FREQ(J),J=IINC1,IINC2)
            WRITE (6,'('' MASS(I)'',6F10.5,/)') (REDMAS(J),J=IINC1,IINC2
     1)
            WRITE (6,'('' DIPX(I)'',6F10.5)') (TRDIP(1,J),J=IINC1,IINC2)
            WRITE (6,'('' DIPY(I)'',6F10.5)') (TRDIP(2,J),J=IINC1,IINC2)
            WRITE (6,'('' DIPZ(I)'',6F10.5,/)') (TRDIP(3,J),J=IINC1,IINC
     12)
            WRITE (6,'('' DIPT(I)'',6F10.5)')
     1   (DIPT(J),J=IINC1,IINC2)
  210    CONTINUE
  220    CONTINUE
         IF (NREM6.LT.1) GO TO 230
         WRITE (6,'(/)')
         IINC1=IINC1+6
         IINC2=IINC1+(NREM6-1)
         WRITE (6,'(3X,''I'',10I10)') (J,J=IINC1,IINC2)
         WRITE (6,'('' FREQ(I)'',6F10.4)') (FREQ(J),J=IINC1,IINC2)
         WRITE (6,'(/,'' MASS(I)'',6F10.5)') (REDMAS(J),J=IINC1,IINC2)
         WRITE (6,'(/,'' DIPX(I)'',6F10.5)') (TRDIP(1,J),J=IINC1,IINC2)
         WRITE (6,'('' DIPY(I)'',6F10.5)') (TRDIP(2,J),J=IINC1,IINC2)
         WRITE (6,'('' DIPZ(I)'',6F10.5)') (TRDIP(3,J),J=IINC1,IINC2)
         WRITE (6,'(/,'' DIPT(I)'',6F10.5)')
     1   (DIPT(J),J=IINC1,IINC2)
  230    CONTINUE
      ENDIF
      WRITE(6,'(//10X,'' NORMAL COORDINATE ANALYSIS'')')
      I=-NVAR
      CALL MATOUT(CNORML,FREQ,NVAR,I,NVAR)
C
C   CARRY OUT IRC IF REQUESTED.
C
      IF(INDEX(KEYWRD,'IRC')+INDEX(KEYWRD,'DRC').NE.0)THEN
         DO 240 I=1,NVAR
            LOC(1,I)=0
  240    LOC(2,I)=0
         NVAR=NVAOLD
         DO 250 I=1,NVAR
            LOC(1,I)=LOCOLD(1,I)
  250    LOC(2,I)=LOCOLD(2,I)
         CALL XYZINT(COORD,NUMAT,NA,NB,NC,1.D0,GEO)
         LAST=1
         CALL DRC(CNORML,FREQ)
         STOP
      ENDIF
      CALL FREQCY(FMATRX,FREQ,CNORML,DELDIP,DELDIP,.FALSE.)
      WRITE(6,'(//10X,'' MASS-WEIGHTED COORDINATE ANALYSIS'')')
      CALL MATOUT(CNORML,FREQ,NVAR,I,NVAR)
      CALL ANAVIB(COORD,FREQ,DIPT,NVAR,CNORML,STORE,
     1FMATRX,TRAVEL,REDMAS)
      IF(INDEX(KEYWRD,'THERMO').NE.0) THEN
         CALL GMETRY(GEO,COORD)
         I=INDEX(KEYWRD,' ROT')
         IF(I.NE.0) THEN
            SYM=READA(KEYWRD,I)
         ELSE
            SYM=1
         ENDIF
         LINEAR=(ABS(A*B*C) .LT. 1.D-10)
         I=INDEX(KEYWRD,' TRANS')
C
C   "I" IS GOING TO MARK THE BEGINNING OF THE GENUINE VIBRATIONS.
C
         IF(I.NE.0)THEN
            I=INDEX(KEYWRD,' TRANS=')
            IF(I.NE.0)THEN
               I=1+READA(KEYWRD,I)
               J=NVIB-I+1
               WRITE(6,'(//1X,''THE LOWEST'',I3,'' VIBRATIONS ARE NOT'',
     1/,'' TO BE USED IN THE THERMO CALCULATION'')')I-1
            ELSE
               WRITE(6,'(//10X,''SYSTEM IS A TRANSITION STATE'')')
               I=2
               J=NVIB-1
            ENDIF
         ELSE
            WRITE(6,'(//10X,''SYSTEM IS A GROUND STATE'')')
            I=1
            J=NVIB
         ENDIF
         CALL THERMO(A,B,C,LINEAR,SYM,WTMOL,FREQ(I),J,ESCF)
      ENDIF
      RETURN
      END
      SUBROUTINE MULLIK(C,CBETA,UHF,H,F,NORBS,VECS,STORE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
      LOGICAL UHF
      DIMENSION C(*), CBETA(*), H(*), VECS(*), STORE(*), F(*)
**********************************************************************
*
*  MULLIK DOES A MULLIKEN POPULATION ANALYSIS
* ON INPUT     C      =  SQUARE ARRAY OF EIGENVECTORS.
*              H      =  PACKED ARRAY OF ONE-ELECTRON MATRIX
*              F      =  WORKSTORE OF SIZE AT LEAST NORBS*NORBS
*              VECS   =  WORKSTORE OF SIZE AT LEAST NORBS*NORBS
*              STORE  =  WORKSTORE OF SIZE AT LEAST (NORBS*(NORBS+1))/2
*
**********************************************************************
C Common MOLKST splitted in MOLKSI and MOLKSR    Ivan Rossi 0394   &8)
      COMMON /MOLKSI/ NUMAT,NAT(NUMATM),NFIRST(NUMATM),
     1                NMIDLE(NUMATM),NLAST(NUMATM), NDUMMY,
     2                NELECS,NALPHA,NBETA,NCLOSE,NOPEN
     3       /MOLKSR/ FRACT
     4       /KEYWRD/ KEYWRD
     5       /BETAS / BETAS(107),BETAP(107),BETAD(107)
      COMMON /GEOM  / GEO(3,NUMATM)
      COMMON /EXPONT/ ZS(107),ZP(107),ZD(107)
      COMMON /SRPL/ ISSRP                                               IR0594
      CHARACTER*4 BETF                                                  IR0594
      CHARACTER*1 BETL                                                  IR0594
      CHARACTER*5 BETTYP                                                IR0594
      LOGICAL GRAPH,ISSRP                                               IR0594
      CHARACTER KEYWRD*80
**********************************************************************
*
*  FIRST, RE-CALCULATE THE OVERLAP MATRIX
*
**********************************************************************
      DIMENSION EIGS(MAXORB), IFACT(MAXORB), XYZ(3,NUMATM)
         SAVE                                                           GL0892
      GRAPH=(INDEX(KEYWRD,'GRAPH').NE.0)
      DO 10 I=1,NORBS
   10 IFACT(I)=(I*(I-1))/2
      IFACT(NORBS+1)=(NORBS*(NORBS+1))/2
C
C  START of special SRP BETA handling (Ivan Rossi - May '94)
C
      IF(ISSRP) THEN
         DO 15 I=1,NUMAT
            IF=NFIRST(I)
            IL=NLAST(I)
            IM1=I-1
            BETF= 'BETS'
            DO 15 K=IF,IL
               II=(K*(K-1))/2
               DO 13 J=1,IM1
                  JF=NFIRST(J)
                  JL=NLAST(J)
                  BETL='S'
                  DO 12 JJ=JF,JL
                     IJ=II+JJ
                     BETTYP=BETF//BETL
                     IF( BETTYP .eq. 'BETPS') THEN
                          H(IJ)=H(IJ)/GETBET(NAT(J), NAT(I),'BETSP')
                     ELSE
                          H(IJ)=H(IJ)/GETBET(NAT(I), NAT(J), BETTYP)
                     ENDIF
                     STORE(IJ)=H(IJ)
   12             BETL='P'
   13          CONTINUE
               DO 14 JJ=IF,K
                  IJ=II+JJ
                  STORE(IJ)=0.D0
   14          H(IJ)=0.D0
   15    BETF='BETP'
      ELSE
C
C ...build Density matrix in the standard way (END of SRP BETA handling
C
         DO 50 I=1,NUMAT
            IF=NFIRST(I)
            IL=NLAST(I)
            IM1=I-1
            BI=BETAS(NAT(I))
            DO 50 K=IF,IL
               II=(K*(K-1))/2
               DO 30 J=1,IM1
                  JF=NFIRST(J)
                  JL=NLAST(J)
                  BJ=BETAS(NAT(J))
                  DO 20 JJ=JF,JL
                     IJ=II+JJ
                     H(IJ)=2.D0*H(IJ)/(BI+BJ)     +1.D-14
C  THE  +1.D-14 IS TO PREVENT POSSIBLE ERRORS IN THE DIAGONALIZATION.
                     STORE(IJ)=H(IJ)
   20             BJ=BETAP(NAT(J))
   30          CONTINUE
               DO 40 JJ=IF,K
                  IJ=II+JJ
                  STORE(IJ)=0.D0
   40          H(IJ)=0.D0
   50    BI=BETAP(NAT(I))
      ENDIF                                                             IR0594
      DO 60 I=1,NORBS
         STORE(IFACT(I+1))=1.D0
   60 H(IFACT(I+1))=1.D0
      CALL RSP(H,NORBS,NORBS,EIGS,VECS)
      DO 70 I=1,NORBS
   70 EIGS(I)=1.D0/SQRT(ABS(EIGS(I)))
      IJ=0
      DO 90 I=1,NORBS
         DO 90 J=1,I
            IJ=IJ+1
            SUM=0.D0
            DO 80 K=1,NORBS
   80       SUM=SUM+VECS(I+(K-1)*NORBS)*EIGS(K)
     1                *VECS(J+(K-1)*NORBS)
            F(I+(J-1)*NORBS)=SUM
   90 F(J+(I-1)*NORBS)=SUM
      IF (GRAPH) THEN
         CALL GMETRY(GEO,XYZ)
*
* WRITE TO DISK THE FOLLOWING DATA FOR GRAPHICS CALCULATION, IN ORDER:
*
*      NUMBER OF ATOMS, ORBITAL, ELECTRONS
*      ALL ATOMIC COORDINATES
*      ORBITAL COUNTERS
*      ORBITAL EXPONENTS, S, P, AND D, AND ATOMIC NUMBERS
*      EIGENVECTORS (M.O.S NOT RE-NORMALIZED)
*      INVERSE-SQUARE ROOT OF THE OVERLAP MATRIX.
*
         OPEN(UNIT=13,FILE='FOR013',FORM='UNFORMATTED',STATUS='NEW')
         WRITE(13)NUMAT,NORBS,NELECS,((XYZ(I,J),J=1,NUMAT),I=1,3)
         WRITE(13)(NLAST(I),NFIRST(I),I=1,NUMAT)
         WRITE(13)(ZS(NAT(I)),I=1,NUMAT),(ZP(NAT(I)),I=1,NUMAT),
     1         (ZD(NAT(I)),I=1,NUMAT),(NAT(I),I=1,NUMAT)
         LINEAR=NORBS*NORBS
         WRITE(13)(C(I),I=1,LINEAR)
         WRITE(13)(F(I),I=1,LINEAR)
         RETURN
      ENDIF
*
* OTHERWISE PERFORM MULLIKEN ANALYSIS
*
C
C      SUBSTITUTING  CRAY MXM WITH BLAS LEVEL 3 DGEMM                     IR0394
C      call mxm(c,norbs,f,norbs,vecs,norbs)
C
      call xgemm('n','n', norbs, norbs, norbs, 1.0d0,
     1            c, norbs, f, norbs, 0.0d0, vecs, norbs)

      I=-1
      CALL DENSIT(VECS,NORBS,NORBS,NCLOSE,NOPEN,FRACT,C,2)
      LINEAR=(NORBS*(NORBS+1))/2
      DO 100 I=1,LINEAR
  100 C(I)=C(I)*STORE(I)
      SUMM=0.D0
      DO 130 I=1,NORBS
         SUM=0
         DO 110 J=1,I
  110    SUM=SUM+C(IFACT(I)+J)
         DO 120 J=I+1,NORBS
  120    SUM=SUM+C(IFACT(J)+I)
         SUMM=SUMM+SUM
  130 C(IFACT(I+1))=SUM
      CALL VECPRT(C,NORBS)
      RETURN
      END
      SUBROUTINE NLLSQ(X,N)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
C
      COMMON /KEYWRD/ KEYWRD
      CHARACTER*80 KEYWRD
      DIMENSION X(*)
      COMMON /MESAGE/ IFLEPO,IITER
************************************************************************
*
*  NLLSQ IS A NON-DERIVATIVE, NONLINEAR LEAST-SQUARES MINIMIZER. IT USES
*        BARTEL'S PROCEDURE TO MINIMIZE A FUNCTION WHICH IS A SUM OF
*        SQUARES.
*
*    ON INPUT N    = NUMBER OF UNKNOWNS
*             X    = PARAMETERS OF FUNCTION TO BE MINIMIZED.
*
*    ON EXIT  X    = OPTIMIZED PARAMETERS.
*
*    THE FUNCTION TO BE MINIMIZED IS "COMPFG". COMPFG MUST HAVE THE
*    CALLING SEQUENCE
*                  CALL COMPFG(XPARAM,.TRUE.,ESCF,.TRUE.,EFS,.TRUE.)
*                  GMIN=ddot(n,EFS,1,EFS,1)
*    WHERE   EFS  IS A VECTOR WHICH  COMPFG  FILLS WITH THE N INDIVIDUAL
*                 COMPONENTS OF THE ERROR FUNCTION AT THE POINT X
*            SSQ IS THE VALUE OF THE SUM OF THE  EFS  SQUARED.
*    IN THIS FORMULATION OF NLLSQ M AND N ARE THE SAME.
*    THE PRECISE DEFINITIONS OF THESE TWO QUANTITIES IS:
*
*     N = NUMBER OF PARAMETERS TO BE OPTIMIZED.
*     M = NUMBER OF REFERENCE FUNCTIONS. M MUST BE GREATER THEN, OR
*         EQUAL TO, N
************************************************************************
C     Q = ORTHOGONAL MATRIX   (M BY M)
C     R = RIGHT-TRIANGULAR MATRIX   (M BY N)
C     MXCNT(1) = MAX ALLOW OVERALL FUN EVALS
C     MXCNT(2) = MAX ALLOW NO OF FNC EVALS PER LIN SEARCH
C     TOLS1 = RELATIVE TOLERANCE ON X OVERALL
C     TOLS2 = ABSOLUTE TOLERANCE ON X OVERALL
C     TOLS5 = RELATIVE TOLERANCE ON X FOR LINEAR SEARCHES
C     TOLS6 = ABSOLUTE TOLERANCE ON X FOR LINEAR SEARCHES
C     IPRINT = PRINT SWITCH
C     NRST = NUMBER OF CYCLES BETWEEN SIDESTEPS
C     **********
      COMMON /TIMER / TIME0
      COMMON /NLLSQI/ NCOUNT
      COMMON /NUMSCF/ NSCF
      DIMENSION Y(MAXPAR), EFS(MAXPAR), P(MAXPAR)
      COMMON /LAST  / LAST
      COMMON /NLLCOM/DDDUM(6),EFSLST(MAXPAR),Q(MAXPAR,MAXPAR),
     1               R(MAXPAR,MAXPAR),XLAST(MAXPAR),
     2               IIIUM(7),IDUMY(2*MAXPAR*MAXPAR-19-MAXPAR*4)
      LOGICAL MIDDLE, SCF1, RESFIL
      CHARACTER SPACE*1, CHDOT*1, ZERO*1, NINE*1, CH*1
      EQUIVALENCE ( IIIUM(2), ICYC),(IIIUM(3), IRST),
     1(IIIUM(4),JRST),
     2(DDDUM(2),ALF), (DDDUM(3),SSQ),(DDDUM(4), PN)
         SAVE                                                           GL0892
      DATA SPACE,CHDOT,ZERO,NINE /' ','.','0','9'/
      MIDDLE=(INDEX(KEYWRD,'RESTART') .NE. 0)
      SCF1=(INDEX(KEYWRD,'1SCF') .NE. 0)
      IFLEPO=10
C*
      M=N
C*
      TOL2=4.D-1
      IF(INDEX(KEYWRD,'GNORM') .NE. 0) THEN
         TOL2=READA(KEYWRD,INDEX(KEYWRD,'GNORM'))
         IF(TOL2.LT.0.001D0.AND.INDEX(KEYWRD,'LET').EQ.0)THEN
            WRITE(6,'(/,A)')'  GNORM HAS BEEN SET TOO LOW, RESET TO 0
     1.001'
            TOL2=0.001D0
         ENDIF
      ENDIF
      LAST=0
      MXCYCL=100
      I=INDEX(KEYWRD,'CYCLES')
      IF (I.NE.0) THEN
         MXCYCL=READA(KEYWRD,I)
         WRITE(6,'(/10X,''NUMBER OF CYCLES TO BE RUN ='',I5)')MXCYCL
      ENDIF
      TOLS1=1.D-12
      TOLS2=1.D-10
      TOLS5=1.D-6
      TOLS6=1.D-3
      IPRINT=-1
      NRST=4
      YMAXST=1.D0
      TLEFT=MAXTIM
      I=INDEX(KEYWRD,' T=')
      IF(I.NE.0) THEN
         TIM=READA(KEYWRD,I)
         DO 10 J=I+3,80
            IF( KEYWRD(J+1:J+1).EQ.' ') THEN
               CH=KEYWRD(J:J)
               IF( CH .EQ. 'M') TIM=TIM*60
               IF( CH .EQ. 'H') TIM=TIM*3600
               IF( CH .EQ. 'D') TIM=TIM*86400
               GOTO 20
            ENDIF
   10    CONTINUE
   20    TLEFT=TIM
      ENDIF
      TLAST=TLEFT
      TDUMP=MAXDMP
      I=INDEX(KEYWRD,' DUMP')
      IF(I.NE.0) THEN
         TDUMP=READA(KEYWRD,I)
         DO 30 J=I+6,80
            IF( KEYWRD(J+1:J+1).EQ.' ') THEN
               CH=KEYWRD(J:J)
               IF( CH .EQ. 'M') TDUMP=TDUMP*60
               IF( CH .EQ. 'H') TDUMP=TDUMP*3600
               IF( CH .EQ. 'D') TDUMP=TDUMP*86400
               GOTO 40
            ENDIF
   30    CONTINUE
   40    CONTINUE
      ENDIF
      RESFIL=.FALSE.
cmgc      TLEFT=TLEFT-SECOND()+TIME0
C     **********
C     SET UP COUNTERS AND SWITCHES
C     **********
      NTO=N/6
      IFRTL=0
      NREM=N-(NTO*6)
      IREPET=0
      NSST=0
      IF(IXSO.EQ.0) IXSO=N
      NP1 = N+1
      NP2 = N+2
      ICYC = 0
      IRST = 0
      JRST = 1
      EPS =TOLS5
      T = TOLS6
C     **********
C     GET STARTING-POINT FUNCTION VALUE
C     SET UP ESTIMATE OF INITIAL LINE STEP
C     **********
      IF(MIDDLE) THEN
         CALL PARSAV(0,N,M)
         NSCF=IIIUM(1)
         CLOSE(13)
         NCOUNT=IIIUM(5)
         MXCYCL=MXCYCL+ICYC
         DO 50 I=1,N
   50    X(I)=XLAST(I)
cmgc         TIME1=SECOND()
         GOTO 100
      ENDIF
      CALL COMPFG(X,.TRUE.,ESCF,.TRUE.,EFSLST,.TRUE.)
      IF( SCF1 ) GOTO 920
      SSQ=ddot(n,efslst,1,efslst,1)
      NCOUNT = 1
   60 CONTINUE
      do 70 j=1,n
      do 70 i=1,n
      r(i,j) = 0.0
      q(i,j) = 0.0
70    continue
      do 80 i=1,n
      r(i,i) = 1.0
      q(i,i) = 1.0
80    continue
      TEMP = 0.0D0
      DO 90 I=1,N
   90 TEMP = TEMP+X(I)**2
      ALF = 100.0D0*(EPS*SQRT(TEMP)+T)
C     **********
C     MAIN LOOP
C     **********
cmgc      TIME1=SECOND()
  100 CONTINUE
C     **********
C     UPDATE COUNTERS AND TEST FOR PRINTING THIS CYCLE
C     **********
      IFRTL=IFRTL+1
      ICYC = ICYC+1
      IRST = IRST+1
C     **********
C     SET  PRT,  THE LEVENBERG-MARQUARDT PARAMETER.
C     **********
      PRT = SQRT(SSQ)
C     **********
C     IF A SIDESTEP IS TO BE TAKEN, GO TO 31
C     **********
      IF (IRST .GE. NRST)  GO TO 250
C     **********
C     SOLVE THE SYSTEM    Q*R*P = -EFSLST    IN THE LEAST-SQUARES SENSE
C     **********
      NSST=0
      DO 120 I=1,M
         TEMP = 0.0D0
         DO 110 J=1,M
  110    TEMP = TEMP-Q(J,I)*EFSLST(J)
  120 EFS(I) = TEMP
      DO 130 J=1,N
         JJ = NP1-J
         DO 130 I=1,J
            II = NP2-I
  130 R(II,JJ) = R(I,J)
      DO 200 I=1,N
         I1 = I+1
         Y(I) = PRT
         EFSSS=0.0D0
         IF (I .GE. N)  GO TO 150
         DO 140 J=I1,N
  140    Y(J) = 0.0D0
  150    CONTINUE
         DO 190 J=I,N
            II = NP2-J
            JJ = NP1-J
            IF (ABS(Y(J)) .LT. ABS(R(II,JJ)))  GO TO 160
            TEMP = Y(J)*SQRT(1.0D0+(R(II,JJ)/Y(J))**2)
            GO TO 170
  160       TEMP = R(II,JJ)*SQRT(1.0D0+(Y(J)/R(II,JJ))**2)
  170       CONTINUE
            SIN = R(II,JJ)/TEMP
            COS = Y(J)/TEMP
            R(II,JJ) = TEMP
            TEMP = EFS(J)
            EFS(J)=SIN*TEMP+COS*EFSSS
            EFSSS=SIN*EFSSS-COS*TEMP
            IF (J .GE. N)  GO TO 200
            J1 = J+1
            DO 180 K=J1,N
               JJ = NP1-K
               TEMP = R(II,JJ)
               R(II,JJ) = SIN*TEMP+COS*Y(K)
  180       Y(K) = SIN*Y(K)-COS*TEMP
  190    CONTINUE
  200 CONTINUE
      P(N) = EFS(N)/R(2,1)
      I = N
  210 I = I-1
      IF (I)  240,240,220
  220 TEMP = EFS(I)
      K = I+1
      II = NP2-I
      DO 230 J=K,N
         JJ = NP1-J
  230 TEMP = TEMP-R(II,JJ)*P(J)
      JJ = NP1-I
      P(I) = TEMP/R(II,JJ)
      GO TO 210
  240 CONTINUE
      GO TO 270
C     **********
C     SIDESTEP SECTION
C     **********
  250 JRST = JRST+1
      NSST=NSST+1
      IF(NSST.GE.IXSO) GO TO 710
      IF (JRST .GT. N)  JRST=2
      IRST = 0
C     **********
C     PRODUCTION OF A VECTOR ORTHOGONAL TO THE LAST P-VECTOR
C     **********
      WORK = PN*(ABS(P(1))+PN)
      TEMP = P(JRST)
      P(1) = TEMP*(P(1)+SIGN(PN,P(1)))
      DO 260 I=2,N
  260 P(I) = TEMP*P(I)
      P(JRST) = P(JRST)-WORK
C     **********
C     COMPUTE NORM AND NORM-SQUARE OF THE P-VECTOR
C     **********
  270 PNLAST = PN
      PN=0.D0
      PN2 = 0.0D0
      DO 280 I=1,N
         PN=PN+ABS(P(I))
  280 PN2 = PN2+P(I)**2
      IF(PN.LT.1.D-20) THEN
         WRITE(6,'('' SYSTEM DOES NOT APPEAR TO BE OPTIMIZABLE.'',/
     1,'' THIS CAN HAPPEN IF (A) IT WAS OPTIMIZED TO BEGIN WITH'',/
     2,'' OR                 (B) IT IS NEITHER A GROUND NOR A'',
     3'' TRANSITION STATE'')')
         CALL GEOUT
         STOP
      ENDIF
      IF(PN2.LT.1.D-20)PN2=1.D-20
      PN = SQRT(PN2)
      IF(ALF.GT.1.D20)ALF=1.D20
      IF(ICYC .GT. 1) THEN
         ALF=ALF*1.D-20*PNLAST/PN
         IF(ALF.GT.1.D10)        ALF=1.D10
         ALF=ALF*1.D20
      ENDIF
      TTMP=ALF*PN
      IF(TTMP.LT.0.0001D0) ALF=0.001D0/PN
C     **********
C     PRINTING SECTION
C     **********
C#      WRITE(6,501)TLEFT,ICYC,SSQ
      DO 290 I=1,N
         EFS(I)=X(I)
  290 CONTINUE
C     **********
C     PERFORM LINE-MINIMIZATION FROM POINT X IN DIRECTION P OR -P
C     **********
      SSQLST = SSQ
      DO 300 I=1,N
         EFS(I)=0.D0
  300 XLAST(I)=X(I)
      CALL LOCMIN(M,X,N,P,SSQ,ALF,EFS,IERR,ESCF)
      IF(SSQLST .LT. SSQ ) THEN
         IF(IERR .EQ. 0)      SSQ=SSQLST
         DO 310 I=1,N
  310    X(I)=XLAST(I)
         IRST=NRST
         PN=PNLAST
         TIME2=TIME1
cmgc         TIME1=SECOND()
         TCYCLE=TIME1-TIME2
         TLEFT=TLEFT-TCYCLE
         IF(TLEFT .GT. TCYCLE*2) GO TO 100
         GOTO 670
      ENDIF
      IREPET=0
C     **********
C     PRODUCE THE VECTOR   R*P
C     **********
      DO 330 I=1,N
         TEMP = 0.0D0
         DO 320 J=I,N
  320    TEMP = TEMP+R(I,J)*P(J)
  330 Y(I) = TEMP
C     **********
C     PRODUCE THE VECTOR ...
C                  Y  =    (EFS-EFSLST-ALF*Q*R*P)/(ALF*(NORMSQUARE(P))
C     COMPUTE NORM OF THIS VECTOR AS WELL
C     **********
      WORK = ALF*PN2
      YN = 0.0D0
      DO 350 I=1,M
         TEMP = 0.0D0
         DO 340 J=1,N
  340    TEMP = TEMP+Q(I,J)*Y(J)
         TEMP = (EFS(I)-EFSLST(I)-ALF*TEMP)
         EFSLST(I) = EFS(I)
         YN = YN+TEMP**2
  350 EFS(I) = TEMP/WORK
      YN = SQRT(YN)/WORK
C     **********
C     THE BROYDEN UPDATE   NEW MATRIX = OLD MATRIX + Y*(P-TRANS)
C     HAS BEEN FORMED.  IT IS NOW NECESSARY TO UPDATE THE  QR DECOMP.
C     FIRST LET    Y = (Q-TRANS)*Y.
C     **********
      DO 370 I=1,M
         TEMP = 0.0D0
         DO 360 J=1,M
  360    TEMP = TEMP+Q(J,I)*EFS(J)
  370 Y(I) = TEMP
C     **********
C     REDUCE THE VECTOR Y TO A MULTIPLE OF THE FIRST UNIT VECTOR USING
C     A HOUSEHOLDER TRANSFORMATION FOR COMPONENTS N+1 THROUGH M AND
C     ELEMENTARY ROTATIONS FOR THE FIRST N+1 COMPONENTS.  APPLY ALL
C     TRANSFORMATIONS TRANSPOSED ON THE RIGHT TO THE MATRIX Q, AND
C     APPLY THE ROTATIONS ON THE LEFT TO THE MATRIX R.
C     THIS GIVES    (Q*(V-TRANS))*((V*R) + (V*Y)*(P-TRANS)),    WHERE
C     V IS THE COMPOSITE OF THE TRANSFORMATIONS.  THE MATRIX
C     ((V*R) + (V*Y)*(P-TRANS))    IS UPPER HESSENBERG.
C     **********
      IF (M .LE. NP1)  GO TO 430
C
C THE NEXT THREE LINES WERE INSERTED TO TRY TO GET ROUND OVERFLOW BUGS.
C
      CONST=1.D-12
      DO 380 I=NP1,M
  380 CONST=MAX(ABS(Y(NP1)),CONST)
      YTAIL = 0.0D0
      DO 390 I=NP1,M
  390 YTAIL = YTAIL+(Y(I)/CONST)**2
      YTAIL = SQRT(YTAIL)*CONST
      BET = (1.0D25/YTAIL)/(YTAIL+ABS(Y(NP1)))
      Y(NP1) = SIGN (YTAIL+ABS(Y(NP1)),Y(NP1))
      DO 420 I=1,M
         TMP = 0.0D0
         DO 400 J=NP1,M
  400    TMP = TMP+Q(I,J)*Y(J)*1.D-25
         TMP = BET*TMP
         DO 410 J=NP1,M
  410    Q(I,J) = Q(I,J)-TMP*Y(J)
  420 CONTINUE
      Y(NP1) = YTAIL
      I = NP1
      GO TO 440
  430 CONTINUE
      I = M
  440 CONTINUE
  450 J = I
      I = I-1
      IF (I)  520,520,460
  460 IF (Y(J))  470,450,470
  470 IF (ABS(Y(I)) .LT. ABS(Y(J)))  GO TO 480
      TEMP = ABS(Y(I))*SQRT(1.0D0+(Y(J)/Y(I))**2)
      GO TO 490
  480 TEMP = ABS(Y(J))*SQRT(1.0D0+(Y(I)/Y(J))**2)
  490 COS = Y(I)/TEMP
      SIN = Y(J)/TEMP
      Y(I) = TEMP
      DO 500 K=1,M
         TEMP = COS*Q(K,I)+SIN*Q(K,J)
         WORK = -SIN*Q(K,I)+COS*Q(K,J)
         Q(K,I) = TEMP
  500 Q(K,J) = WORK
      IF (I .GT. N)  GO TO 450
      R(J,I) = -SIN*R(I,I)
      R(I,I) = COS*R(I,I)
      IF (J .GT. N)  GO TO 450
      DO 510 K=J,N
         TEMP = COS*R(I,K)+SIN*R(J,K)
         WORK = -SIN*R(I,K)+COS*R(J,K)
         R(I,K) = TEMP
  510 R(J,K) = WORK
      GO TO 450
  520 CONTINUE
C     **********
C     REDUCE THE UPPER-HESSENBERG MATRIX TO UPPER-TRIANGULAR FORM
C     USING ELEMENTARY ROTATIONS.  APPLY THE SAME ROTATIONS, TRANSPOSED,
C     ON THE RIGHT TO THE MATRIX  Q.
C     **********
      DO 530 K=1,N
  530 R(1,K) = R(1,K)+YN*P(K)
      JEND = NP1
      IF (M .EQ. N)  JEND=N
      DO 600 J=2,JEND
         I = J-1
         IF (R(J,I))  540,600,540
  540    IF (ABS(R(I,I)) .LT. ABS(R(J,I)))  GO TO 550
         TEMP = ABS(R(I,I))*SQRT(1.0D0+(R(J,I)/R(I,I))**2)
         GO TO 560
  550    TEMP = ABS(R(J,I))*SQRT(1.0D0+(R(I,I)/R(J,I))**2)
  560    COS = R(I,I)/TEMP
         SIN = R(J,I)/TEMP
         R(I,I) = TEMP
         IF (J .GT. N)  GO TO 580
         DO 570 K=J,N
            TEMP = COS*R(I,K)+SIN*R(J,K)
            WORK = -SIN*R(I,K)+COS*R(J,K)
            R(I,K) = TEMP
  570    R(J,K) = WORK
  580    DO 590 K=1,M
            TEMP = COS*Q(K,I)+SIN*Q(K,J)
            WORK = -SIN*Q(K,I)+COS*Q(K,J)
            Q(K,I) = TEMP
  590    Q(K,J) = WORK
  600 CONTINUE
C     **********
C     CHECK THE STOPPING CRITERIA
C     **********
      TEMP = 0.0D0
      DO 610 I=1,N
  610 TEMP = TEMP+X(I)**2
      TOLX = TOLS1*SQRT(TEMP)+TOLS2
      IF (SQRT(ALF*PN2) .LE. TOLX)  GO TO 690
      IF(SSQ.GE.2.D0*N) GO TO 630
      DO 620 I=1,N
C*****
C     The stopping criterion is that no individual gradient be
C         greater than TOL2
C*****
         IF(ABS(EFSLST(I)).GE.TOL2) GO TO 630
  620 CONTINUE
C#      WRITE(6,730) SSQ
      GO TO 700
  630 CONTINUE
      IF (ICYC .GE. MXCYCL)  THEN
         IFLEPO=12
         GOTO 920
      ENDIF
      TIME2=TIME1
cmgc      TIME1=SECOND()
      TCYCLE=TIME1-TIME2
      TLEFT=TLEFT-TCYCLE
      IF(RESFIL)THEN
         WRITE(6,640)TLEFT,SQRT(SSQ),ESCF
  640    FORMAT('  RESTART FILE WRITTEN,  TIME LEFT:',F12.5,
     1' GRAD.:',F10.3,' HEAT:',G14.7)
         RESFIL=.FALSE.
      ELSE
         WRITE(6,650)ICYC,TCYCLE,TLEFT,SQRT(SSQ),ESCF
  650    FORMAT(' CYCLE:',I5,' TIME:',F8.5,' TIME LEFT:',F12.5,
     1' GRAD.:',F10.3,' HEAT:',G14.7)
      ENDIF
      IF(TLAST-TLEFT.GT.TDUMP)THEN
         TLAST=TLEFT
         RESFIL=.TRUE.
         DO 660 I=1,N
  660    XLAST(I)=X(I)
         IIIUM(1)=NSCF
         CALL PARSAV(2,N,M)
      ENDIF
      IF(TLEFT .GT. TCYCLE*2) GO TO 100
  670 IIIUM(5)=NCOUNT
      DO 680 I=1,N
  680 XLAST(I)=X(I)
      IIIUM(1)=NSCF
      CALL PARSAV(1,N,M)
      STOP
  690 WRITE (6,810)  NCOUNT
      GOTO 920
  700 WRITE (6,820)  NCOUNT
      GOTO 920
  710 CONTINUE
      WRITE(6,720) IXSO
  720 FORMAT(1H ,5X,'ATTEMPT TO GO DOWNHILL IS UNSUCCESSFUL AFTER',I5,5X
     1,'ORTHOGONAL SEARCHES')
      GOTO 920
C#  730 FORMAT(1H ,'FINAL GRADIENT =',F15.7)
  740 FORMAT(1H ,3X,'ALF =',E12.4)
  750 FORMAT(1H ,3X,'NCOUNT =',I5)
  760 FORMAT(3X,'TIME LEFT:',F7.1,' CYCLE',I5,3X,'GNORM SQUARED IS'
     1,F13.5)
  770 FORMAT(4(5X,'X(',I2,') = ',E15.8))
  780 FORMAT(4(5X,'P(',I2,') = ',E15.8))
  790 FORMAT(5X,'R-MATRIX DIAGONAL ENTRIES ...')
  800 FORMAT(6E13.3)
  810 FORMAT('0TEST ON X SATISFIED, NUMBER OF FUNCTION CALLS = ',I5)
  820 FORMAT('0TEST ON SSQ SATISFIED, NUMBER OF FUNCTION CALLS = ',I5)
  830 FORMAT(' ///// NEXT CYCLE IS A SIDE-STEP ALONG THE ',I2,
     1  '-TH NORMAL TO P')
  840 FORMAT('0ALLOWED NUMBER OF FUNCTION CALLS EXCEEDED.'/
     1  ' NUMBER OF FUNCTION CALLS WAS ',I5)
  850 FORMAT('  L.-M. PARAMETER = ',E15.7,
     1  '   SUMSQUARES CHANGE = ',E15.7)
  860 FORMAT(1H )
  870 FORMAT(1H )
  880 FORMAT(1H ,3X,'I',7X,I2,9(10X,I2))
  890 FORMAT(1H ,1X,'X(I)',1X,F10.5,2X,9(F10.5,2X))
  900 FORMAT(1H ,1X,'G(I)',1X,F10.5,2X,9(F10.5,2X))
  910 FORMAT(1H ,1X,'P(I)',1X,F10.5,2X,9(F10.5,2X))
  920 LAST=1
      CALL COMPFG(X,.TRUE.,ESCF,.TRUE.,EFSLST,.TRUE.)
      RETURN
      END
      SUBROUTINE POWSAV(HESS, GRAD, XPARAM, PMAT, ILOOP, BMAT, IPOW)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
C
      DIMENSION HESS(MAXPAR,*),GRAD(*),BMAT(MAXPAR,*),IPOW(9),
     1 XPARAM(*), PMAT(*)
**********************************************************************
*
* POWSAV STORES AND RESTORES DATA USED IN THE SIGMA GEOMETRY
*        OPTIMISATION.
*
*  ON INPUT HESS   = HESSIAN MATRIX, PARTIAL OR WHOLE.
*           GRAD   = GRADIENTS.
*           XPARAM = CURRENT STATE OF PARAMETERS.
*           ILOOP  = INDEX OF HESSIAN, OR FLAG OF POINT REACHED SO-FAR.
*           BMAT   = "B" MATRIX!
*           IPOW   = INDICES AND FLAGS.
*           IPOW(9)= 0 FOR RESTORE, 1 FOR DUMP
*
**********************************************************************
      COMMON /GEOVAR/ XDUMMY(MAXPAR),NVAR,LOC(2,MAXPAR)                 IR0394
      COMMON /ELEMTS/ ELEMNT(107)
      COMMON /GEOSYM/ NDEP,LOCPAR(MAXPAR),IDEPFN(MAXPAR),LOCDEP(MAXPAR)
      COMMON /TITLES/ KOMENT,TITLE
      COMMON /GEOKST/ NATOMS,LABELS(NUMATM),
     1                NA(NUMATM),NB(NUMATM),NC(NUMATM)
      COMMON /GEOM  / GEO(3,NUMATM)
      COMMON /LOCVAR/ LOCVAR(2,MAXPAR)
      COMMON /KEYWRD/ KEYWRD
      COMMON /VALVAR/ VALVAR(MAXPAR),NUMVAR
      DIMENSION IEL1(3),QQ(3), COORD(3,NUMATM)
      CHARACTER ELEMNT*2, KEYWRD*80,KOMENT*80, TITLE*80
      COMMON /DENSTY/ P(MPACK), PA(MPACK), PB(MPACK)
      COMMON /ALPARM/ ALPARM(3,MAXPAR),X0, X1, X2, JLOOP
C Common MOLKST splitted in MOLKSI and MOLKSR    Ivan Rossi 0394   &8)
      COMMON /MOLKSI/ NUMAT,NAT(NUMATM),NFIRST(NUMATM),
     1                NMIDLE(NUMATM),NLAST(NUMATM), NORBS,
     2                NELECS,NALPHA,NBETA,NCLOSE,NOPEN
     3       /MOLKSR/ FRACT
C    changed common path for portability  (IR)
      COMMON /PATHI / LATOM,LPARAM
      COMMON /PATHR / REACT(200)
         SAVE                                                           GL0892
      OPEN(UNIT=9,FILE='FOR009',STATUS='UNKNOWN',FORM='UNFORMATTED')
      REWIND 9
      OPEN(UNIT=10,FILE='FOR010',STATUS='UNKNOWN',FORM='UNFORMATTED')
      REWIND 10
      IR=9
      IF(IPOW(9) .NE. 0) THEN
         IF(IPOW(9) .EQ. 1) THEN
            WRITE(6,'(//10X,''- - - - - - - TIME UP - - - - - - -'',//)'
     1)
            WRITE(6,'(//10X,'' - THE CALCULATION IS BEING DUMPED TO DISK
     1'',/10X,''   RESTART IT USING THE KEY-WORD "RESTART"'')')
            FUNCT1=SQRT(ddot(nvar,grad,1,grad,1))
            WRITE(6,'(//10X,''CURRENT VALUE OF GRADIENT NORM =''
     1  ,F12.6)')FUNCT1
            DO 10 I=1,NVAR
               K=LOC(1,I)
               L=LOC(2,I)
   10       GEO(L,K)=XPARAM(I)
            WRITE(6,'(/10X,''CURRENT VALUE OF GEOMETRY'',/)')
            DEGREE=57.29577951D0
            IF(NA(1) .EQ. 99) THEN
C
C  CONVERT FROM CARTESIAN COORDINATES TO INTERNAL
C
               DO 20 I=1,NATOMS
                  DO 20 J=1,3
   20          COORD(J,I)=GEO(J,I)
               CALL XYZINT(COORD,NUMAT,NA,NB,NC,1.D0,GEO)
            ENDIF
            GEO(2,1)=0.D0
            GEO(3,1)=0.D0
            GEO(1,1)=0.D0
            GEO(2,2)=0.D0
            GEO(3,2)=0.D0
            GEO(3,3)=0.D0
            IVAR=1
            NA(1)=0
            WRITE(6,'(A)')KEYWRD,KOMENT,TITLE
            DO 50 I=1,NATOMS
               DO 30 J=1,3
   30          IEL1(J)=0
   40          CONTINUE
               IF(LOC(1,IVAR).EQ.I) THEN
                  IEL1(LOC(2,IVAR))=1
                  IVAR=IVAR+1
                  GOTO 40
               ENDIF
               IF(I.LT.4) THEN
                  IEL1(3)=0
                  IF(I.LT.3) THEN
                     IEL1(2)=0
                     IF(I.LT.2) THEN
                        IEL1(1)=0
                     ENDIF
                  ENDIF
               ENDIF
               IF(I.EQ.LATOM)IEL1(LPARAM)=-1
               QQ(1)=GEO(1,I)
               QQ(2)=GEO(2,I)*DEGREE
               QQ(3)=GEO(3,I)*DEGREE
   50       WRITE(6,'(2X,A2,3(F12.6,I3),I4,2I3)')
     1    ELEMNT(LABELS(I)),(QQ(K),IEL1(K),K=1,3),NA(I),NB(I),NC(I)
            I=0
            X=0.D0
            WRITE(6,'(I4,3(F12.6,I3),I4,2I3)')
     1    I,X,I,X,I,X,I,I,I,I
            IF(NDEP.NE.0)THEN
               DO 60 I=1,NDEP
   60          WRITE(6,'(3(I4,'',''))')LOCPAR(I),IDEPFN(I),LOCDEP(I)
               WRITE(6,*)
            ENDIF
         ENDIF
         WRITE(IR)IPOW,ILOOP
         WRITE(IR)(XPARAM(I),I=1,NVAR)
         WRITE(IR)(  GRAD(I),I=1,NVAR)
         WRITE(IR)((HESS(J,I),J=1,NVAR),I=1,NVAR)
         WRITE(IR)((BMAT(J,I),J=1,NVAR),I=1,NVAR)
         LINEAR=(NVAR*(NVAR+1))/2
         WRITE(IR)(PMAT(I),I=1,LINEAR)
         LINEAR=(NORBS*(NORBS+1))/2
         WRITE(10)(PA(I),I=1,LINEAR)
         IF(NALPHA.NE.0)WRITE(10)(PB(I),I=1,LINEAR)
         IF(LATOM .NE. 0) THEN
            WRITE(IR)((ALPARM(J,I),J=1,3),I=1,NVAR)
            WRITE(IR)JLOOP,X0, X1, X2
         ENDIF
         CLOSE (9)
         CLOSE (10)
         RETURN
      ELSE
         WRITE(6,'(//10X,'' RESTORING DATA FROM DISK''/)')
         READ(IR)IPOW,ILOOP
         READ(IR)(XPARAM(I),I=1,NVAR)
         READ(IR)(  GRAD(I),I=1,NVAR)
         READ(IR)((HESS(J,I),J=1,NVAR),I=1,NVAR)
         READ(IR)((BMAT(J,I),J=1,NVAR),I=1,NVAR)
         FUNCT1=SQRT(ddot(nvar,grad,1,grad,1))
         WRITE(6,'(10X,''FUNCTION ='',F13.6//)')FUNCT1
         LINEAR=(NVAR*(NVAR+1))/2
         READ(IR)(PMAT(I),I=1,LINEAR)
         LINEAR=(NORBS*(NORBS+1))/2
         READ(10)(PA(I),I=1,LINEAR)
         IF(NALPHA.NE.0)READ(10)(PB(I),I=1,LINEAR)
         IF(LATOM.NE.0) THEN
            READ(IR)((ALPARM(J,I),J=1,3),I=1,NVAR)
            READ(IR)JLOOP,X0, X1, X2
            ILOOP=ILOOP+1
         ENDIF
         ILOOP=ILOOP+1
         RETURN
      ENDIF
      END
      SUBROUTINE DRC(STARTV, STARTK)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
C
      DIMENSION STARTV(*), STARTK(*)
************************************************************************
*                                                                      *
*    DRC IS DESIGNED TO FOLLOW A REACTION PATH FROM THE TRANSITION     *
*    STATE.  TWO MODES ARE SUPPORTED, FIRST: GAS PHASE:- AS THE SYSTEM *
*    MOVES FROM THE T/S THE MOMENTUM OF THE ATOMS IS STORED AND THE    *
*    POSITION OF THE ATOMS IS RELATED TO THE OLD POSITION BY (A) THE   *
*    CURRENT VELOCITY OF THE ATOM, AND (B) THE FORCES ACTING ON THAT   *
*    ATOM.  THE SECOND MODE IS CONDENSED PHASE, IN WHICH THE ATOMS MOVE*
*    IN RESPONSE TO THE FORCES ACTING ON THEM. I.E. INFINITELY DAMPED  *
*                                                                      *
************************************************************************
      COMMON /KEYWRD/ KEYWRD
      COMMON /DENSTY/ P(MPACK),PA(MPACK),PB(MPACK)
      COMMON /GRADNT/ GRAD(MAXPAR),GNORM
      COMMON /GEOSYM/ NDEP,LOCPAR(MAXPAR),IDEPFN(MAXPAR),LOCDEP(MAXPAR)
      COMMON /GEOM  / GEO(3,NUMATM)
      COMMON /ATMASS/ ATMASS(NUMATM)
      COMMON /GEOVAR/ XPARAM(MAXPAR), NVAR, LOC(2,MAXPAR)               IR0394
      COMMON /GEOKST/ NATOMS,LABELS(NUMATM),
     1                NA(NUMATM),NB(NUMATM),NC(NUMATM)
C Common MOLKST splitted in MOLKSI and MOLKSR    Ivan Rossi 0394   &8)
      COMMON /MOLKSI/ NUMAT,NAT(NUMATM),NFIRST(NUMATM),
     1                NMIDLE(NUMATM),NLAST(NUMATM), NORBS,
     2                NELECS,NALPHA,NBETA,NCLOSE,NOPEN
     3       /MOLKSR/ FRACT
      COMMON /DRCCOM/ MCOPRT(2,MAXPAR), NCOPRT, PRTMAX
      COMMON /IOCM/ IREAD
      CHARACTER KEYWRD*80
      CHARACTER SPACE*1, CHDOT*1, ZERO*1, NINE*1, CH*1
      DIMENSION VELREF(MAXPAR), VELO0(MAXPAR), VELO1(MAXPAR),
     1VELO2(MAXPAR), VELO3(MAXPAR), GERROR(MAXPAR),
     2COORD(3,NUMATM), GROLD2(MAXPAR),
     3GROLD(MAXPAR), PAROLD(MAXPAR), GEOREF(3,NUMATM),
     4 SQRTMS(MAXPAR)
      LOGICAL INT, ADDK, LETOT, LET, VELRED,PRTMAX, IRCDRC
         SAVE                                                           GL0892
      DATA VELO0/MAXPAR*0.D0/, INT/.TRUE./
      DATA SPACE,CHDOT,ZERO,NINE /' ','.','0','9'/
      DATA ADDK/.TRUE./
      CLOSE (IREAD)
C7/26/GL91 TNOW=SECNDS()
cmgc           TNOW=SECOND()
C7/26/GL91 OLDTIM=SECNDS()
cmgc           OLDTIM=SECOND()
      DELOLD=10.D0
      GTOT=0.D0
      OPEN(UNIT=7,STATUS='SCRATCH')
      IF(INDEX(KEYWRD,' PREC').NE.0)THEN
         ACCU=0.5D0
      ELSE
         ACCU=1.D0
      ENDIF
      LPOINT=0
      VELRED=(INDEX(KEYWRD,'VELOC').NE.0)
C
C     PRINT OUT INITIAL VELOCITIES
C
C#      WRITE(6,'(A)')' INITIAL VELOCITY IN DRC'
C#      WRITE(6,'(3F13.5)')(STARTV(I),I=1,NUMAT*3)
      LET=(INDEX(KEYWRD,' GEO-OK').NE.0)
      IF(INDEX(KEYWRD,' SYMME').NE.0)THEN
         WRITE(6,*)'  SYMMETRY SPECIFIED, BUT CANNOT BE USED IN DRC'
         NDEP=0
      ENDIF
C
C      CONVERT TO CARTESIAN COORDINATES, IF NOT ALREADY DONE.
C
      IF(INDEX(KEYWRD,' XYZ').EQ.0)THEN
         NA(1)=0
         CALL GMETRY(GEO,COORD)
         L=0
         DO 20 I=1,NUMAT
            LABELS(I)=NAT(I)
            SUM=SQRT(ATMASS(NAT(I)))
            DO 10 J=1,3
               L=L+1
               SQRTMS(L)=SUM
               GEO(J,I)=COORD(J,I)
   10       COORD(J,I)=0.D0
   20    CONTINUE
         NA(1)=99
      ENDIF
C
C  TRANSFER COORDINATES TO XPARAM AND LOC
C
      IF(INDEX(KEYWRD,' DRC').NE.0)THEN
         PRTMAX=(LOC(1,1).EQ.1)
         IF(PRTMAX)THEN
            J=1
         ELSE
            J=0
         ENDIF
         NVAR=NVAR-J
         DO 30 I=1,NVAR
            MCOPRT(1,I)=LOC(1,I+J)
   30    MCOPRT(2,I)=LOC(2,I+J)
         IF(LOC(1,1).EQ.0)NVAR=0
         NCOPRT=NVAR
      ELSE
         NCOPRT=0
      ENDIF
      L=0
      DO 40 I=1,NUMAT
         DO 40 J=1,3
            L=L+1
            LOC(1,L)=I
            LOC(2,L)=J
            GEOREF(J,I)=GEO(J,I)
   40 XPARAM(L)=GEO(J,I)
      NVAR=NUMAT*3
C
C DETERMINE DAMPING FACTOR
C
      IRCDRC=(INDEX(KEYWRD,'IRC=').NE.0)
      IF(INDEX(KEYWRD,'DRC=').NE.0) THEN
         HALF=READA(KEYWRD,INDEX(KEYWRD,'DRC='))
         WRITE(6,'(//10X,'' DAMPING FACTOR FOR KINETIC ENERGY ='',F12.6)
     1')HALF
      ELSEIF (INDEX(KEYWRD,'DRC').EQ.0) THEN
         HALF=0.D0
      ELSE
         HALF=1.D6
      ENDIF
      LETOT=(.NOT.IRCDRC.AND.HALF.LT.1.D0)
      HALF=SIGN(MAX(0.000001D0,ABS(HALF)),HALF)
C
C DETERMINE EXCESS KINETIC ENERGY
C
      IF(INDEX(KEYWRD,'KINE').NE.0) THEN
         ADDONK=READA(KEYWRD,INDEX(KEYWRD,'KINE'))
         WRITE(6,'(//10X,'' EXCESS KINETIC ENERGY ENTERED INTO SYSTEM ='
     1',F12.6)')ADDONK
      ELSE
         ADDONK=0.D0
      ENDIF
C
C   LOOP OVER TIME-INTERVALS OF DELTAT SECOND
C
      DELTAT=1.D-16
      QUADR=1.D0
      TOTIME=0.D0
      ONCE=0.D0
      ETOT=0.D0
      ESCF=0.D0
      CONST=1.D0
      I=INDEX(KEYWRD,' T=')
      IF(I.NE.0) THEN
         TIM=READA(KEYWRD,I)
         DO 50 J=I+3,80
            IF( KEYWRD(J+1:J+1).EQ.' ') THEN
               CH=KEYWRD(J:J)
               IF( CH .EQ. 'M') TIM=TIM*60
               IF( CH .EQ. 'H') TIM=TIM*3600
               IF( CH .EQ. 'D') TIM=TIM*86400
               GOTO 60
            ENDIF
   50    CONTINUE
C             4 SECONDS TO LOAD IN EXECUTABLE!
   60    TLEFT=TIM-4
      ELSE
         TLEFT=3596
      ENDIF
      IF( INDEX(KEYWRD,'REST').NE.0.AND.INDEX(KEYWRD,'IRC=').EQ.0)THEN
C
C  RESTART FROM A PREVIOUS RUN
C
         OPEN(UNIT=9,FILE='FOR009',STATUS='UNKNOWN',FORM='FORMATTED')
         REWIND 9
         OPEN(UNIT=10,FILE='FOR010',STATUS='UNKNOWN',FORM='UNFORMATTED')
         REWIND 10
         READ(9,'(A80)')ALPHA
         READ(9,'(3F19.13)')(XPARAM(I),I=1,NVAR)
         READ(9,'(A80)')ALPHA
         READ(9,'(3F19.3)')(VELO0(I),I=1,NVAR)
         READ(9,'(A80)')ALPHA
         READ(9,*)(GRAD(I),I=1,NVAR)
         READ(9,*)(GROLD(I),I=1,NVAR)
         READ(9,*)(GROLD2(I),I=1,NVAR)
         READ(9,*)ETOT,ESCF,EKIN,DELOLD,DELTAT,DLOLD2,ILOOP,
     1GNORM,LETOT,ELOST1,GTOT
         WRITE(6,'(//10X,''CALCULATION RESTARTED, CURRENT'',
     1'' KINETIC ENERGY='',F10.5,//)')EKIN
         GOTO 110
      ELSE
         ILOOP=1
         IF(INDEX(KEYWRD,'IRC=').NE.0.OR.VELRED)THEN
            IF(INDEX(KEYWRD,'IRC=').NE.0)THEN
               K=READA(KEYWRD,INDEX(KEYWRD,'IRC='))
            ELSE
               K=1
            ENDIF
            IF(K.LT.0)THEN
               K=-K
               ONE=-1.D0
            ELSE
               ONE=1.D0
            ENDIF
            KL=(K-1)*NVAR
            SUMM=0.D0
            VELO1(1)=0
            VELO1(2)=0
            VELO1(3)=0
            SUMMAS=0.D0
            I=0
            DO 70 II=1,NUMAT
               AMS=ATMASS(II)
               SUMMAS=SUMMAS+AMS
               DO 70 I1=1,3
                  I=I+1
                  VELO0(I)=STARTV(KL+I)*ONE
                  VELREF(I)=VELO0(I)
                  VELO1(I1)=VELO1(I1)+VELO0(I)*AMS
   70       CONTINUE
            DO 80 I=1,3
   80       VELO1(I)=-VELO1(I)/SUMMAS
            I=0
            DO 90 II=1,NUMAT
               AMS=ATMASS(II)
               DO 90 I1=1,3
                  I=I+1
                  IF(ADDONK.GT.1.D-5.OR..NOT.VELRED)VELO0(I)=VELO0(I)+VE
     1LO1(I1)
   90       SUMM=SUMM+VELO0(I)**2*AMS
            IF(ADDONK.LT.1.D-5.AND.VELRED)ADDONK=0.5D0*SUMM/4.184D10
            IF(ADDONK.LT.1.D-5.AND..NOT.VELRED)THEN
               IF(ABS(HALF).GT.1.D-3.AND.STARTK(K).GT.105.D0)THEN
                  WRITE(6,'(A,F10.3,A,/,A)')' BY DEFAULT, ONE QUANTUM OF
     1 ENERGY,'//' EQUIVALENT TO',STARTK(K),' CM(-1)',
     2' WILL BE USED TO START THE DRC'
C
C    2.8585086D-3 CONVERTS CM(-1) INTO KCAL/MOLE
C
                  ADDONK=STARTK(K)*2.8585086D-3
                  WRITE(6,'(A,F7.2,A)')' THIS REPRESENTS AN ENERGY OF',A
     1DDONK,' KCALS/MOLE'
               ELSEIF(ABS(HALF).GT.1.D-3)THEN
                  WRITE(6,'(A,F7.2,A)')' THE VIBRATIONAL FREQUENCY (',ST
     1ARTK(K),' IS TOO SMALL FOR ONE QUANTUM TO BE USED'
                  WRITE(6,'(A)')
     1' INSTEAD 0.3KCAL/MOLE WILL BE USED TO START THE IRC'
                  ADDONK=0.3D0
               ELSE
                  ADDONK=0.3D0
               ENDIF
            ENDIF
C
C   AT THIS POINT ADDONK IS IN KCAL/MOLE
C   NORMALIZE SO THAT TOTAL K.E. = ONE QUANTUM (DEFAULT) (DRC ONLY)
C                              OR 0.3KCAL/MOLE (IRC ONLY)
C                              OR ADDONK IF KINETIC=NN SUPPLIED
C
            SUMM=SQRT(ADDONK/(0.5D0*SUMM/4.184D10))
            ADDK=.FALSE.
            IF(SUMM.GT.1.D-10)THEN
               DO  100 I=1,NVAR
  100          VELO0(I)=VELO0(I)*SUMM
            ENDIF
         ENDIF
      ENDIF
  110 CONTINUE
      IUPPER=ILOOP+4999
      ILP=ILOOP
      ONE=0.D0
      IF(INDEX(KEYWRD,'REST').NE.0.AND.INDEX(KEYWRD,'IRC=').EQ.0)
     1ONE=1.D0
      DO 190 ILOOP=ILP,IUPPER
C
C  MOVEMENT OF ATOMS WILL BE PROPORTIONAL TO THE AVERAGE VELOCITIES
C  OF THE ATOMS BEFORE AND AFTER TIME INTERVAL
C
C
C  RAPID CHANGE IN GRADIENT IMPLIES SMALL STEP SIZE FOR DELTAT
C
C   KINETIC ENERGY = 1/2 * M * V * V
C                  = 0.5 / (4.184D10) * M * V * V
C   NEW VELOCITY = OLD VELOCITY + GRADIENT * TIME / MASS
C                = KCAL/ANGSTROM*SECOND/(ATOMIC WEIGHT)
C                =4.184*10**10(ERGS)*10**8(PER CM)*DELTAT(SECONDS)
C   NEW POSITION = OLD POSITION - AVERAGE VELOCITY * TIME INTERVAL
C
C
C   ESTABLISH REFERENCE TOTAL ENERGY
C
         ERROR=(ETOT-(EKIN+ESCF))
         IF(ILOOP.GT.2)THEN
            QUADR = 1.D0+ERROR/(EKIN*CONST+0.001D0)*0.5D0
            QUADR = MIN(1.3D0,MAX(0.8D0,QUADR))
         ELSE
            QUADR=1.D0
         ENDIF
         IF((LET.OR.EKIN.GT.0.2).AND.ADDK)THEN
C
C   DUMP IN EXCESS KINETIC ENERGY
C
            ETOT=ETOT+ADDONK
            ADDK=.FALSE.
            ADDONK=0.D0
         ENDIF
         EKOLD=EKIN
C
C  CALCULATE THE DURATION OF THE NEXT STEP.
C  STEP SIZE IS THAT REQUIRED TO PRODUCE A CONSTANT CHANGE IN GEOMETRY
C
C
C  IF DAMPING IS USED, CALCULATE THE NEW TOTAL ENERGY AND
C  THE RATIO FOR REDUCING THE KINETIC ENERGY
C
         CONST=MAX(1.D-36,0.5D0**(DELTAT*1.D15/HALF))
         CONST=SQRT(CONST)
         VELVEC=0.D0
         EKIN=0.D0
         DELTA1=DELOLD+DLOLD2
         ELOST=0.D0
         DO 120 I=1,NVAR
C
C   CALCULATE COMPONENTS OF VELOCITY AS
C   V = V(0) + V'*T + V"*T*T
C   WE NEED ALL THREE TERMS, V(0), V' AND V"
C
            VELO1(I) = 1.D0/ATMASS(LOC(1,I))*GRAD(I)
            IF(ILOOP.GT.3) THEN
               VELO3(I) = 2.D0/ATMASS(LOC(1,I))*
     1(DELTA1*(GROLD(I)-GRAD(I))-DELOLD*(GROLD2(I)-GRAD(I)))/
     2(DELTA1*(DELOLD**2*1.D30)-DELOLD*(DELTA1**2*1.D30))
               VELO2(I)=1.D0/ATMASS(LOC(1,I))*
     1(GRAD(I)-GROLD(I)-0.5D0*VELO3(I)*(1.D30*DELOLD**2))/(DELOLD*1.D15)
            ELSE
               VELO2(I) = 1.D0/ATMASS(LOC(1,I))*
     1                 (GRAD(I)-GROLD(I))/(1.D15*DELOLD)
               VELO3(I)=0.D0
            ENDIF
C
C  MOVE ATOMS THROUGH DISTANCE EQUAL TO VELOCITY * DELTA-TIME, NOTE
C  VELOCITY CHANGES FROM START TO FINISH, THEREFORE AVERAGE.
C
            PAROLD(I)=XPARAM(I)
            XPARAM(I)=XPARAM(I)
     1             -1.D8*(DELTAT*VELO0(I)*ONE
     2             +0.5D0*DELTAT**2*VELO1(I)
     3             +0.16666D0*(DELTAT**2*1.D15)*DELTAT*VELO2(I)
     4             +0.0416666D0*DELTAT**2*(1.D30*DELTAT**2)*VELO3(I))
C
C   CORRECT ERRORS DUE TO CUBIC COMPONENTS IN ENERGY GRADIENT,
C   ALSO TO ADD ON EXCESS ENERGY, IF NECESSARY.
C
            VELVEC=VELVEC+VELO0(I)**2
C
C   MODIFY VELOCITY IN LIGHT OF CURRENT ENERGY GRADIENTS.
C
C   VELOCITY = OLD VELOCITY + (DELTA-T / ATOMIC MASS) * CURRENT GRADIENT
C                           + 1/2 *(DELTA-T * DELTA-T /ATOMIC MASS) *
C                             (SLOPE OF GRADIENT)
C              SLOPE OF GRADIENT = (GRAD(I)-GROLD(I))/DELOLD
C
C
C   THIS EXPRESSION IS ACCURATE TO SECOND ORDER IN TIME.
C
            VELO0(I) = VELO0(I) + DELTAT*VELO1(I) + 0.5D0*DELTAT**2*VELO
     12(I)*1.D15           + 0.166666D0*DELTAT*(1.D30*DELTAT**2)*VELO3(
     2I)
            IF(LET.OR.GNORM.GT.3.D0)THEN
               LET=.TRUE.
               ELOST=ELOST+VELO0(I)**2*ATMASS(LOC(1,I))*(1-CONST**2)
               VELO0(I)=VELO0(I)*CONST*QUADR
            ENDIF
C
C  CALCULATE KINETIC ENERGY (IN 2*ERGS AT THIS POINT)
C
            EKIN=EKIN+VELO0(I)**2*ATMASS(LOC(1,I))
  120    CONTINUE
         ONE=1.D0
         IF(LET.OR.GNORM.GT.3.D0)THEN
            IF(.NOT.LETOT)THEN
               ETOT=ESCF+ADDONK
               ADDONK=0.D0
               ELOST1=0.D0
               ELOST=0.D0
            ENDIF
            LETOT=.TRUE.
         ENDIF
C
C  CONVERT ENERGY INTO KCAL/MOLE
C
         EKIN=0.5*EKIN/4.184D10
         IF(LETOT.AND.ABS(HALF).GT.0.00001D0)
     1ETOT=ETOT-EKIN/CONST**2+EKIN
         ELOST1=ELOST1+0.5D0*ELOST/4.184D10
C
C STORE OLD GRADIENTS FOR DELTA - VELOCITY CALCULATION
C
         DO 130 I=1,NVAR
            GROLD2(I)=GROLD(I)
            GROLD(I)=GRAD(I)
  130    GRAD(I)=0.D0
C
C   CALCULATE ENERGY AND GRADIENTS
C
         SCFOLD=ESCF
         CALL COMPFG(XPARAM,.TRUE.,ESCF,.TRUE.,GRAD,.TRUE.)
         IF(ILOOP.GT.2)THEN
            GNORM=0.D0
            DO 150 I=1,NVAR,3
               SUM=SQRT(ddot(3,GRAD(I),1,GRAD(I),1)/
     1(ddot(3,VELO0(I),1,VELO0(I),1)+1.D-20))
               DO 140 J=I,I+2
  140          GERROR(J)=GERROR(J)+GRAD(J)+VELO0(J)*SUM
  150       CONTINUE
            GNORM=SQRT(ddot(nvar,GERROR,1,GERROR,1))
            GTOT=GNORM
         ENDIF
         GNORM=SQRT(ddot(nvar,grad,1,grad,1))
C
C   CONVERT GRADIENTS INTO ERGS/CM
C
         DO 160 I=1,NVAR
  160    GRAD(I)=GRAD(I)*4.184D18
C
C   SPECIAL TREATMENT FOR FIRST POINT - SET "OLD" GRADIENTS EQUAL TO
C   CURRENT GRADIENTS.
C
         IF(ILOOP.EQ.1) THEN
            DO 170 I=1,NVAR
  170       GROLD(I)=GRAD(I)
         ENDIF
         DLOLD2=DELOLD
         DELOLD=DELTAT
         SUM=0.D0
         DO 180 I=1,NVAR
  180    SUM=SUM + ((GRAD(I)-GROLD(I))/4.184D18)**2
         IF(ABS(HALF).LT.0.001D0)THEN
            DELTAT= DELTAT*
     1MIN(2.D0, (5.D-5*ACCU/(ABS(ESCF+ELOST1-ETOLD)+1.D-20)))**0.25D0
            ETOLD=ESCF+ELOST1
            IF(ILOOP.GT.5.AND.SCFOLD-ESCF.LT.-1.D-3 .OR.
     1      ILOOP.GT.30.AND.SCFOLD-ESCF.LT.0.D0)  THEN
               WRITE(6,'(//,'' IRC CALCULATION COMPLETE '')')
               STOP
            ENDIF
         ELSE
            DELTAT= DELTAT*MIN(1.05D0, 10.D0*ACCU/(SUM+1.D-4))
************************************************************************
*
*         TESTING CODE - REMOVE BEFORE FINAL VERSION ASSEMBLED
C#          (ILOOP/400)*400.EQ.ILOOP)DELTAT=-DELTAT
*
************************************************************************
         ENDIF
         DELTAT=MAX(1.D-16,DELTAT)
         IF(ABS(HALF).LT.0.00001D0)THEN
            CALL PRTDRC(ESCF,DELTAT,XPARAM,GEOREF,
     1ELOST1,GTOT,ETOT,VELO0,NVAR)
         ELSE
            CALL PRTDRC(ESCF,DELTAT,XPARAM,GEOREF,
     1EKIN,ELOST,ETOT,VELO0,NVAR)
         ENDIF
cmgc         TNOW=SECOND()
         TCYCLE=TNOW-OLDTIM
         OLDTIM=TNOW
         TLEFT=TLEFT-TCYCLE
         IF (ILOOP.EQ.IUPPER.OR.TLEFT.LT.3*TCYCLE) THEN
            IF( INDEX(KEYWRD,'REST')+INDEX(KEYWRD,'ISOT').NE.0) CLOSE (9
     1)
            OPEN(UNIT=9,FILE='FOR009',STATUS='unknown',FORM='FORMATTED')
            REWIND 9
            OPEN(UNIT=10,FILE='FOR010',STATUS='UNKNOWN',FORM='UNFORMATTE
     1D')
            REWIND 10
            WRITE(9,'(A)')' CARTESIAN GEOMETRY PARAMETERS IN ANGSTROMS'
            WRITE(9,'(3F19.13)')(XPARAM(I),I=1,NVAR)
            WRITE(9,'(A)')' VELOCITY FOR EACH CARTESIAN COORDINATE, IN C
     1M/SEC'
            WRITE(9,'(3F19.3)')(VELO0(I),I=1,NVAR)
            WRITE(9,'(A)')' FIRST, SECOND, AND THIRD-ORDER GRADIENTS, ET
     1C'
            WRITE(9,*)(GRAD(I),I=1,NVAR)
            WRITE(9,*)(GROLD(I),I=1,NVAR)
            WRITE(9,*)(GROLD2(I),I=1,NVAR)
            I=ILOOP+1
            WRITE(9,*)ETOT,ESCF,EKIN,DELOLD,DELTAT,DLOLD2,I,
     1GNORM,LETOT,ELOST1,GTOT
            ESCF=-1.D9
            CALL PRTDRC(ESCF,DELTAT,XPARAM,GEOREF,
     1EKIN,ELOST,ETOT,VELO0,NVAR)
            LINEAR=(NORBS*(NORBS+1))/2
            WRITE(10)(PA(I),I=1,LINEAR)
            IF(NALPHA.NE.0)WRITE(10)(PB(I),I=1,LINEAR)
            WRITE(6,'(//10X,'' RUNNING OUT OF TIME, RESTART FILE WRITTEN
     1'')')
            STOP
         ENDIF
  190 CONTINUE
      END
      SUBROUTINE LOCMIN(M,X,N,P,SSQ,ALF,EFS,ITRAP,ESCF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
C
      COMMON /NLLSQI/ NCOUNT
      COMMON /KEYWRD/ CONTRL
      COMMON /NUMCAL/ NUMCAL
      DIMENSION X(*), P(*), EFS(*)
      DIMENSION CONST(MAXPAR), XSTOR(MAXPAR), GSTOR(MAXPAR)
      DIMENSION PHI(3),VT(3)
      INTEGER LEFT,RIGHT,CENTER
      CHARACTER*80 KEYWRD, CONTRL
      LOGICAL DEBUG, LOWER
         SAVE                                                           GL0892
      DATA ICALCN /0/
      DATA CONST/MAXPAR*1.D0/
************************************************************************
*
*    LOCMIN IS CALLED BY NLLSQ ONLY. IT IS A LINE-SEARCH PROCEDURE FOR
*    LOCATING A MINIMUM IN THE FUNCTION SPACE OF COMPFG.  SEE NLLSQ
*    FOR MORE DETAILS
*
************************************************************************
      IF (ICALCN .NE. NUMCAL) THEN
         ICALCN = NUMCAL
         XMAXM=1.D9
         SCALE=1.D0
         KEYWRD=CONTRL
C
C THE ABOVE LINE IS TO TRY TO PREVENT OVERFLOW IN NLLSQ
C
         EPS=1.D-5
         DEBUG=(INDEX(KEYWRD,'LINMIN') .NE. 0)
         TEE=1.D-2
         YMAXST=0.005D0
         XCRIT=0.0002D0
         MXCNT2=30
         IPRINT=0
         IF(DEBUG)IPRINT=-1
      ENDIF
      XMAXM=1.D-11
      DO 10 I=1,N
   10 XMAXM=MAX(XMAXM,ABS(P(I)))
      XMINM=XMAXM*SCALE
      XMAXM=YMAXST/XMAXM/SCALE
      FIN = SSQ
      LOWER = .FALSE.
      T=ALF
      PHI(1) = SSQ
      VT(1) = 0.0D0
      VT(2) = T/4.0D0
      IF(VT(2).GT.XMAXM) VT(2)=XMAXM
      T = VT(2)
      DO 20 I=1,N
   20 X(I) = X(I)+T*P(I)*CONST(I)*SCALE
      CALL COMPFG(X,.TRUE.,ESCF,.TRUE.,EFS,.TRUE.)
      phi(2) = ddot(n,efs,1,efs,1)
      sqstor = phi(2)
      estor = energy
      alfs = t
      do 25 iexch = 1,n
      xstor(iexch) = x(iexch)
25    continue
      DO 30 I=1,M
   30 GSTOR(I)=EFS(I)
      IF (PHI(1) .LE. PHI(2)) THEN
         VT(3) = -VT(2)
         LEFT = 3
         CENTER = 1
         RIGHT = 2
      ELSE
         VT(3)=2.0D0*VT(2)
         LEFT = 1
         CENTER = 2
         RIGHT = 3
      ENDIF
      TLAST = VT(3)
      T = TLAST-T
      DO 40 I=1,N
   40 X(I) = X(I)+T*P(I)*CONST(I)*SCALE
      FLAST=PHI(2)
      CALL COMPFG(X,.TRUE.,ESCF,.TRUE.,EFS,.TRUE.)
      f = ddot(n,efs,1,efs,1)
      if(f .lt. sqstor) then
        sqstor = f
        estor = energy
        alfs = t
        do 45 iexch = 1,n
        xstor(iexch) = x(iexch)
45      continue
      endif
      DO 50 I=1,M
   50 GSTOR(I)=EFS(I)
      IF(F.LT.FIN) LOWER = .TRUE.
      NCOUNT = NCOUNT+2
      PHI(3) = F
      IF (IPRINT) 60,70,70
   60 WRITE (6,310) VT(1),PHI(1),VT(2),PHI(2),VT(3),PHI(3)
   70 MXCT=MXCNT2
      DO 250 ICTR=3,MXCT
         XMAXM=XMAXM*3.D0
         ALPHA = VT(2) - VT(3)
         BETA = VT(3) - VT(1)
         GAMMA = VT(1)-VT(2)
         IF(ALPHA.EQ.0.D0)ALPHA=1.D-20
         IF(BETA.EQ.0.D0)BETA=1.D-20
         IF(GAMMA.EQ.0.D0)GAMMA=1.D-20
         ABG =-(PHI(1)*ALPHA+PHI(2)*BETA+PHI(3)*GAMMA)/ALPHA
         ABG=ABG/BETA
         ABG=ABG/GAMMA
         ALPHA=ABG
         BETA = ((PHI(1)-PHI(2))/GAMMA)-ALPHA*(VT(1)+VT(2))
         IF (ALPHA)  80,80,110
   80    IF (PHI(RIGHT) .GT. PHI(LEFT))  GO TO 90
         T = 3.0D0*VT(RIGHT)-2.0D0*VT(CENTER)
         GO TO 100
   90    T = 3.0D0*VT(LEFT)-2.0D0*VT(CENTER)
  100    S=T-TLAST
         T=S+TLAST
         GO TO 150
  110    T = -BETA/(2.0D0*ALPHA)
         S=T-TLAST
         IF (S) 120,260,130
  120    AMDIS=VT(LEFT)-TLAST-XMAXM
         GO TO 140
  130    AMDIS=VT(RIGHT)-TLAST+XMAXM
  140    IF(ABS(S).GT.ABS(AMDIS)) S=AMDIS
         T=S+TLAST
  150    CONTINUE
         IF(ICTR.GT.3.AND.ABS(S*XMINM).LT.XCRIT) THEN
            IF( DEBUG )
     1    WRITE(6,'('' EXIT DUE TO SMALL PROJECTED STEP'')')
            GO TO 260
         ENDIF
         T=S+TLAST
         DO 160 I=1,N
  160    X(I) = X(I)+S*P(I)*CONST(I)*SCALE
         FLAST=F
         CALL COMPFG(X,.TRUE.,ESCF,.TRUE.,EFS,.TRUE.)
      f = ddot(n,efs,1,efs,1)
      if(f .lt. sqstor) then
        sqstor = f
        estor = energy
        alfs = t
        do 165 iexch = 1,n
        xstor(iexch) = x(iexch)
165     continue
      endif
         DO 170 I=1,M
  170    GSTOR(I)=EFS(I)
         IF(F.LT.FIN) LOWER = .TRUE.
         NCOUNT = NCOUNT+1
         IF (IPRINT) 180,190,190
  180    WRITE (6,320) VT(LEFT),PHI(LEFT),VT(CENTER),PHI(CENTER),
     1  VT(RIGHT),PHI(RIGHT),T,F
  190    CONTINUE
C
C    TEST FOR EXCITED STATES AND POTHOLES
C
         ITRAP=0
         IF(ABS(VT(CENTER)).GT.1.D-10) GOTO 200
         IF(ABS(T)/(ABS(VT(LEFT))+1.D-15).GT.0.3333) GOTO 200
         IF(2.5D0*F-PHI(RIGHT)-PHI(LEFT).LT.0.5D0*PHI(CENTER)) GOTO 200
C
C   WE ARE STUCK ON A FALSE MINIMUM
C
         ITRAP=1
         GOTO 260
  200    CONTINUE
*
* NOW FOR THE MAIN STOPPING TESTS.  LOCMIN WILL STOP IF:-
*     THE ERROR FUNCTION HAS BEEN REDUCED, AND
*     THE RATE OF DROP OF THE ERROR FUNCTION IS LESS THAN 0.5% PER STEP
*     AND
*     (A) THE RATIO OF THE PROPOSED STEP TO THE TOTAL STEP IS LESS THAN
*         EPS,   OR
*     (B) THE LAST DROP IN ERROR FUNCTION WAS LESS THAN 5%OFTHETOTALDROP
*         DURING THIS CALL TO LOCMIN.
*
         IF(DEBUG)WRITE(6,'('' F/FLAST'',F13.6)')F/FLAST
         IF( LOWER  .AND. F/FLAST .GT. 0.995D0) THEN
            IF((ABS(T-TLAST).LE.EPS*ABS(T+TLAST)+TEE)) THEN
               IF( DEBUG )
     1       WRITE(6,'('' EXIT AS STEP IS ABSOLUTELY SMALL '')')
               GO TO 260
            ENDIF
            SUM=MIN(ABS(F-PHI(1)),ABS(F-PHI(2)),ABS(F-PHI(3)))
            SUM2=(FIN-SQSTOR)*0.05D0
            IF(SUM .LT. SUM2) THEN
               IF( DEBUG )
     1        WRITE(6,'('' EXIT DUE TO HAVING REACHED BOTTOM'')')
               GOTO 260
            ENDIF
         ENDIF
         TLAST = T
         IF ((T .GT. VT(RIGHT)) .OR. (T .GT. VT(CENTER) .AND. F .LT.
     1  PHI(CENTER)) .OR. (T .GT. VT(LEFT) .AND. T .LT. VT(CENTER) .AND.
     2  F .GT. PHI(CENTER)))  GO TO 210
         VT(RIGHT) = T
         PHI(RIGHT) = F
         GO TO 220
  210    VT(LEFT) = T
         PHI(LEFT) = F
  220    IF (VT(CENTER) .LT. VT(RIGHT))  GO TO 230
         I = CENTER
         CENTER = RIGHT
         RIGHT = I
  230    IF (VT(LEFT) .LT. VT(CENTER))  GO TO 240
         I = LEFT
         LEFT = CENTER
         CENTER = I
  240    IF (VT(CENTER) .LT. VT(RIGHT))  GO TO 250
         I = CENTER
         CENTER = RIGHT
         RIGHT = I
  250 CONTINUE
  260 CONTINUE
      f = sqstor
      energy = estor
      t = alfs
      do 265 iexch = 1,n
      x(iexch) = xstor(iexch)
265   continue
      DO 270 I=1,M
  270 EFS(I)=GSTOR(I)
      SSQ=(F)
      ALF=T
      IF (T) 280,300,300
  280 T = -T
      DO 290 I=1,N
  290 P(I) = -P(I)
  300 CONTINUE
      ALF=T
      RETURN
  310 FORMAT(' ---LOCMIN'/5X,'LEFT   ...',2F19.6/5X,'CENTER ...',
     1  2F19.6/5X,'RIGHT  ...',2F19.6/' ')
  320 FORMAT(5X,'LEFT   ...',2F19.6/5X,'CENTER ...',2F19.6/5X,
     1  'RIGHT  ...',2F19.6/5X,'NEW    ...',2F19.6/' ')
      END
C
      SUBROUTINE PRTDRC(ESCF,DELTT,XPARAM,REF,EKIN,GTOT,ETOT,VELO0,NVAR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
C
      DIMENSION XPARAM(*), VELO0(*), REF(*)
*********************************************************************
*
*    PRTDRC PREPARES TO PRINT THE GEOMETRY ETC. FOR POINTS IN A DRC
*    OR IRC
*    CALCULATION.
*    ON INPUT  ESCF   = HEAT OF FORMATION FOR THE CURRENT POINT
*              DELTT  = CHANGE IN TIME, PREVIOUS TO CURRENT POINT
*              XPARAM = CURRENT CARTESIAN GEOMETRY
*              EKIN   = CURRENT KINETIC ENERGY
*              GTOT   = TOTAL GRADIENT NORM IN IRC CALC'N.
*              VELO0  = CURRENT VELOCITY
*              NVAR   = NUMBER OF VARIABLES = 3 * NUMBER OF ATOMS.
*
********************************************************************
      COMMON /KEYWRD/ KEYWRD
C Common MOLKST splitted in MOLKSI and MOLKSR    Ivan Rossi 0394   &8)
      COMMON /MOLKSI/ NUMAT,NAT(NUMATM),NFIRST(NUMATM),
     1                NMIDLE(NUMATM),NLAST(NUMATM), NORBS,
     2                NELECS,NALPHA,NBETA,NCLOSE,NOPEN
      COMMON /GEOKST/ NATOMS,LABELS(NUMATM),
     1                NA(NUMATM),NB(NUMATM),NC(NUMATM)
      COMMON /DRCCOM/  MCOPRT(2,MAXPAR), NCOPRT, PARMAX
      COMMON /CORE  / CORE(107)
      COMMON /ATMASS/ ATMASS(NUMATM)
      COMMON /DENSTY/ P(MPACK),PA(MPACK),PB(MPACK)
      COMMON /FMATRX/ ALLXYZ(3,MAXPAR),ALLVEL(3,MAXPAR),PARREF(MAXPAR),
     1XYZ3(3,MAXPAR),VEL3(3,MAXPAR), ALLGEO(3,MAXPAR), GEO3(3,MAXPAR),
     2 DUMMY(MAXHES-19*MAXPAR)
      COMMON /NUMCAL/ NUMCAL
      DIMENSION ESCF3(3),EKIN3(3), GTOT3(3), CHARGE(NUMATM), XOLD3(3),
     1GEO(3*NUMATM), VREF(MAXPAR), VREF0(MAXPAR), TSTEPS(100), ETOT3(3),
     2XTOT3(3)
      LOGICAL TURN, PARMAX, LDRC, GOTURN
      CHARACTER*80 KEYWRD, TEXT1*3, TEXT2*2,  COTYPE(3)*2
         SAVE                                                           GL0892
      DATA REFSCF/0.D0/
      DATA COTYPE/'BL','BA','DI'/
      DATA ICALCN /0/
C*TNT      IF (FIRST) THEN
      IF (ICALCN .NE. NUMCAL) THEN
         SQRT2=SQRT(2.D0)
         DO 10 I=1,NVAR
   10    PARREF(I)=XPARAM(I)
         ETOT=ESCF+EKIN
         TLAST=0.D0
         GOTURN=.FALSE.
         SUM=0.D0
         DO 20 I=1,NVAR
            SUM=SUM+VELO0(I)**2
            VREF0(I)=VELO0(I)
   20    VREF(I)=VELO0(I)
         IONE=1
         LDRC=(SUM.GT.1.D0)
C*TNT         FIRST=.FALSE.
         ICALCN = NUMCAL
         ILOOP=1
         OLDT=-100.D0
         TOLD1=0.0D0
C
C       DETERMINE TYPE OF PRINT: TIME, ENERGY OR GEOMETRY PRIORITY
C       OR PRINT ALL POINTS
C
         STEPT=0.D0
         STEPH=0.D0
         STEPX=0.D0
         IF(INDEX(KEYWRD,' T-PRIO').NE.0)THEN
            IF(INDEX(KEYWRD,' T-PRIORITY=').NE.0)THEN
               STEPT=READA(KEYWRD,INDEX(KEYWRD,'T-PRIO')+5)
            ELSE
               STEPT=0.1D0
            ENDIF
            TREF=-1.D-6
            WRITE(6,'(/,'' TIME PRIORITY, INTERVAL ='',F4.1,
     1'' FEMTOSECONDS'',/)')STEPT
         ELSEIF(INDEX(KEYWRD,' H-PRIO').NE.0)THEN
            IF(INDEX(KEYWRD,' H-PRIORITY=').NE.0)THEN
               STEPH=READA(KEYWRD,INDEX(KEYWRD,'H-PRIO')+5)
            ELSE
               STEPH=0.1D0
            ENDIF
            WRITE(6,'(/,'' KINETIC ENERGY PRIORITY, STEP ='',F5.2,
     1'' KCAL/MOLE'',/)')STEPH
         ELSEIF(INDEX(KEYWRD,' X-PRIO').NE.0)THEN
            IF(INDEX(KEYWRD,' X-PRIORITY=').NE.0)THEN
               STEPX=READA(KEYWRD,INDEX(KEYWRD,'X-PRIO')+5)
            ELSE
               STEPX=0.05D0
            ENDIF
            WRITE(6,'(/,'' GEOMETRY PRIORITY, STEP ='',F5.2,
     1'' ANGSTROMS'',/)')STEPX
         ENDIF
         IF(INDEX(KEYWRD,' REST').NE.0.AND.INDEX(KEYWRD,'IRC=').EQ.0) TH
     1EN
            READ(9,*)(PARREF(I),I=1,NVAR)
            READ(9,*)(VREF0(I),I=1,NVAR)
            READ(9,*)(VREF(I),I=1,NVAR)
            READ(9,*)(ALLGEO(3,I),I=1,NVAR)
            READ(9,*)(ALLGEO(2,I),I=1,NVAR)
            READ(9,*)(ALLGEO(1,I),I=1,NVAR)
            READ(9,*)(ALLVEL(3,I),I=1,NVAR)
            READ(9,*)(ALLVEL(2,I),I=1,NVAR)
            READ(9,*)(ALLVEL(1,I),I=1,NVAR)
            READ(9,*)(ALLXYZ(3,I),I=1,NVAR)
            READ(9,*)(ALLXYZ(2,I),I=1,NVAR)
            READ(9,*)(ALLXYZ(1,I),I=1,NVAR)
            READ(9,*)ILOOP,LDRC,IONE,ETOT1,ETOT0,ESCF1,ESCF0,EKIN1,EKIN0
     1,TOLD2,TOLD1,GTOT1,GTOT0,XOLD2,XOLD1,XOLD0,TOTIME,JLOOP,ETOT,REFX
         ENDIF
      ENDIF
      IF(ESCF.LT.-1.D8) THEN
         WRITE(9,*)(PARREF(I),I=1,NVAR)
         WRITE(9,*)(VREF0(I),I=1,NVAR)
         WRITE(9,*)(VREF(I),I=1,NVAR)
         WRITE(9,*)(ALLGEO(3,I),I=1,NVAR)
         WRITE(9,*)(ALLGEO(2,I),I=1,NVAR)
         WRITE(9,*)(ALLGEO(1,I),I=1,NVAR)
         WRITE(9,*)(ALLVEL(3,I),I=1,NVAR)
         WRITE(9,*)(ALLVEL(2,I),I=1,NVAR)
         WRITE(9,*)(ALLVEL(1,I),I=1,NVAR)
         WRITE(9,*)(ALLXYZ(3,I),I=1,NVAR)
         WRITE(9,*)(ALLXYZ(2,I),I=1,NVAR)
         WRITE(9,*)(ALLXYZ(1,I),I=1,NVAR)
         WRITE(9,*)ILOOP,LDRC,IONE,ETOT1,ETOT0,ESCF1,ESCF0,EKIN1,EKIN0,
     1TOLD2,TOLD1,GTOT1,GTOT0,XOLD2,XOLD1,XOLD0,TOTIME,JLOOP,ETOT,REFX
         RETURN
      ENDIF
      CALL CHRGE(P,CHARGE)
      DO 30 I=1,NUMAT
         L=NAT(I)
   30 CHARGE(I)=CORE(L) - CHARGE(I)
      DELTAT=DELTT*1.D15
      NA(2)=-1
      CALL XYZINT(XPARAM,NUMAT,NA,NB,NC,57.29577951D0,GEO)
      NA(1)=99
      IF(ILOOP.EQ.1)THEN
         ETOT1=ETOT0
         ETOT0=ETOT
         ESCF1=ESCF
         ESCF0=ESCF
         EKIN1=EKIN
         EKIN0=EKIN
         DO 40 J=1,3
            DO 40 I=1,NVAR
               ALLGEO(J,I)=GEO(I)
               ALLXYZ(J,I)=XPARAM(I)
   40    ALLVEL(J,I)=VELO0(I)
      ELSE
         DO 50 I=1,NVAR
            ALLGEO(3,I)=ALLGEO(2,I)
            ALLGEO(2,I)=ALLGEO(1,I)
            ALLGEO(1,I)=GEO(I)
            ALLXYZ(3,I)=ALLXYZ(2,I)
            ALLXYZ(2,I)=ALLXYZ(1,I)
            ALLXYZ(1,I)=XPARAM(I)
            ALLVEL(3,I)=ALLVEL(2,I)
            ALLVEL(2,I)=ALLVEL(1,I)
   50    ALLVEL(1,I)=VELO0(I)
      ENDIF
C
C  FORM QUADRATIC EXPRESSION FOR POSITION AND VELOCITY W.R.T. TIME.
C
      T1=MAX(TOLD2,0.02D0)
      T2=MAX(TOLD1,0.02D0)+T1
      DO 60 I=1,NVAR
      geo3(3,i) = (t2*(allgeo(2,i) - allgeo(3,i)) -
     &             t1*(allgeo(1,i) - allgeo(3,i)))/
     &             (t2*t1**2 - t1*t2**2)
      geo3(2,i) = (allgeo(2,i) - allgeo(3,i) - geo3(3,i)*t1**2)/t1
      geo3(1,i) = allgeo(3,i)
      xyz3(3,i) = (t2*(allxyz(2,i) - allxyz(3,i)) -
     &             t1*(allxyz(1,i) - allxyz(3,i)))/
     &             (t2*t1**2 - t1*t2**2)
      xyz3(2,i) = (allxyz(2,i) - allxyz(3,i) - xyz3(3,i)*t1**2)/t1
      xyz3(1,i) = allxyz(3,i)
      vel3(3,i) = (t2*(allvel(2,i) - allvel(3,i)) -
     &             t1*(allvel(1,i) - allvel(3,i)))/
     &             (t2*t1**2 - t1*t2**2)
      vel3(2,i) = (allvel(2,i) - allvel(3,i) - vel3(3,i)*t1**2)/t1
      vel3(1,i) = allvel(3,i)
   60 CONTINUE
      ETOT2=ETOT1
      ETOT1=ETOT0
      ETOT0=ETOT
      CALL QUADR(ETOT2,ETOT1,ETOT0,T1,T2,ETOT3(1),ETOT3(2),
     1ETOT3(3))
      EKIN2=EKIN1
      EKIN1=EKIN0
      EKIN0=EKIN
      CALL QUADR(EKIN2,EKIN1,EKIN0,T1,T2,EKIN3(1),EKIN3(2),
     1EKIN3(3))
      ESCF2=ESCF1
      ESCF1=ESCF0
      ESCF0=ESCF
      CALL QUADR(ESCF2,ESCF1,ESCF0,T1,T2,ESCF3(1),ESCF3(2),
     1ESCF3(3))
      GTOT2=GTOT1
      GTOT1=GTOT0
      GTOT0=GTOT
      CALL QUADR(GTOT2,GTOT1,GTOT0,T1,T2,GTOT3(1),GTOT3(2),
     1GTOT3(3))
      XTOT2=XTOT1
      XTOT1=XTOT0
      XOLD2=XOLD2+XOLD1
      XOLD1=XOLD0
C
C   CALCULATE CHANGE IN GEOMETRY
C
      XOLD0=0.D0
      L=0
      XTOT0=0.D0
      SUM1=0.D0
      DO 80 I=1,NUMAT
         SUM=0.D0
         DO 70 J=1,3
            L=L+1
            SUM1=SUM1+(ALLXYZ(1,L)-REF(L))**2*ATMASS(I)
   70    SUM=SUM+(ALLXYZ(2,L)-ALLXYZ(1,L))**2
   80 XOLD0=XOLD0+SQRT(SUM)
      XTOT0=XTOT0+SQRT(SUM1)/SQRT2
      CALL QUADR(XTOT2,XTOT1,XTOT0,T1,T2,
     1XTOT3(1),XTOT3(2),XTOT3(3))
      CALL QUADR(XOLD2,XOLD2+XOLD1,XOLD2+XOLD1+XOLD0,T1,T2,
     1XOLD3(1),XOLD3(2),XOLD3(3))
***********************************************************************
*   GO THROUGH THE CRITERIA FOR DECIDING WHETHER OR NOT TO PRINT THIS *
*   POINT.  IF YES, THEN ALSO CALCULATE THE EXACT POINT AS A FRACTION *
*   BETWEEN THE LAST POINT AND THE CURRENT POINT                      *
***********************************************************************
C   NFRACT IS THE NUMBER OF POINTS TO BE PRINTED IN THE CURRENT DOMAIN
***********************************************************************
      IF(ILOOP.LT.3) GOTO 170
      FRACT=-10
      NFRACT=1
      IF(STEPH.NE.0) THEN
C
C   CRITERION FOR PRINTING RESULTS  IS A CHANGE IN HEAT OF FORMATION =
C   -CHANGE IN KINETIC ENERGY
C
         IF(REFSCF.EQ.0.D0) THEN
            I=nint(ESCF2/STEPH)
            REFSCF=I*STEPH
         ENDIF
         DH=ABS(ESCF1-REFSCF)
         IF(DH.GT.STEPH)THEN
            STEPH=SIGN(STEPH,ESCF1-REFSCF)
          nfract = iabs(nint(dh/steph))
            CC=ESCF3(1)
            BB=ESCF3(2)
            AA=ESCF3(3)
************************************************
* PROGRAMMERS! - BE VERY CAREFUL IF YOU CHANGE *
* THIS FOLLOWING SECTION.  THERE IS NUMERICAL  *
* INSTABILITY IF ABS(BB/AA) IS VERY LARGE. NEAR*
* INFLECTION POINTS AA CHANGES SIGN.       JJPS*
************************************************
            IF(ABS(BB/AA).GT.30)THEN
C
C   USE LINEAR INTERPOLATION
C
               DO 90 I=1,NFRACT
   90          TSTEPS(I)=-(CC-(REFSCF+I*STEPH))/BB
            ELSE
C
C  USE QUADRATIC INTERPOLATION
C
               DO 100 I=1,NFRACT
                  C1=CC-(REFSCF+I*STEPH)
  100          TSTEPS(I)=(-BB+SIGN(SQRT(BB*BB-4.D0*(AA*C1)),BB))/(2.D0*A
     1A)
            ENDIF
            FRACT=-.1
            REFSCF=REFSCF+NFRACT*STEPH
         ENDIF
      ELSEIF(STEPT.NE.0.D0) THEN
C
C   CRITERION FOR PRINTING RESULTS IS A CHANGE IN TIME.
C
         IF(ABS(TOTIME+TOLD2-TREF).GT.STEPT)THEN
            FINCR=STEPT
            I=nint(TOTIME/STEPT)
            FRACT=I*STEPT-TOTIME
            I=nint((TOLD2+TOTIME)/STEPT)
            J=nint(TOTIME/STEPT)
            NFRACT=I-J+ IONE
            IONE=0
            DO 110 I=1,NFRACT
  110       TSTEPS(I)=FRACT+I*STEPT
            TREF=TREF+NFRACT*STEPT
         ENDIF
      ELSEIF(STEPX.NE.0.D0) THEN
C
C   CRITERION FOR PRINTING RESULTS IS A CHANGE IN GEOMETRY.
C
         IF(XOLD2+XOLD1-REFX.GT.STEPX)THEN
            NFRACT=nint((XOLD2+XOLD1-REFX)/STEPX)
            CC=XOLD3(1)
            BB=XOLD3(2)
            AA=XOLD3(3)
            IF(ABS(BB/AA).GT.30)THEN
C
C   USE LINEAR INTERPOLATION
C
               DO 120 I=1,NFRACT
  120          TSTEPS(I)=-(CC-(REFX+I*STEPX))/BB
            ELSE
C
C  USE QUADRATIC INTERPOLATION
C
               DO 130 I=1,NFRACT
                  C1=CC-(REFX+I*STEPX)
  130          TSTEPS(I)=(-BB+SIGN(SQRT(BB*BB-4.D0*(AA*C1)),BB))/(2.D0*A
     1A)
            ENDIF
            REFX=REFX+NFRACT*STEPX
            FRACT=-.1
         ENDIF
      ELSE
C
C   PRINT EVERY POINT.
C
         FRACT=0.0
      ENDIF
      IF(FRACT.LT.-9.D0)GOTO 170
      TURN=(TURN.OR.ABS(FRACT-1.D0).GT.1.D-6)
C
C  LOOP OVER ALL POINTS IN CURRENT DOMAIN
C
      IF(FRACT.EQ.0.D0.AND.NFRACT.EQ.1)THEN
         TEXT1=' '
         TEXT2=' '
         II=0
         CALL DRCOUT(XYZ3,GEO3,VEL3,NVAR,TOTIME,ESCF3,EKIN3,
     1GTOT3,ETOT3,XTOT3,ILOOP,CHARGE,FRACT,TEXT1,TEXT2,II,JLOOP)
         N=0
         DO 140 I=1,NCOPRT
            K=MCOPRT(1,I)
            J=MCOPRT(2,I)
            L=K*3-3+J
            IF(ABS(GEO3(3,L)).GT.1.D-20)FRACT=-GEO3(2,L)/(GEO3(3,L)*2.D0
     1)
            IF(FRACT.GT.0.D0.AND.FRACT.LT.TOLD2) THEN
               IF(GEO3(3,L).GT.0.D0)TEXT1='MIN'
               IF(GEO3(3,L).LT.0.D0)TEXT1='MAX'
               TEXT2=COTYPE(J)
               IF(N.EQ.0)THEN
                  N=N+1
                  WRITE(6,'(/,20(''****''))')
               ENDIF
               TIME=TOTIME+FRACT
               CALL DRCOUT(XYZ3,GEO3,VEL3,NVAR,TIME,ESCF3,EKIN3,
     1GTOT3,ETOT3,XTOT3,ILOOP,CHARGE,FRACT,TEXT1,TEXT2,K,JLOOP)
            ENDIF
  140    CONTINUE
         IF(N.NE.0)WRITE(6,'(/,20(''****''))')
         IF(ABS(ESCF3(3)).GT.1.D-20)FRACT=-ESCF3(2)/(ESCF3(3)*2.D0)
         IF(.NOT.GOTURN.AND.FRACT.GT.0.D0.AND.FRACT.LT.TOLD2*1.04D0
     1.AND. PARMAX) THEN
            GOTURN=.TRUE.
            TIME=FRACT+TOTIME
            IF(ESCF3(3).GT.0.D0) THEN
               TEXT1='MIN'
               IF(LDRC) THEN
                  SUM= ddot(nvar,VELO0,1,VREF ,1)**2/
     &                (ddot(nvar,VELO0,1,VELO0,1)*
     &                 ddot(nvar,VREF ,1,VREF ,1)+1.D-10)
                  SUM1=ddot(nvar,VELO0,1,VREF0,1)**2/
     &                (ddot(nvar,VELO0,1,VELO0,1)*
     &                 ddot(nvar,VREF0,1,VREF0,1)+1.D-10)
                  IF(SUM1.GT.0.1D0)
     1WRITE(6,'(/,A,F8.5,A,F8.5,A,F8.1,A)')' COEF. OF V(0)
     2=',SUM1,'   LAST V(0)',SUM,'   HALF-LIFE =',
     3-0.6931472D0*TIME/LOG(SUM1),' FEMTOSECS'
               ENDIF
               WRITE(6,'(//,A,F11.3,A)')' HALF-CYCLE TIME ='
     1,TIME-TLAST,' FEMTOSECONDS'
               TLAST=TIME
               DO 150 I=1,NVAR
  150          VREF(I)=VELO0(I)
            ENDIF
            IF(ESCF3(3).LT.0.D0)TEXT1='MAX'
            TEXT2=' '
            CALL DRCOUT(XYZ3,GEO3,VEL3,NVAR,TIME,ESCF3,EKIN3,
     1GTOT3,ETOT3,XTOT3,ILOOP,CHARGE,FRACT,TEXT1,TEXT2,0,JLOOP)
         ELSE
            GOTURN=.FALSE.
         ENDIF
      ELSE
         DO 160 I=1,NFRACT
            TIME=TOTIME+TSTEPS(I)
            TEXT1=' '
            TEXT2=' '
C#           WRITE(6,'(A,4F12.4)')' KINETIC ENERGY, POINT',EKIN3,TSTEPS(
            CALL DRCOUT(XYZ3,GEO3,VEL3,NVAR,TIME,ESCF3,EKIN3,
     1GTOT3,ETOT3,XTOT3,ILOOP,CHARGE,TSTEPS(I),TEXT1,TEXT2,0,JLOOP)
  160    CONTINUE
      ENDIF
  170 CONTINUE
C
C BUFFER TOTAL TIME TO 3 POINTS BACK!
C
      TOTIME=TOTIME+TOLD2
      TOLD2=TOLD1
      TOLD1=DELTAT
      ILOOP=ILOOP+1
      RETURN
      END
      SUBROUTINE PULAY(F,P,N,FPPF,FOCK,EMAT,LFOCK,NFOCK,MSIZE,START,PL)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DIMENSION F(*), P(*), FPPF(*), FOCK(*)
      LOGICAL START
************************************************************************
*
*   PULAY USES DR. PETER PULAY'S METHOD FOR CONVERGENCE.
*         A MATHEMATICAL DESCRIPTION CAN BE FOUND IN
*         "P. PULAY, J. COMP. CHEM. 3, 556 (1982).
*
* ARGUMENTS:-
*         ON INPUT F      = FOCK MATRIX, PACKED, LOWER HALF TRIANGLE.
*                  P      = DENSITY MATRIX, PACKED, LOWER HALF TRIANGLE.
*                  N      = NUMBER OF ORBITALS.
*                  FPPF   = WORKSTORE OF SIZE MSIZE, CONTENTS WILL BE
*                           OVERWRITTEN.
*                  FOCK   =      "       "              "         "
*                  EMAT   = WORKSTORE OF AT LEAST 15**2 ELEMENTS.
*                  START  = LOGICAL, = TRUE TO START PULAY.
*                  PL     = UNDEFINED ELEMENT.
*      ON OUTPUT   F      = "BEST" FOCK MATRIX, = LINEAR COMBINATION
*                           OF KNOWN FOCK MATRICES.
*                  START  = FALSE
*                  PL     = MEASURE OF NON-SELF-CONSISTENCY
*                         = [F*P] = F*P - P*F.
*
************************************************************************
      COMMON /KEYWRD/ KEYWRD
      COMMON /NUMCAL/ NUMCAL
      DIMENSION EMAT(20,20), EVEC(1000), COEFFS(20)
      CHARACTER*80 KEYWRD
      LOGICAL DEBUG
         SAVE                                                           GL0892
      DATA ICALCN /0/
C*TNT      DATA FIRST/.TRUE./
C*TNT      IF(FIRST) THEN
C*TNT         FIRST=.FALSE.
      IF (ICALCN .NE. NUMCAL) THEN
         ICALCN = NUMCAL
         MAXLIM=15
         DEBUG=(INDEX(KEYWRD,'DEBUGPULAY') .NE.0)
      ENDIF
      IF(START) THEN
         LINEAR=(N*(N+1))/2
         MFOCK=MSIZE/LINEAR
         IF(MFOCK.GT.MAXLIM)MFOCK=MAXLIM
         IF(DEBUG)
     1    WRITE(6,'('' MAXIMUM SIZE:'',I5)')MFOCK
         NFOCK=1
         LFOCK=1
         START=.FALSE.
      ELSE
         IF(NFOCK.LT.MFOCK)      NFOCK=NFOCK+1
         IF(LFOCK.NE.MFOCK)THEN
            LFOCK=LFOCK+1
         ELSE
            LFOCK=1
         ENDIF
      ENDIF
      LBASE=(LFOCK-1)*LINEAR
*
*   FIRST, STORE FOCK MATRIX FOR FUTURE REFERENCE.
*
      DO 10 I=1,LINEAR
   10 FOCK((I-1)*MFOCK+LFOCK)=F(I)
*
*   NOW FORM /FOCK*DENSITY-DENSITY*FOCK/, AND STORE THIS IN FPPF
*
      CALL MAMULT(P,F,FPPF(LBASE+1),N,0.D0)
      CALL MAMULT(F,P,FPPF(LBASE+1),N,-1.D0)
*
*   FPPF NOW CONTAINS THE RESULT OF FP - PF.
*
      NFOCK1=NFOCK+1
      DO 20 I=1,NFOCK
         EMAT(NFOCK1,I)=-1.D0
         EMAT(I,NFOCK1)=-1.D0
         EMAT(LFOCK,I)=
     &     ddot(linear,FPPF((I-1)*LINEAR+1),1,FPPF(LBASE+1),1)
   20 EMAT(I,LFOCK)=EMAT(LFOCK,I)
      PL=EMAT(LFOCK,LFOCK)/LINEAR
      EMAT(NFOCK1,NFOCK1)=0.D0
      CONST=1.D0/EMAT(LFOCK,LFOCK)
      DO 30 I=1,NFOCK
         DO 30 J=1,NFOCK
   30 EMAT(I,J)=EMAT(I,J)*CONST
      IF(DEBUG) THEN
         WRITE(6,'('' EMAT'')')
         DO 40 I=1,NFOCK1
   40    WRITE(6,'(6E13.6)')(EMAT(J,I),J=1,NFOCK1)
      ENDIF
      L=0
      DO 50 I=1,NFOCK1
         DO 50 J=1,NFOCK1
            L=L+1
   50 EVEC(L)=EMAT(I,J)
      CONST=1.D0/CONST
      DO 60 I=1,NFOCK
         DO 60 J=1,NFOCK
   60 EMAT(I,J)=EMAT(I,J)*CONST
*********************************************************************
*   THE MATRIX EMAT SHOULD HAVE FORM
*
*      |<E(1)*E(1)>  <E(1)*E(2)> ...   -1.0|
*      |<E(2)*E(1)>  <E(2)*E(2)> ...   -1.0|
*      |<E(3)*E(1)>  <E(3)*E(2)> ...   -1.0|
*      |<E(4)*E(1)>  <E(4)*E(2)> ...   -1.0|
*      |     .            .      ...     . |
*      |   -1.0         -1.0     ...    0. |
*
*   WHERE <E(I)*E(J)> IS THE SCALAR PRODUCT OF [F*P] FOR ITERATION I
*   TIMES [F*P] FOR ITERATION J.
*
*********************************************************************
      CALL OSINV(EVEC,NFOCK1,D)
      IF(ABS(D).LT.1.D-6)THEN
         START=.TRUE.
         RETURN
      ENDIF
      IF(NFOCK.LT.2) RETURN
      IL=NFOCK*NFOCK1
      DO 70 I=1,NFOCK
   70 COEFFS(I)=-EVEC(I+IL)
      IF(DEBUG) THEN
         WRITE(6,'('' EVEC'')')
         WRITE(6,'(6F12.6)')(COEFFS(I),I=1,NFOCK)
         WRITE(6,'(''    LAGRANGIAN MULTIPLIER (ERROR) =''
     1             ,F13.6)')EVEC(NFOCK1*NFOCK1)
      ENDIF
      DO 90 I=1,LINEAR
         SUM=0
         L=0
         II=(I-1)*MFOCK
         DO 80 J=1,NFOCK
   80    SUM=SUM+COEFFS(J)*FOCK(J+II)
   90 F(I)=SUM
      RETURN
      END
      SUBROUTINE REACT1(ESCF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
C
      COMMON /GEOM  / GEO(3,NUMATM)
      DIMENSION GEOA(3,NUMATM), GEOVEC(3,NUMATM),
     1          P1STOR(MPACK), P2STOR(MPACK),
     2          P3STOR(MPACK), XOLD(MAXPAR), GROLD(MAXPAR)
      COMMON /GEOKST/ NATOMS,LABELS(NUMATM),
     1                NA(NUMATM), NB(NUMATM), NC(NUMATM)
      COMMON /DENSTY/ P(MPACK),PA(MPACK),PB(MPACK)
      COMMON /GEOSYM/ NDEP,LOCPAR(MAXPAR),IDEPFN(MAXPAR),LOCDEP(MAXPAR)
      COMMON /GEOVAR/ XPARAM(MAXPAR), NVAR, LOC(2,MAXPAR)               IR0394
      COMMON /GRADNT/ GRAD(MAXPAR),GNORM
      COMMON /ISTOPE/ AMS(107)
      COMMON /GRAVEC/ COSINE
      COMMON /KEYWRD/ KEYWRD
C Common MOLKST splitted in MOLKSI and MOLKSR    Ivan Rossi 0394   &8)
      COMMON /MOLKSI/ NUMAT,NAT(NUMATM),NFIRST(NUMATM),
     1                NMIDLE(NUMATM),NLAST(NUMATM), NORBS,
     2                NELECS,NALPHA,NBETA,NCLOSE,NOPEN
     3       /MOLKSR/ FRACT
      COMMON /REACTN/ STEP, GEOA, GEOVEC,CALCST
      COMMON /IOCM/ IREAD
      LOGICAL GRADNT, FINISH, XYZ, INT, GOK(2)
************************************************************************
*
*  REACT1 DETERMINES THE TRANSITION STATE OF A CHEMICAL REACTION.
*
*   REACT WORKS BY USING TWO SYSTEMS SIMULTANEOUSLY, THE HEATS OF
*   FORMATION OF BOTH ARE CALCULATED, THEN THE MORE STABLE ONE
*   IS MOVED IN THE DIRECTION OF THE OTHER. AFTER A STEP THE
*   ENERGIES ARE COMPARED, AND THE NOW LOWER-ENERGY FORM IS MOVED
*   IN THE DIRECTION OF THE HIGHER-ENERGY FORM. THIS IS REPEATED
*   UNTIL THE SADDLE POINT IS REACHED.
*
*   IF ONE FORM IS MOVED 3 TIMES IN SUCCESSION, THEN THE HIGHER ENERGY
*   FORM IS RE-OPTIMIZED WITHOUT SHORTENING THE DISTANCE BETWEEN THE TWO
*   FORMS. THIS REDUCES THE CHANCE OF BEING CAUGHT ON THE SIDE OF A
*   TRANSITION STATE.
*
************************************************************************
      DIMENSION IDUM1(NUMATM), IDUM2(NUMATM), XSTORE(MAXPAR),
     +IDUM3(NUMATM), IDUM4(NUMATM), COORD(3,NUMATM), IROT(2,3)
      EQUIVALENCE (IDUMMY,COORD)
      CHARACTER*80 KEYWRD
         SAVE                                                           GL0892
      DATA IROT/1,2,1,3,2,3/
      GOLD=0.D0
      GOK(1)=.FALSE.
      GOK(2)=.FALSE.
      XYZ=(INDEX(KEYWRD,' XYZ') .NE. 0)
      GRADNT=(INDEX(KEYWRD,'GRAD') .NE. 0)
      I=(INDEX(KEYWRD,' BAR'))
      STEPMX=0.15D0
      IF(I.NE.0) STEPMX=READA(KEYWRD,I)
      MAXSTP=1000
C
C    READ IN THE SECOND GEOMETRY.
C
      IF(XYZ) THEN
         CALL GETGEO(IREAD,LABELS,GEOA,LOC,NA,NB,NC,AMS,NATOMS,INT)
      ELSE
         CALL GETGEO(IREAD,IDUM1,GEOA,IDUMMY,
     1         IDUM1,IDUM2,IDUM3,AMS,NATOMS,INT)
C
C  IF INTERNAL COORDINATES ARE TO BE USED, CHECK THE CONNECTIVITY
C
      L=0
      DO 8 I=1,NATOMS
      IF(IDUM1(I).NE.NA(I))THEN
      L=L+1
      IF(L.EQ.1)WRITE(6,'(10X,''ERRORS DETECTED IN CONNECTIVITY'')')
      WRITE(6,'(A,I3,A,I3,A,I3,A)')' FOR ATOM',I,' THE BOND LABELS ARE D
     +IFFERENT:      ',IDUM1(I),' AND',NA(I)
      ENDIF
      IF(IDUM2(I).NE.NB(I))THEN
      L=L+1
      IF(L.EQ.1)WRITE(6,'(10X,''ERRORS DETECTED IN CONNECTIVITY'')')
      WRITE(6,'(A,I3,A,I3,A,I3,A)')' FOR ATOM',I,' THE BOND ANGLE LABELS
     + ARE DIFFERENT:',IDUM2(I),' AND',NB(I)
      ENDIF
      IF(IDUM3(I).NE.NC(I))THEN
      L=L+1
      IF(L.EQ.1)WRITE(6,'(10X,''ERRORS DETECTED IN CONNECTIVITY'')')
      WRITE(6,'(A,I3,A,I3,A,I3,A)')' FOR ATOM',I,' THE DIHEDRAL LABELS A
     +RE DIFFERENT:  ',IDUM3(I),' AND',NC(I)
      ENDIF
  8   CONTINUE
      IF(L.NE.0)WRITE(6,'(10X,A)')' CORRECT BEFORE RESUBMISSION'
      IF(L.NE.0)STOP
      ENDIF
      CLOSE (IREAD)
cmgc      TIME0= SECOND()
C
C  SWAP FIRST AND SECOND GEOMETRIES AROUND
C  SO THAT GEOUT CAN OUTPUT DATA ON SECOND GEOMETRY.
C
      NUMAT2=0
      DO 10 I=1,NATOMS
         IF(LABELS(I).NE.99) NUMAT2=NUMAT2+1
         CONST=1.D0
         DO 10 J=1,3
            X=GEOA(J,I)*CONST
            CONST=0.0174532925D0
            GEOA(J,I)=GEO(J,I)
            GEO(J,I)=X
   10 CONTINUE
      IF(NUMAT2.NE.NUMAT) THEN
         WRITE(6,'(//10X,'' NUMBER OF ATOMS IN SECOND SYSTEM IS '',
     1''INCORRECT'',/)')
         WRITE(6,'('' NUMBER OF ATOMS IN FIRST  SYSTEM ='',I4)')NUMAT
         WRITE(6,'('' NUMBER OF ATOMS IN SECOND SYSTEM ='',I4)')NUMAT2
         GOTO 270
      ENDIF
      WRITE(6,'(//10X,'' GEOMETRY OF SECOND SYSTEM'',/)')
      IF(NDEP.NE.0) CALL SYMTRY
      CALL GEOUT
C
C     CONVERT TO CARTESIAN, IF NECESSARY
C
      IF(   XYZ   )THEN
         CALL GMETRY(GEO,COORD)
         SUMX=0.D0
         SUMY=0.D0
         SUMZ=0.D0
         DO 20 J=1,NUMAT
            SUMX=SUMX+COORD(1,J)
            SUMY=SUMY+COORD(2,J)
   20    SUMZ=SUMZ+COORD(3,J)
         SUMX=SUMX/NUMAT
         SUMY=SUMY/NUMAT
         SUMZ=SUMZ/NUMAT
         DO 30 J=1,NUMAT
            GEO(1,J)=COORD(1,J)-SUMX
            GEO(2,J)=COORD(2,J)-SUMY
   30    GEO(3,J)=COORD(3,J)-SUMZ
         WRITE(6,'(//,''  CARTESIAN GEOMETRY OF FIRST SYSTEM'',//)')
         WRITE(6,'(3F14.5)')((GEO(J,I),J=1,3),I=1,NUMAT)
         SUMX=0.D0
         SUMY=0.D0
         SUMZ=0.D0
         DO 40 J=1,NUMAT
            SUMX=SUMX+GEOA(1,J)
            SUMY=SUMY+GEOA(2,J)
   40    SUMZ=SUMZ+GEOA(3,J)
         SUM=0.D0
         SUMX=SUMX/NUMAT
         SUMY=SUMY/NUMAT
         SUMZ=SUMZ/NUMAT
         DO 50 J=1,NUMAT
            GEOA(1,J)=GEOA(1,J)-SUMX
            GEOA(2,J)=GEOA(2,J)-SUMY
            GEOA(3,J)=GEOA(3,J)-SUMZ
            SUM=SUM+(GEO(1,J)-GEOA(1,J))**2
     1           +(GEO(2,J)-GEOA(2,J))**2
     2           +(GEO(3,J)-GEOA(3,J))**2
   50    CONTINUE
         DO 100 L=3,1,-1
C
C     DOCKING IS DONE IN STEPS OF 16, 4, AND 1 DEGREES AT A TIME.
C
            CA=COS(4.D0**(L-1)*0.01745329D0)
            SA=SQRT(ABS(1.D0-CA**2))
            DO 90 J=1,3
               IR=IROT(1,J)
               JR=IROT(2,J)
               DO 80 I=1,10
                  SUMM=0.D0
                  DO 60 K=1,NUMAT
                     X         = CA*GEOA(IR,K)+SA*GEOA(JR,K)
                     GEOA(JR,K)=-SA*GEOA(IR,K)+CA*GEOA(JR,K)
                     GEOA(IR,K)=X
                     SUMM=SUMM+(GEO(1,K)-GEOA(1,K))**2
     1                         +(GEO(2,K)-GEOA(2,K))**2
     2                         +(GEO(3,K)-GEOA(3,K))**2
   60             CONTINUE
                  IF(SUMM.GT.SUM) THEN
                     IF(I.GT.1)THEN
                        SA=-SA
                        DO 70 K=1,NUMAT
                           X         = CA*GEOA(IR,K)+SA*GEOA(JR,K)
                           GEOA(JR,K)=-SA*GEOA(IR,K)+CA*GEOA(JR,K)
                           GEOA(IR,K)=X
   70                   CONTINUE
                        GOTO 90
                     ENDIF
                     SA=-SA
                  ENDIF
   80          SUM=SUMM
   90       CONTINUE
  100    CONTINUE
         WRITE(6,'(//,''  CARTESIAN GEOMETRY OF SECOND SYSTEM'',//)')
         WRITE(6,'(3F14.5)')((GEOA(J,I),J=1,3),I=1,NUMAT)
         WRITE(6,'(//,''   "DISTANCE":'',F13.6)')SUM
         WRITE(6,'(//,''  REACTION COORDINATE VECTOR'',//)')
         WRITE(6,'(3F14.5)')((GEOA(J,I)-GEO(J,I),J=1,3),I=1,NUMAT)
         NA(1)=99
         J=0
         NVAR=0
         DO 120 I=1,NATOMS
            IF(LABELS(I).NE.99)THEN
               J=J+1
               DO 110 K=1,3
                  NVAR=NVAR+1
                  LOC(2,NVAR)=K
  110          LOC(1,NVAR)=J
               LABELS(J)=LABELS(I)
            ENDIF
  120    CONTINUE
         NATOMS=NUMAT
      ENDIF
C
C   XPARAM HOLDS THE VARIABLE PARAMETERS FOR GEOMETRY IN GEO
C   XOLD   HOLDS THE VARIABLE PARAMETERS FOR GEOMETRY IN GEOA
C
      IF(NVAR.EQ.0)THEN
         WRITE(6,'(///10X,''THERE ARE NO VARIABLES IN THE SADDLE'',
     1'' CALCULATION!'')')
         STOP
      ENDIF
      SUM=0.D0
      DO 130 I=1,NVAR
         GROLD(I)=1.D0
         XPARAM(I)=GEO(LOC(2,I),LOC(1,I))
         XOLD(I)=GEOA(LOC(2,I),LOC(1,I))
  130 SUM=SUM+(XPARAM(I)-XOLD(I))**2
      STEP0=SQRT(SUM)
      ONE=1.D0
      DELL=0.1D0
      EOLD=-2000.D0
cmgc      TIME1=SECOND()
      SWAP=0
      LINEAR=(NORBS*(NORBS+1))/2
      DO 140 I=1,LINEAR
         P1STOR(I)=P(I)
         P2STOR(I)=PA(I)
  140 P3STOR(I)=PB(I)
      DO 230 ILOOP=1,MAXSTP
cmgc         TIME2=SECOND()
         WRITE(6,'('' TIME='',F9.2)')TIME2-TIME1
         TIME1=TIME2
C
C   THIS METHOD OF CALCULATING 'STEP' IS QUITE ARBITARY, AND NEEDS
C   TO BE IMPROVED BY INTELLIGENT GUESSWORK!
C
         IF (GNORM.LT.1.D-3)GNORM=1.D-3
         WRITE(6,'('' CURRENT BAR, STEPMX, GNORM'',3F12.7)')
     1STEP0,STEPMX,GNORM
         STEP=MIN(SWAP,0.5D0, 6.D0/GNORM, DELL,STEPMX*STEP0+0.005D0)
         SWAP=SWAP+1.D0
         DELL=DELL+0.1
         STEP0=STEP0-STEP
         IF(STEP0.LT.0.01D0) GOTO 240
         STEP=STEP0
         DO 150 I=1,NVAR
  150    XSTORE(I)=XPARAM(I)
         CALL FLEPO(XPARAM, NVAR, ESCF)
         DO 160 I=1,NVAR
  160    XPARAM(I)=GEO(LOC(2,I),LOC(1,I))
         WRITE(6,'(//10X,''FOR POINT'',I3)')ILOOP
         WRITE(6,'('' DISTANCE A - B  '',F12.6)')STEP
C
C   NOW TO CALCULATE THE "CORRECT" GRADIENTS, SWITCH OFF 'STEP'.
C
         STEP=0.D0
         DO 170 I=1,NVAR
  170    GRAD(I)=GROLD(I)
         CALL COMPFG (XPARAM, .TRUE., FUNCT1,.FALSE.,GRAD,.TRUE.)
         DO 180 I=1,NVAR
  180    GROLD(I)=GRAD(I)
         IF (GRADNT) THEN
            WRITE(6,'(''  ACTUAL GRADIENTS OF THIS POINT'')')
            WRITE(6,'(8F10.4)')(GRAD(I),I=1,NVAR)
         ENDIF
         WRITE(6,'('' HEAT            '',F12.6)')FUNCT1
         GNORM=SQRT(ddot(nvar,grad,1,grad,1))
         WRITE(6,'('' GRADIENT NORM   '',F12.6)')GNORM
         COSINE=COSINE*ONE
         WRITE(6,'('' DIRECTION COSINE'',F12.6)')COSINE
         CALL GEOUT
         IF(SWAP.GT.2.9D0 .OR. ILOOP .GT. 3 .AND. COSINE .LT. 0.D0
     1  .OR. ESCF .GT. EOLD)
     2  THEN
            IF(SWAP.GT.2.9D0)THEN
               SWAP=0.D0
            ELSE
               SWAP=0.5D0
            ENDIF
C
C   SWAP REACTANT AND PRODUCT AROUND
C
            FINISH=(GOK(1).AND.GOK(2) .AND. COSINE .LT. 0.D0)
            IF(FINISH) THEN
               WRITE(6,'(//10X,'' BOTH SYSTEMS ARE ON THE SAME SIDE OF T
     1HE '',''TRANSITION STATE -'',/10X,'' GEOMETRIES OF THE SYSTEMS'',
     2'' ON EACH SIDE OF THE T.S. ARE AS FOLLOWS'')')
               DO 190 I=1,NVAR
  190          XPARAM(I)=XSTORE(I)
               CALL COMPFG (XPARAM, .TRUE., FUNCT1,.TRUE.,GRAD,.TRUE.)
               WRITE(6,'(//10X,'' GEOMETRY ON ONE SIDE OF THE TRANSITION
     1'','' STATE'')')
               CALL WRITMO(TIME0,FUNCT1)
            ENDIF
            WRITE(6,'(''  REACTANTS AND PRODUCTS SWAPPED AROUND'')')
            ONE=-1.D0
            EOLD=ESCF
            SUM=GOLD
            GOLD=GNORM
            I=1.7+ONE*0.5
            IF(GNORM.GT.10.D0)GOK(I)=.TRUE.
            GNORM=SUM
            DO 200 I=1,NUMAT
               DO 200 J=1,3
                  X=GEO(J,I)
                  GEO(J,I)=GEOA(J,I)
  200       GEOA(J,I)=X
            DO 210 I=1,NVAR
               X=XOLD(I)
               XOLD(I)=XPARAM(I)
  210       XPARAM(I)=X
C
C
C    SWAP AROUND THE DENSITY MATRICES.
C
            DO 220 I=1,LINEAR
               X=P1STOR(I)
               P1STOR(I)=P(I)
               P(I)=X
               X=P2STOR(I)
               P2STOR(I)=PA(I)
               PA(I)=X
               X=P3STOR(I)
               P3STOR(I)=PB(I)
               PB(I)=X
  220       CONTINUE
            IF(FINISH) GOTO 240
         ELSE
            ONE=1.D0
         ENDIF
  230 CONTINUE
  240 CONTINUE
      WRITE(6,'('' AT END OF REACTION'')')
      GOLD=SQRT(ddot(nvar,grad,1,grad,1))
      CALL COMPFG (XPARAM, .TRUE., FUNCT1,.TRUE.,GRAD,.TRUE.)
      GNORM=SQRT(ddot(nvar,grad,1,grad,1))
      DO 250 I=1,NVAR
  250 GROLD(I)=XPARAM(I)
      CALL WRITMO(TIME0,FUNCT1)
*
* THE GEOMETRIES HAVE (A) BEEN OPTIMIZED CORRECTLY, OR
*                     (B) BOTH ENDED UP ON THE SAME SIDE OF THE T.S.
*
*  TRANSITION STATE LIES BETWEEN THE TWO GEOMETRIES
*
      C1=GOLD/(GOLD+GNORM)
      C2=1.D0-C1
      WRITE(6,'('' BEST ESTIMATE GEOMETRY OF THE TRANSITION STATE'')')
      WRITE(6,'(//10X,'' C1='',F8.3,''C2='',F8.3)')C1,C2
      DO 260 I=1,NVAR
  260 XPARAM(I)=C1*GROLD(I)+C2*XOLD(I)
      STEP=0.D0
      CALL COMPFG (XPARAM, .TRUE., FUNCT1,.TRUE.,GRAD,.TRUE.)
      CALL WRITMO(TIME0,FUNCT1)
cmgc      TIM=SECOND()-TIME0
      WRITE(6,'(///,'' TOTAL CPU TIME: '',F16.2,'' SECONDS'')') TIM
      WRITE(6,'(/,'' == MOPAC DONE =='')')
c     call timend
      return
  270 STOP
      END
      SUBROUTINE SEARCH(XPARAM,ALPHA,SIG,NVAR,GMIN,OKC,OKF, FUNCT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
C
      DIMENSION XPARAM(*), SIG(*)
************************************************************************
*
* SEARCH PERFORMS A LINE SEARCH FOR POWSQ. IT MINIMIZES THE NORM OF
*        THE GRADIENT VECTOR IN THE DIRECTION SIG.
*
* ON INPUT  XPARAM = CURRENT POINT IN NVAR DIMENSIONAL SPACE.
*           ALPHA  = STEP SIZE (IN FACT ALPHA IS CALCULATED IN SEARCH).
*           SIG    = SEARCH DIRECTION VECTOR.
*           NVAR   = NUMBER OF PARAMETERS IN SIG (& XPARAM)
*
* ON OUTPUT XPARAM = PARAMETERS OF MINIMUM.
*           ALPHA  = DISTANCE TO MINIMUM.
*           GMIN   = GRADIENT NORM AT MINIMUM.
*           OKC    = EXITED BEFORE COUNTS WERE EXCEEDED (LOGICAL)
*           OKF    = FUNCTION WAS IMPROVED.
************************************************************************
      COMMON /SIGMA1/ GNEXT, AMIN, ANEXT
      COMMON /SIGMA2/  GNEXT1(MAXPAR), GMIN1(MAXPAR)
      COMMON/KEYWRD/ KEYWRD
      COMMON /NUMCAL/ NUMCAL
      DIMENSION GRAD(MAXPAR),XREF(MAXPAR), GREF(MAXPAR), XMIN1(MAXPAR)
      CHARACTER*80 KEYWRD
      LOGICAL DEBUG, OKC, OKF, NOPR
         SAVE                                                           GL0892
      DATA ICALCN /0/
      IF (ICALCN .NE. NUMCAL) THEN
         ICALCN = NUMCAL
C
C    TOLG   = CRITERION FOR EXIT BY RELATIVE CHANGE IN GRADIENT.
C
         DEBUG=(INDEX(KEYWRD,'LINMIN') .NE. 0)
         NOPR=( .NOT. DEBUG)
         LOOKS=0
         OKF=.TRUE.
         TINY=0.1D0
         TOLERG=0.02D0
         IF(NVAR .EQ. 1)TIMY=0.D0
         G=100.D0
         XMAXM=2.D0
         ALPHA=0.1D0
      ENDIF
      ANEXT1=0.D0
      DO 10 I=1,NVAR
         GREF(I)  =GMIN1(I)
         GNEXT1(I)=GMIN1(I)
         XMIN1(I) =XPARAM(I)
   10 XREF(I)  =XPARAM(I)
      IF(ABS(ALPHA) .GT. 0.2)ALPHA=SIGN(0.2D0,ALPHA)
      IF(DEBUG) THEN
         WRITE(6,'('' SEARCH DIRECTION VECTOR'')')
         WRITE(6,'(6F12.6)')(SIG(I),I=1,NVAR)
         WRITE(6,'('' INITIAL GRADIENT VECTOR'')')
         WRITE(6,'(6F12.6)')(GMIN1(I),I=1,NVAR)
      ENDIF
      gb = ddot(nvar,gmin1,1,gref,1)
      IF(DEBUG) WRITE(6,'('' GRADIENT AT START OF SEARCH:'',F16.6)')
     1SQRT(GB)
      GSTORE=GB
      AMIN=0.D0
      GMINN=1.D9
C
C
      TA=0.D0
      GA=GB
      GB=1.D9
      ITRYS=0
      GOTO 30
   20 SUM=GA/(GA-GB)
      ITRYS=ITRYS+1
      IF(ABS(SUM) .GT. 3.D0) SUM=SIGN(3.D0,SUM)
      ALPHA=(TB-TA)*SUM+TA
C
C         XPARAM IS THE GEOMETRY OF THE PREDICTED MINIMUM ALONG THE LINE
C
   30 CONTINUE
      DO 40 I=1,NVAR
   40 XPARAM(I)=XREF(I)+ALPHA*SIG(I)
C
C         CALCULATE GRADIENT NORM AND GRADIENTS AT THE PREDICTED MINIMUM
C
      IF(ITRYS.EQ.1)THEN
      DO 50 I=1,NVAR
   50 GRAD(I)=0.D0
      ENDIF
      CALL COMPFG (XPARAM, .TRUE., FUNCT, .TRUE., GRAD, .TRUE.)
      LOOKS=LOOKS+1
C
C          G IS THE PROJECTION OF THE GRADIENT ALONG SIG.
C
      g = ddot(nvar,gref,1,grad,1)
      gtot = sqrt(ddot(nvar,grad,1,grad,1))
      IF( .NOT. NOPR)
     1WRITE(6,'('' LOOKS'',I3,'' ALPHA ='',F12.6,'' GRADIENT'',F12.3,
     2'' G  ='',F16.6)')
     3looks,alpha,gtot,g
      IF(GTOT .LT. GMINN) THEN
         GMINN=GTOT
         IF(ABS(AMIN-ALPHA) .GT.1.D-2) THEN
*
* WE CAN MOVE ANEXT TO A POINT NEAR, BUT NOT TOO NEAR, AMIN, SO THAT THE
* SECOND DERIVATIVESWILLBEREALISTIC(D2E/DX2=(GNEXT1-GMIN1)/(ANEXT-AMIN))
*
            ANEXT=AMIN
            DO 60 I=1,NVAR
   60       GNEXT1(I)=GMIN1(I)
         ENDIF
         AMIN=ALPHA
         DO 70 I=1,NVAR
            IF(GMINN.LT.GMIN) XMIN1(I)=XPARAM(I)
   70    GMIN1(I)=GRAD(I)
         IF(GMIN.GT.GMINN)GMIN=GMINN
      ENDIF
      IF(ITRYS .GT. 8) GOTO 80
      IF (ABS(G/GSTORE).LT.TINY .OR. ABS(G) .LT. TOLERG) GO TO 80
      IF(ABS(G) .LT. MAX(ABS(GA),ABS(GB)) .OR.
     1     GA*GB .GT. 0.D0 .AND. G*GA .LT. 0.D0) THEN
C
C   G IS AN IMPROVEMENT ON GA OR GB.
C
         IF(ABS(GB) .LT. ABS(GA))THEN
            TA=ALPHA
            GA=G
            GO TO 20
         ELSE
            TB=ALPHA
            GB=G
            GO TO 20
         ENDIF
      ELSE
C#         WRITE(6,'(//10X,'' FAILED IN SEARCH, SEARCH CONTINUING'')')
         GOTO 80
      ENDIF
   80 LNSTOP=4
      gminn = sqrt(ddot(nvar,gmin1,1,gmin1,1))
      DO 90 I=1,NVAR
   90 XPARAM(I)=XMIN1(I)
      IF(DEBUG) THEN
         WRITE(6,'('' AT EXIT FROM SEARCH'')')
         WRITE(6,'('' XPARAM'',6F12.6)')(XPARAM(I),I=1,NVAR)
         WRITE(6,'('' GNEXT1'',6F12.6)')(GNEXT1(I),I=1,NVAR)
         WRITE(6,'('' GMIN1 '',6F12.6)')(GMIN1(I),I=1,NVAR)
         WRITE(6,'('' AMIN, ANEXT,GMIN'',4F12.6)')
     1    AMIN,ANEXT,GMIN
      ENDIF
      IF(GMINN.GT.GMIN)THEN
      DO 45 I=1,NVAR
  45  XPARAM(I)=XREF(I)
      ENDIF
      RETURN
C
      END
      SUBROUTINE WRITMO(TIME0,FUNCT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
#include "mopcvar.par"
C
C
      CHARACTER*80 KEYWRD,KOMENT,TITLE
      DOUBLE PRECISION MECI
      COMMON /KEYWRD/ KEYWRD
      COMMON /TITLES/ KOMENT,TITLE
      COMMON /ELEMTS/ ELEMNT(107)
      COMMON /GEOM  / GEO(3,NUMATM)
      COMMON /GEOKST/ NATOMS,LABELS(NUMATM),
     1                NA(NUMATM),NB(NUMATM),NC(NUMATM)
      COMMON /HMATRX/ H(MPACK)
      COMMON /FOKMAT/ F(MPACK), FB(MPACK)
      COMMON /VECTOR/ C(MORB2),EIGS(MAXORB),CBETA(MORB2),EIGB(MAXORB)
      COMMON /DENSTY/ P(MPACK),PA(MPACK),PB(MPACK)
      COMMON /GEOSYM/ NDEP,LOCPAR(MAXPAR),IDEPFN(MAXPAR),LOCDEP(MAXPAR)
C    changed common path for portability  (IR)
      COMMON /PATHI / LATOM,LPARAM
      COMMON /PATHR / REACT(200)
      COMMON /NUMSCF/ NSCF
      COMMON /WMATRX/ WJ(N2ELEC), WK(N2ELEC)
      COMMON /ATHEAT/ ATHEAT
      COMMON /CORE  / CORE(107)
      COMMON /SCRACH/ RXYZ(MPACK), XDUMY(MAXPAR**2-MPACK)
      COMMON /CIMATS/ ENGYCI(3),VECTCI(9),ECI(6)
      COMMON /MESAGE/ IFLEPO,IITER
      COMMON /ATMASS/ ATMASS(NUMATM)
      COMMON /ENUCLR/ ENUCLR
      COMMON /ELECT / ELECT
      COMMON /XYZGRA/ DXYZ(3,NUMATM*27)
      COMMON /GRADNT/ GRAD(MAXPAR), GNORM
C Common MOLKST splitted in MOLKSI and MOLKSR    Ivan Rossi 0394   &8)
      COMMON /MOLKSI/ NUMAT,NAT(NUMATM),NFIRST(NUMATM),
     1                NMIDLE(NUMATM),NLAST(NUMATM), NORBS,
     2                NELECS,NALPHA,NBETA,NCLOSE,NOPEN
     3       /MOLKSR/ FRACT
      COMMON /GEOVAR/ XPARAM(MAXPAR), NVAR, LOC(2,MAXPAR)               IR0394
      COMMON /NUMCAL/ NUMCAL
************************************************************************
*
*   WRITE PRINTS OUT MOST OF THE RESULTS.
*         IT SHOULD NOT ALTER ANY PARAMETERS, SO THAT IT CAN BE CALLED
*         AT ANY CONVENIENT TIME.
*
************************************************************************
      DIMENSION Q(MAXORB), Q2(MAXORB), COORD(3,NUMATM)
     1,IEL1(107), NELEMT(107), IEL2(107)
      DIMENSION W(N2ELEC), DUMY(3)
      LOGICAL UHF, CI, SINGLT, TRIPLT, EXCITD, PRTGRA, XYZ
      CHARACTER TYPE(3)*11, IDATE*24, CALCN(2)*5, GTYPE*13, GRTYPE*14,
     1          FLEPO(16)*58, ITER(2)*58, NUMBRS(11)*1                  IR0494
      CHARACTER*2 ELEMNT, IELEMT(20), SPNTYP*7, CALTYP*7
      EQUIVALENCE (W,WJ)
         SAVE                                                           GL0892
      DATA TYPE/'BOND       ','ANGLE      ','DIHEDRAL   '/
      DATA CALCN /'     ','ALPHA'/
      DATA NUMBRS /'0','1','2','3','4','5','6','7','8','9',' '/
      DATA ICALCN /0/
      DATA FLEPO(1),FLEPO(2),FLEPO(3)/
     1' 1SCF WAS SPECIFIED, SO BFGS WAS NOT USED                 ',
     2' GRADIENTS WERE INITIALLY ACCEPTABLY SMALL                ',
     3' HERBERTS TEST WAS SATISFIED IN BFGS                      '/
      DATA FLEPO(4),FLEPO(5),FLEPO(6)/
     1' THE LINE MINIMIZATION FAILED TWICE IN A ROW.   TAKE CARE!',
     2' BFGS FAILED DUE TO COUNTS EXCEEDED. TAKE CARE!           ',
     3' PETERS TEST WAS SATISFIED IN BFGS OPTIMIZATION           '/
      DATA FLEPO(7),FLEPO(8),FLEPO(9)/
     1' THIS MESSAGE SHOULD NEVER APPEAR, CONSULT A PROGRAMMER!! ',
     2' GRADIENT TEST NOT PASSED, BUT FURTHER WORK NOT JUSTIFIED ',
     3' A FAILURE HAS OCCURRED, TREAT RESULTS WITH CAUTION!!     '/
      DATA FLEPO(10),FLEPO(11),FLEPO(12)/
     1' GEOMETRY OPTIMIZED USING NLLSQ. GRADIENT NORM MINIMIZED  ',
     2' GEOMETRY OPTIMIZED USING POWSQ. GRADIENT NORM MINIMIZED  ',
     3' CYCLES EXCEEDED, GRADIENT NOT FULLY MINIMIZED IN NLLSQ   '/
      DATA FLEPO(13),FLEPO(14),FLEPO(15)/                                IR0394
     1' 1SCF RUN AFTER RESTART.  GEOMETRY MIGHT NOT BE OPTIMIZED ',
     2' HEAT OF FORMATION MINIMIZED IN ONE LINE SEARCH           ',
     3' GEOMETRY OPTIMISED USING EIGENVECTOR FOLLOWING (EF).     '/
      DATA FLEPO(16)/
     1' EF-OPTIMIZED GEOMETRY.  NUMBER OF -VE ROOTS INCORRECT    '/
      DATA ITER/
     1' SCF FIELD WAS ACHIEVED                                   ',
     2'  ++++----**** FAILED TO ACHIEVE SCF. ****----++++        '/
C
C SUMMARY OF RESULTS (NOTE: THIS IS IN A SUBROUTINE SO IT
C          CAN BE USED BY THE PATH OPTION)
      PI=3.141592653589D0
      IDATE=' '
      IF(IFLEPO.EQ.0) IFLEPO=7
      IUHF=MIN(INDEX(KEYWRD,'UHF'),1)+1
      PRTGRA=(INDEX(KEYWRD,' GRAD').NE.0)
      LINEAR=(NORBS*(NORBS+1))/2
      XYZ=(INDEX(KEYWRD,' XYZ') .NE. 0)
      SINGLT=(INDEX(KEYWRD,'SINGLET') .NE. 0)
      TRIPLT=(INDEX(KEYWRD,'TRIPLET') .NE. 0)
      EXCITD=(INDEX(KEYWRD,'EXCITED') .NE. 0)
      SPNTYP='GROUND '
      IF(SINGLT) SPNTYP='SINGLET'
      IF(TRIPLT) SPNTYP='TRIPLET'
      IF(EXCITD) SPNTYP='EXCITED'
      CI=(INDEX(KEYWRD,'C.I.') .NE. 0)
      IF(INDEX(KEYWRD,'MINDO') .NE. 0) THEN
         CALTYP='MINDO/3'
      ELSEIF(INDEX(KEYWRD,'AM1') .NE. 0) THEN
         CALTYP='  AM1  '
      ELSEIF(INDEX(KEYWRD,'PM3') .NE. 0) THEN
         CALTYP='  PM3  '
      ELSE
         CALTYP=' MNDO  '
      ENDIF
      UHF=(IUHF.EQ.2)
      CALL DATE(IDATE)
      DEGREE=57.29577951D0
      IF(NA(1).EQ.99)THEN
         DEGREE=1.D0
         TYPE(1)='           '
         TYPE(2)='           '
         TYPE(3)='           '
      ENDIF
      GNORM=0.D0
      IF(NVAR.NE.0)GNORM=SQRT(ddot(nvar,grad,1,grad,1))
      WRITE(6,'(/,'' ----'',15(''-----''))')
      WRITE(6,'(A)')KEYWRD,KOMENT,TITLE
      WRITE(6,'(//4X,A58)')FLEPO(IFLEPO)
      IITER=MAX(1,IITER)
      WRITE(6,'(4X,A58)')ITER(IITER)
      WRITE(6,'(//30X,A7,''  CALCULATION'')')CALTYP
      WRITE(6,'(55X,''VERSION '',F5.2)')VERSON
      WRITE(6,'(55X,A24)')IDATE
      IF(IITER.EQ.2)THEN
C
C   RESULTS ARE MEANINGLESS. DON'T PRINT ANYTHING!
C
         WRITE(6,'(//,'' FOR SOME REASON THE SCF CALCULATION FAILED.'',/
     1,'' THE RESULTS WOULD BE MEANINGLESS, SO WILL NOT BE PRINTED.'')')
         WRITE(6,'('' TRY TO FIND THE REASON FOR THE FAILURE BY USING ''
     1,''"PL".'',/,
     2'' CHECK YOUR GEOMETRY AND ALSO TRY USING SHIFT OR PULAY. '')')
         CALL GEOUT
         RETURN                                                          IR0295
      ENDIF
      WRITE(6,'(////10X,''FINAL HEAT OF FORMATION ='',F17.5,'' KCAL''
     1)')FUNCT
      IF(LATOM.EQ.0) WRITE(6,'(/)')
      WRITE(6,'(    10X,''TOTAL ENERGY            ='',F17.5,'' EV''
     1)')ELECT+ENUCLR
      WRITE(6,'(    10X,''ELECTRONIC ENERGY       ='',F17.5,'' EV''
     1)')ELECT
      WRITE(6,'(    10X,''CORE-CORE REPULSION     ='',F17.5,'' EV''
     1)')ENUCLR
      IF(LATOM.EQ.0) WRITE(6,'(1X)')
      PRTGRA=(PRTGRA .OR. GNORM .GT. 2.D0)
      IF(PRTGRA)
     1WRITE(6,'(    10X,''GRADIENT NORM           ='',F17.5)')GNORM
      IF(LATOM.NE.0) THEN
C
C   WE NEED TO CALCULATE THE REACTION COORDINATE GRADIENT.
C
         MVAR=NVAR
         LOC11=LOC(1,1)
         LOC21=LOC(2,1)
         NVAR=1
         LOC(1,1)=LATOM
         LOC(2,1)=LPARAM
         XREACT=GEO(LPARAM,LATOM)
         CALL DERIV(GEO,GCOORD)
         NVAR=MVAR
         LOC(1,1)=LOC11
         LOC(2,1)=LOC21
         GRTYPE=' KCAL/ANGSTROM'
         IF(LPARAM.EQ.1)THEN
            WRITE(6,'(    10X,''FOR REACTION COORDINATE ='',F17.5
     1        ,'' ANGSTROMS'')')XREACT
         ELSE
            IF(NA(1).NE.99)GRTYPE=' KCAL/RADIAN  '
            WRITE(6,'(    10X,''FOR REACTION COORDINATE ='',F17.5
     1        ,'' DEGREES'')')XREACT*DEGREE
         ENDIF
         WRITE(6,'(    10X,''REACTION GRADIENT       ='',F17.5,A14
     1    )')GCOORD,GRTYPE
      ENDIF
      IF(NALPHA.GT.0)THEN
         EIONIS=-MAX(EIGS(NALPHA), EIGB(NBETA))
      ELSEIF(NELECS.EQ.1)THEN
         EIONIS=-EIGS(1)
      ELSEIF(NELECS.GT.1) THEN
         EIONIS=-MAX(EIGS(NCLOSE), EIGS(NOPEN))
      ELSE
         EIONIS=0.D0
      ENDIF
      NOPN=NOPEN-NCLOSE
C   CORRECTION TO I.P. OF DOUBLETS
      IF(NOPN.EQ.1)THEN
         I=NCLOSE*NORBS+1
         XIIII= SPCG(C(I),C(I),C(I),C(I),W,WJ)
         EIONIS=EIONIS+0.5D0*XIIII
      ENDIF
      WRITE(6,'(       10X,''IONIZATION POTENTIAL    ='',F17.5)')EIONIS
      IF( UHF ) THEN
         WRITE(6,'(      10X,''NO. OF ALPHA ELECTRONS  ='',I11)')NALPHA
         WRITE(6,'(      10X,''NO. OF BETA  ELECTRONS  ='',I11)')NBETA
      ELSE
         WRITE(6,'(      10X,''NO. OF FILLED LEVELS    ='',I11)')NCLOSE
         IF(NOPN.NE.0) THEN
            WRITE(6,'(   10X,''AND NO. OF OPEN LEVELS  ='',I11)')NOPN
         ENDIF
      ENDIF
      SUMW=0
      DO 10 I=1,NUMAT
   10 SUMW=SUMW+ATMASS(I)
      IF(SUMW.GT.0.1D0)
     1WRITE(6,'(    10X,''MOLECULAR WEIGHT        ='',F11.3)')SUMW
      IF(LATOM.EQ.0) WRITE(6,'(/)')
      WRITE(6,'(10X,''SCF CALCULATIONS  =   '',I14 )') NSCF
cmgc      TIM=SECOND()-TIME0
      I=TIM*0.000001D0
      TIM=TIM-I*1000000
      CALL TIMOUT(6,TIM)
      IF( NDEP .NE. 0 )CALL SYMTRY
      IF(NA(1).NE.99) THEN
         DO 50 J=1,NATOMS
            DO 50 I=1,3
               X=GEO(I,J)
               GOTO (40, 30, 20) I
   20          X=X - AINT(X/(2.D0*PI)+SIGN(0.4999D0,X)-0.0001D0)*PI*2.D0
               GEO(3,J)=X
               GOTO 40
   30          X=X - AINT(X/(2.D0*PI))*PI*2.D0
               IF(X.LT.0)X=X+PI*2.D0
               IF(X .GT. PI) THEN
                  GEO(3,J)=GEO(3,J)+PI
                  X=2.D0*PI-X
               ENDIF
               GEO(2,J)=X
   40          CONTINUE
   50    CONTINUE
      ENDIF
      DO 60 I=1,NVAR
   60 XPARAM(I)=GEO(LOC(2,I),LOC(1,I))
      CALL GMETRY(GEO,COORD)
      IF(PRTGRA)THEN
         WRITE(6,'(///7X,''FINAL  POINT  AND  DERIVATIVES'',/)')
         WRITE(6,'(''   PARAMETER     ATOM    TYPE  ''
     1    ,''          VALUE       GRADIENT'')')
      ENDIF
      SUM=0.5D0
      DO 70 I=1,NUMAT
   70 SUM=SUM+CORE(NAT(I))
      I=SUM
      KCHRGE=I-NCLOSE-NOPEN-NALPHA-NBETA
C
C    WRITE OUT THE GEOMETRIC VARIABLES
C
      IF(PRTGRA) THEN
         DO 80 I=1,NVAR
            J=LOC(2,I)
            K=LOC(1,I)
            L=LABELS(K)
            XI=XPARAM(I)
            IF(J.NE.1) XI=XI*DEGREE
            IF(J.EQ.1.OR.NA(1).EQ.99)THEN
               GTYPE='KCAL/ANGSTROM'
            ELSE
               GTYPE='KCAL/RADIAN  '
            ENDIF
   80    WRITE(6,'(I7,I11,1X,A2,4X,A11,F13.6,F13.6,2X,A13)')
     1I,K,ELEMNT(L),TYPE(J),XI,GRAD(I),GTYPE
      ENDIF
C
C     WRITE OUT THE GEOMETRY
C
      WRITE(6,'(///)')
      CALL GEOUT
      IF (INDEX(KEYWRD,'NOINTER') .EQ. 0) THEN
C
C   WRITE OUT THE INTERATOMIC DISTANCES
C
         L=0
         DO 90 I=1,NUMAT
            DO 90 J=1,I
               L=L+1
   90    RXYZ(L)=SQRT((COORD(1,I)-COORD(1,J))**2+
     1                         (COORD(2,I)-COORD(2,J))**2+
     2                         (COORD(3,I)-COORD(3,J))**2)
         WRITE(6,'(//10X,''  INTERATOMIC DISTANCES'')')
         CALL VECPRT(RXYZ,NUMAT)
      ENDIF
      DO 100 I=1,NORBS
  100 IF(EIGS(I).LT.-999.D0.OR.EIGS(I).GT.1000.D0)EIGS(I)=0.D0
      DO 110 I=1,NORBS
  110 IF(EIGB(I).LT.-999.D0.OR.EIGB(I).GT.1000.D0)EIGS(I)=0.D0
      IF(NORBS.GT.0)THEN
         IF (INDEX(KEYWRD,'VECT') .NE. 0) THEN
            WRITE(6,'(//10X,A5,'' EIGENVECTORS  '')')CALCN(IUHF)
            CALL MATOUT (C,EIGS,NORBS,NORBS,NORBS)
            IF(UHF) THEN
               WRITE(6,'(//10X,'' BETA EIGENVECTORS  '')')
               CALL MATOUT (CBETA,EIGB,NORBS,NORBS,NORBS)
            ENDIF
         ELSE
            WRITE(6,'(//10X,A5,''   EIGENVALUES'',/)')CALCN(IUHF)
            WRITE(6,'(8F10.5)')(EIGS(I),I=1,NORBS)
            IF(UHF) THEN
               WRITE(6,'(//10X,'' BETA EIGENVALUES '')')
               WRITE(6,'(8F10.5)')(EIGB(I),I=1,NORBS)
            ENDIF
         ENDIF
      ENDIF
      WRITE(6,'(//13X,'' NET ATOMIC CHARGES AND DIPOLE '',
     1''CONTRIBUTIONS'',/)')
      WRITE(6,'(8X,'' ATOM NO.   TYPE          CHARGE        ATOM''
     1,''  ELECTRON DENSITY'')')
      CALL CHRGE(P,Q)
      DO 120 I=1,NUMAT
         L=NAT(I)
         Q2(I)=CORE(L) - Q(I)
  120 WRITE(6,'(I12,9X,A2,4X,F13.4,F16.4)')
     1I,ELEMNT(L),Q2(I),Q(I)
      DIP= DIPOLE(P,Q2,COORD,DUMY)
      IF (INDEX(KEYWRD,'NOXYZ') .EQ. 0) THEN
         WRITE(6,'(//10X,''CARTESIAN COORDINATES '',/)')
         WRITE(6,'(4X,''NO.'',7X,''ATOM'',15X,''X'',
     1  9X,''Y'',9X,''Z'',/)')
         WRITE(6,'(I6,8X,A2,14X,3F10.4)')
     1  (I,ELEMNT(NAT(I)),(COORD(J,I),J=1,3),I=1,NUMAT)
      ENDIF
      IF(NORBS.GT.0) THEN
         IF (INDEX(KEYWRD,'FOCK') .NE. 0) THEN
            WRITE(6,'('' FOCK MATRIX IS '')')
            CALL VECPRT(F,NORBS)
         ENDIF
         IF (INDEX(KEYWRD,'DENSI') .NE. 0) THEN
            WRITE(6,'(//,20X,'' DENSITY MATRIX IS '')')
            CALL VECPRT(P,NORBS)
         ELSE
            WRITE(6,'(//10X,''ATOMIC ORBITAL ELECTRON POPULATIONS'',/)')
            WRITE(6,'(8F10.5)')(P((I*(I+1))/2),I=1,NORBS)
         ENDIF
         IF(INDEX(KEYWRD,' PI') .NE. 0) THEN
            WRITE(6,'(//10X,''SIGMA-PI BOND-ORDER MATRIX'')')
            CALL DENROT
         ENDIF
         IF(UHF) THEN
            SZ=ABS(NALPHA-NBETA)*0.5D0
            SS2=SZ*SZ
            L=0
            DO 140 I=1,NORBS
               DO 130 J=1,I
                  L=L+1
                  PA(L)=PA(L)-PB(L)
  130          SS2=SS2+PA(L)**2
  140       SS2=SS2-0.5D0*PA(L)**2
            WRITE(6,'(//20X,''(SZ)    ='',F10.6)')SZ
            WRITE(6,'(  20X,''(S**2)  ='',F10.6)')SS2
            IF(INDEX(KEYWRD,'SPIN') .NE. 0) THEN
               WRITE(6,'(//10X,''SPIN DENSITY MATRIX'')')
               CALL VECPRT(PA,NORBS)
            ELSE
               WRITE(6,'(//10X,''ATOMIC ORBITAL SPIN POPULATIONS'',/)')
               WRITE(6,'(8F10.5)')(PA((I*(I+1))/2),I=1,NORBS)
            ENDIF
            IF(INDEX(KEYWRD,'HYPERFINE') .NE. 0) THEN
C
C  WORK OUT THE HYPERFINE COUPLING CONSTANTS.
C
               WRITE(6,'(//10X,''    HYPERFINE COUPLING COEFFICIENTS'',/
     1)')
               J=(NALPHA-1)*NORBS
               DO 150 K=1,NUMAT
                  I=NFIRST(K)
C#          WRITE(6,'('' PA:'',F13.6,'' C('',I2,''+'',I3,''):'',
C#     +F13.5)')PA((I*(I+1))/2),I,J,C(I+J)
  150          Q(K)=PA((I*(I+1))/2)*0.3333333D0+C(I+J)**2*0.66666666D0
               WRITE(6,'(5(2X,A2,I2,F9.5,1X))')
     1    (ELEMNT(NAT(I)),I,Q(I),I=1,NUMAT)
            ENDIF
            DO 160 I=1,LINEAR
  160       PA(I)=P(I)-PB(I)
         ENDIF
         IF (INDEX(KEYWRD,'BONDS') .NE. 0) THEN
            IF(NBETA.EQ.0)THEN
               WRITE(6,'(/10X,''BONDING CONTRIBUTION OF EACH M.O.'',/)')
               CALL MOLVAL(C,NORBS,P,NORBS,2.D0)
            ELSE
               WRITE(6,'(/10X,''BONDING CONTRIBUTION OF EACH ALPHA M.O.'
     1',/)')
               CALL MOLVAL(C,NORBS,P,NORBS,1.D0)
               WRITE(6,'(/10X,''BONDING CONTRIBUTION OF EACH BETA  M.O.'
     1',/)')
               CALL MOLVAL(C,NORBS,P,NORBS,1.D0)
            ENDIF
            CALL BONDS(P)
         ENDIF
         I=NCLOSE+NALPHA
         IF (INDEX(KEYWRD,'LOCAL') .NE. 0) THEN
            CALL LOCAL(C,NORBS,I,EIGS)
            IF(NBETA.NE.0)THEN
               WRITE(6,'(//10X,'' LOCALIZED BETA MOLECULAR ORBITALS'')')
               CALL LOCAL(CBETA,NORBS,NBETA,EIGB)
            ENDIF
         ENDIF
         IF (INDEX(KEYWRD,'1ELE') .NE. 0) THEN
            WRITE(6,'('' FINAL ONE-ELECTRON MATRIX '')')
            CALL VECPRT(H,NORBS)
         ENDIF
         IF(INDEX(KEYWRD,'ENPART') .NE. 0)
     1CALL ENPART(UHF,H,PA,PB,P,Q,COORD)
      ENDIF
      DO 170 I=1,107
  170 NELEMT(I)=0
      DO 180 I=1,NUMAT
         IGO=NAT(I)
         IF (IGO.GT.107) GO TO 180
         NELEMT(IGO)=NELEMT(IGO)+1
  180 CONTINUE
      ICHFOR=0
      IF (NELEMT(6).EQ.0) GO TO 190
      ICHFOR=1
      IELEMT(1)=ELEMNT(6)
      NZS=NELEMT(6)
      IF (NZS.LT.10) THEN
         IF (NZS.EQ.1) THEN
            IEL1(1)=11
         ELSE
            IEL1(1)=NZS+1
         ENDIF
         IEL2(1)=11
      ELSE
         KFRST=NZS/10
         KSEC=NZS-(10*KFRST)
         IEL1(1)=KFRST+1
         IEL2(1)=KSEC+1
      ENDIF
  190 NELEMT(6)=0
      DO 200 I=1,107
         IF (NELEMT(I).EQ.0) GO TO 200
         ICHFOR=ICHFOR+1
         IELEMT(ICHFOR)=ELEMNT(I)
         NZS=NELEMT(I)
         IF (NZS.LT.10) THEN
            IF (NZS.EQ.1) THEN
               IEL1(ICHFOR)=11
            ELSE
               IEL1(ICHFOR)=NZS+1
            ENDIF
            IEL2(ICHFOR)=11
         ELSE
            KFRST=NZS/10
            KSEC=NZS-(10*KFRST)
            IEL1(ICHFOR)=KFRST+1
            IEL2(ICHFOR)=KSEC+1
         ENDIF
  200 CONTINUE
      IF(INDEX(KEYWRD,'DENOUT') .NE. 0) THEN
         OPEN(UNIT=10,FILE='FOR010',STATUS='UNKNOWN',FORM='UNFORMATTED')
         REWIND 10
         WRITE(10)(PA(I),I=1,LINEAR)
         IF(UHF)WRITE(10)(PB(I),I=1,LINEAR)
         CLOSE (10)
      ENDIF
      IF((CI.OR.NOPEN.NE.NCLOSE.OR.INDEX(KEYWRD,'SIZE').NE.0)
     1 .AND. INDEX(KEYWRD,'MECI')+INDEX(KEYWRD,'ESR').NE.0)THEN
         WRITE(6,'(//10X,
     1''MULTI-ELECTRON CONFIGURATION INTERACTION CALCULATION'',//)')
         NMOS=0
         NCIS=0
         IF(INDEX(KEYWRD,'C.I.=').NE.0)
     1      NMOS=READA(KEYWRD,INDEX(KEYWRD,'C.I.=')+5)
C
C   SET UP C.I. PARAMETERS
C   NMOS IS NO. OF M.O.S USED IN C.I.
C   NCIS IS CHANGE IN SPIN, OR NUMBER OF STATES
C
         IF(NMOS.EQ.0) NMOS=NOPEN-NCLOSE
         IF(NCIS.EQ.0) THEN
            IF(TRIPLT.OR.INDEX(KEYWRD,'QUAR').NE.0)NCIS=1
            IF(INDEX(KEYWRD,'QUIN')+INDEX(KEYWRD,'SEXT').NE.0)NCIS=2
         ENDIF
         X=MECI(EIGS,C,CBETA,EIGB, NORBS,NMOS,NCIS, .TRUE.)
      ENDIF
      IF (INDEX(KEYWRD,'MULLIK') +INDEX(KEYWRD,'GRAPH') .NE. 0) THEN
         IF (INDEX(KEYWRD,'MULLIK') .NE. 0)
     1   WRITE(6,'(/10X,'' MULLIKEN POPULATION ANALYSIS'')')
         IF (INDEX(KEYWRD,'GRAPH') .NE. 0)
     1   WRITE(6,'(/10X,'' DATA FOR GRAPH WRITTEN TO DISK'')')
         CALL MULLIK(C,CBETA,UHF,H,F,NORBS,P,RXYZ)
      ENDIF
C
C  NOTE THAT THE DENSITY, H AND F MATRICES ARE CORRUPTED BY A
C  CALL TO MULLIK.
      IF (ICALCN .NE. NUMCAL) THEN
         ICALCN = NUMCAL
         OPEN(UNIT=12,FILE='FOR012',STATUS='UNKNOWN')
         REWIND 12
      ENDIF
      IWRITE=12
      WRITE(IWRITE,'(//20X,'' SUMMARY OF '',A7,
     1'' CALCULATION'',/)')CALTYP
      WRITE(IWRITE,'(60X,''VERSION '',F5.2)')VERSON
      WRITE (IWRITE,210) (IELEMT(I),NUMBRS(IEL1(I)),NUMBRS(IEL2(I))
     1,I=1,ICHFOR)
  210 FORMAT (//,1X,17(A2,A1,A1))
      WRITE(IWRITE,'(55X,A24)')IDATE
      DO 220 IK=80,3,-1
  220 IF(KOMENT(IK:IK).NE.' ')GOTO 230
  230 WRITE(IWRITE,'(A)')KOMENT(:IK)
      DO 240 IT=80,3,-1
  240 IF(TITLE(IT:IT).NE.' ')GOTO 250
  250 WRITE(IWRITE,'(A)')TITLE(:IT)
      WRITE(IWRITE,'(//4X,A58)')FLEPO(IFLEPO)
      WRITE(IWRITE,'(4X,A58)')ITER(IITER)
      WRITE(IWRITE,'(//10X,''HEAT OF FORMATION       =''
     1,F17.6,'' KCAL'')')FUNCT
      WRITE(IWRITE,'(  10X,''ELECTRONIC ENERGY       =''
     1,F17.6,'' EV'')')ELECT
      WRITE(IWRITE,'(  10X,''CORE-CORE REPULSION     =''
     1,F17.6,'' EV'')')ENUCLR
      IF(PRTGRA)
     1WRITE(IWRITE,'(  10X,''GRADIENT NORM           =''
     2,F17.6)')GNORM
      IF(LATOM.NE.0) THEN
         GRTYPE=' KCAL/ANGSTROM'
         IF(LPARAM.EQ.1)THEN
            WRITE(IWRITE,'(    10X,''FOR REACTION COORDINATE ='',F17.4
     1        ,'' ANGSTROMS'')')XREACT
         ELSE
            IF(NA(1).NE.99)GRTYPE=' KCAL/RADIAN  '
            WRITE(IWRITE,'(    10X,''FOR REACTION COORDINATE ='',F17.4
     1        ,'' DEGREES'')')XREACT*DEGREE
         ENDIF
         WRITE(IWRITE,'(    10X,''REACTION GRADIENT       ='',F17.6,A14
     1    )')GCOORD,GRTYPE
      ENDIF
      WRITE(IWRITE,'(  10X,''DIPOLE                  =''
     1,F16.5, '' DEBYE'')')DIP
      IF(UHF) THEN
         WRITE(IWRITE,'(  10X,''(SZ)                    ='',F17.6)')SZ
         WRITE(IWRITE,'(  10X,''(S**2)                  ='',F17.6)')SS2
         WRITE(IWRITE,'(  10X,''NO. OF ALPHA ELECTRONS  ='',I10)')NALPHA
         WRITE(IWRITE,'(  10X,''NO. OF BETA  ELECTRONS  ='',I10)')NBETA
      ELSE
         WRITE(IWRITE,'(  10X,''NO. OF FILLED LEVELS    ='',I10)')NCLOSE
         NOPN=NOPEN-NCLOSE
         IF(NOPN.NE.0)
     1WRITE(IWRITE,'(  10X,''AND NO. OF OPEN LEVELS  ='',I10)')NOPN
      ENDIF
      IF(CI)
     1WRITE(IWRITE,'(  10X,''CONFIGURATION INTERACTION WAS USED'')')
      IF(KCHRGE.NE.0)
     1WRITE(IWRITE,'(  10X,''CHARGE ON SYSTEM        ='',I10)')KCHRGE
      WRITE(IWRITE,'(  10X,''IONIZATION POTENTIAL    =''
     1,F17.6,'' EV'')')EIONIS
      WRITE(IWRITE,'(  10X,''MOLECULAR WEIGHT        ='',F14.3)')SUMW
      WRITE(IWRITE,'(  10X,''SCF CALCULATIONS        =''
     1,I10)') NSCF
cmgc      TIM=SECOND()-TIME0
      CALL TIMOUT(IWRITE,TIM)
      WRITE(IWRITE,'(//10X,''FINAL GEOMETRY OBTAINED'',36X,''CHARGE'')')
      DO 260 I=80,3,-1
  260 IF(KEYWRD(I:I).NE.' ')GOTO 270
  270 WRITE(IWRITE,'(A)')KEYWRD(:I)
      WRITE(IWRITE,'(A)')KOMENT(:IK)
      WRITE(IWRITE,'(A)')TITLE(:IT)
      NA1=NA(1)
      IF(XYZ) CALL XYZINT(GEO,NATOMS,NA,NB,NC,1.D0,COORD)
      DEGREE=57.29577951D0
      COORD(2,1)=0.D0
      COORD(3,1)=0.D0
      COORD(1,1)=0.D0
      COORD(2,2)=0.D0
      COORD(3,2)=0.D0
      COORD(3,3)=0.D0
      IVAR=1
      NA(1)=0
      L=0
      DO 300 I=1,NATOMS
         DO 280 J=1,3
            IF(.NOT.XYZ)COORD(J,I)=GEO(J,I)
  280    IEL1(J)=0
  290    CONTINUE
         IF(LOC(1,IVAR).EQ.I) THEN
            IEL1(LOC(2,IVAR))=1
            IVAR=IVAR+1
            GOTO 290
         ENDIF
         IF(I.LT.4) THEN
            IEL1(3)=0
            IF(I.LT.3) THEN
               IEL1(2)=0
               IF(I.LT.2) THEN
                  IEL1(1)=0
               ENDIF
            ENDIF
         ENDIF
         IF(I.EQ.LATOM)IEL1(LPARAM)=-1
         Q(1)=COORD(1,I)
         Q(2)=COORD(2,I)*DEGREE
         Q(3)=COORD(3,I)*DEGREE
         IF(LABELS(I).NE.107.AND.LABELS(I).NE.99)THEN
            L=L+1
            WRITE(IWRITE,'(1X,A2,3(F12.6,I3),I5,2I5,F13.4)')
     1    ELEMNT(LABELS(I)),(Q(K),IEL1(K),K=1,3),NA(I),NB(I),NC(I),Q2(L)
         ELSE
            WRITE(IWRITE,'(1X,A2,3(F12.6,I3),I5,2I5,F13.4)')
     1    ELEMNT(LABELS(I)),(Q(K),IEL1(K),K=1,3),NA(I),NB(I),NC(I)
         ENDIF
  300 CONTINUE
      NA(1)=NA1
      I=0
      X=0.D0
      WRITE(IWRITE,'(I3,3(F12.6,I3),I5,2I5)')
     1    I,X,I,X,I,X,I,I,I,I
      DO 310 I=1,NDEP
  310 WRITE(IWRITE,'(3(I4,'',''))')LOCPAR(I),IDEPFN(I),LOCDEP(I)
      WRITE(IWRITE,'(///)')
      NSCF=0
      RETURN
      END
C
C***********************************************************************
C  TQL2
C***********************************************************************
C
      SUBROUTINE tql2 (NM,N,D,E,Z,IERR)
C
C     CALLED BY:
C                RSP
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION D(N),E(N),Z(NM,N)
      DOUBLE PRECISION B,C,F,G,H,P,R,S,MACHEP
C
C     REAL SQRT,ABS,SIGN
C
C     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE TQL2,
C     NUM. MATH. 11, 293-306(1968) BY BOWDLER, MARTIN, REINSCH, AND
C     WILKINSON.
C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 227-240(1971).
C
C     THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS
C     OF A SYMMETRIC TRIDIAGONAL MATRIX BY THE QL METHOD.
C     THE EIGENVECTORS OF A FULL SYMMETRIC MATRIX CAN ALSO
C     BE FOUND IF  TRED2  HAS BEEN USED TO REDUCE THIS
C     FULL MATRIX TO TRIDIAGONAL FORM.
C
C     ON INPUT-
C
C        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
C          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
C          DIMENSION STATEMENT,
C
C        N IS THE ORDER OF THE MATRIX,
C
C        D CONTAINS THE DIAGONAL ELEMENTS OF THE INPUT MATRIX,
C
C        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
C          IN ITS LAST N-1 POSITIONS.  E(1) IS ARBITRARY,
C
C        Z CONTAINS THE TRANSFORMATION MATRIX PRODUCED IN THE
C          REDUCTION BY  TRED2, IF PERFORMED.  IF THE EIGENVECTORS
C          OF THE TRIDIAGONAL MATRIX ARE DESIRED, Z MUST CONTAIN
C          THE IDENTITY MATRIX.
C
C      ON OUTPUT-
C
C        D CONTAINS THE EIGENVALUES IN ASCENDING ORDER.  IF AN
C          ERROR EXIT IS MADE, THE EIGENVALUES ARE CORRECT BUT
C          UNORDERED FOR INDICES 1,2,...,IERR-1,
C
C        E HAS BEEN DESTROYED,
C
C        Z CONTAINS ORTHONORMAL EIGENVECTORS OF THE SYMMETRIC
C          TRIDIAGONAL (OR FULL) MATRIX.  IF AN ERROR EXIT IS MADE,
C          Z CONTAINS THE EIGENVECTORS ASSOCIATED WITH THE STORED
C          EIGENVALUES,
C
C        IERR IS SET TO
C          ZERO       FOR NORMAL RETURN,
C          J          IF THE J-TH EIGENVALUE HAS NOT BEEN
C                     DETERMINED AFTER 30 ITERATIONS.
C
C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
C
C     ------------------------------------------------------------------
C
C                **********
C
      DATA ZERO,ONE,TWO / 0.0D0,1.0D0,2.0D0 /
C
C     ********** MACHEP IS A MACHINE DEPENDENT PARAMETER SPECIFYING
C                THE RELATIVE PRECISION OF FLOATING POINT ARITHMETIC.
C
C     MACHEP = TWO**(-46)
      MACHEP = TWO**(-45)                                               0519WH93
C
      IERR = 0
      IF (N.EQ.1) GO TO 160
C
      DO 10 I = 2, N
         E(I-1) = E(I)
   10 CONTINUE
C
      F = ZERO
      B = ZERO
      E(N) = ZERO
C
      DO 110 L = 1, N
         J = 0
         H = MACHEP*(ABS(D(L))+ABS(E(L)))
         IF (B.LT.H) B = H
C
C     ********** LOOK FOR SMALL SUB-DIAGONAL ELEMENT **********
C
         DO 20 M = L, N
            IF (ABS(E(M)).LE.B) GO TO 30
C
C     ********** E(N) IS ALWAYS ZERO, SO THERE IS NO EXIT
C                THROUGH THE BOTTOM OF THE LOOP **********
C
   20    CONTINUE
C
   30    IF (M.EQ.L) GO TO 100
   40    IF (J.EQ.30) GO TO 150
         J = J+1
C
C     ********** FORM SHIFT **********
C
         L1 = L+1
         G = D(L)
         P = (D(L1)-G)/(TWO*E(L))
C
C        R = SQRT(P*P+ONE)
C
         IF (ABS(P).GT.1.0D+16) THEN
            R = ABS(P)
         ELSE
            R = SQRT(P*P+ONE)
         ENDIF
         D(L) = E(L)/(P+SIGN(R,P))
         H = G-D(L)
C
         DO 50 I = L1, N
            D(I) = D(I)-H
   50    CONTINUE
C
         F = F+H
C
C     ********** QL TRANSFORMATION **********
C
         P = D(M)
         C = ONE
         S = ZERO
         MML = M-L
C
C     ********** FOR I=M-1 STEP -1 UNTIL L DO -- **********
C
         DO 90 II = 1, MML
            I = M-II
            G = C*E(I)
            H = C*P
            IF (ABS(P).LT.ABS(E(I))) GO TO 60
            C = E(I)/P
            R = SQRT(C*C+ONE)
            E(I+1) = S*P*R
            S = C/R
            C = ONE/R
            GO TO 70
   60       C = P/E(I)
            R = SQRT(C*C+ONE)
            E(I+1) = S*E(I)*R
            S = ONE/R
            C = C*S
   70       P = C*D(I)-S*G
            D(I+1) = H+S*(C*G+S*D(I))
C
C     ********** FORM VECTOR **********
C
            DO 80 K = 1, N
               H = Z(K,I+1)
               Z(K,I+1) = S*Z(K,I)+C*H
               Z(K,I) = C*Z(K,I)-S*H
   80       CONTINUE
C
   90    CONTINUE
C
         E(L) = S*P
         D(L) = C*P
         IF (ABS(E(L)).GT.B) GO TO 40
  100    D(L) = D(L)+F
  110 CONTINUE
C
C     ********** ORDER EIGENVALUES AND EIGENVECTORS **********
C
      DO 140 II = 2, N
         I = II-1
         K = I
         P = D(I)
C
         DO 120 J = II, N
            IF (D(J).GE.P) GO TO 120
            K = J
            P = D(J)
  120    CONTINUE
C
         IF (K.EQ.I) GO TO 140
         D(K) = D(I)
         D(I) = P
C
         DO 130 J = 1, N
            P = Z(J,I)
            Z(J,I) = Z(J,K)
            Z(J,K) = P
  130    CONTINUE
C
  140 CONTINUE
C
      GO TO 160
C
C     ********** SET ERROR -- NO CONVERGENCE TO AN
C                EIGENVALUE AFTER 30 ITERATIONS **********
C
  150 IERR = L
  160 RETURN
C
C     ********** LAST CARD OF TQL2 **********
C
      END
C
C***********************************************************************
C  TQLRAT
C***********************************************************************
C
      SUBROUTINE tqlrat (N,D,E2,IERR)
C
C     CALLED BY:
C                RSP
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION D(N),E2(N)
      DOUBLE PRECISION B,C,F,G,H,P,R,S,MACHEP
C
C     REAL SQRT,ABS,SIGN
C
C     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE TQLRAT,
C     ALGORITHM 464, COMM. ACM 16, 689(1973) BY REINSCH.
C
C     THIS SUBROUTINE FINDS THE EIGENVALUES OF A SYMMETRIC
C     TRIDIAGONAL MATRIX BY THE RATIONAL QL METHOD.
C
C     ON INPUT-
C
C        N IS THE ORDER OF THE MATRIX,
C
C        D CONTAINS THE DIAGONAL ELEMENTS OF THE INPUT MATRIX,
C
C        E2 CONTAINS THE SQUARES OF THE SUBDIAGONAL ELEMENTS OF THE
C          INPUT MATRIX IN ITS LAST N-1 POSITIONS.  E2(1) IS ARBITRARY.
C
C      ON OUTPUT-
C
C        D CONTAINS THE EIGENVALUES IN ASCENDING ORDER.  IF AN
C          ERROR EXIT IS MADE, THE EIGENVALUES ARE CORRECT AND
C          ORDERED FOR INDICES 1,2,...IERR-1, BUT MAY NOT BE
C          THE SMALLEST EIGENVALUES,
C
C        E2 HAS BEEN DESTROYED,
C
C        IERR IS SET TO
C          ZERO       FOR NORMAL RETURN,
C          J          IF THE J-TH EIGENVALUE HAS NOT BEEN
C                     DETERMINED AFTER 30 ITERATIONS.
C
C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
C
C     ------------------------------------------------------------------
C
C                **********
C
      DATA ZERO,ONE,TWO / 0.0D0,1.0D0,2.0D0 /
C
C     ********** MACHEP IS A MACHINE DEPENDENT PARAMETER SPECIFYING
C                THE RELATIVE PRECISION OF FLOATING POINT ARITHMETIC.
C
C     MACHEP = TWO**(-46)
      MACHEP = TWO**(-45)                                               0519WH93
C
      IERR = 0
      IF (N.EQ.1) GO TO 140
C
      DO 10 I = 2, N
         E2(I-1) = E2(I)
   10 CONTINUE
C
      F = ZERO
      B = ZERO
      E2(N) = ZERO
C
      DO 120 L = 1, N
         J = 0
         H = MACHEP*(ABS(D(L))+SQRT(E2(L)))
         IF (B.GT.H) GO TO 20
         B = H
         C = B*B
C
C     ********** LOOK FOR SMALL SQUARED SUB-DIAGONAL ELEMENT **********
C
   20    DO 30 M = L, N
            IF (E2(M).LE.C) GO TO 40
C
C     ********** E2(N) IS ALWAYS ZERO, SO THERE IS NO EXIT
C                THROUGH THE BOTTOM OF THE LOOP **********
C
   30    CONTINUE
C
   40    IF (M.EQ.L) GO TO 80
   50    IF (J.EQ.30) GO TO 130
         J = J+1
C
C     ********** FORM SHIFT **********
C
         L1 = L+1
         S = SQRT(E2(L))
         G = D(L)
         P = (D(L1)-G)/(TWO*S)
         R = SQRT(P*P+ONE)
         D(L) = S/(P+SIGN(R,P))
         H = G-D(L)
C
         DO 60 I = L1, N
            D(I) = D(I)-H
   60    CONTINUE
C
         F = F+H
C
C     ********** RATIONAL QL TRANSFORMATION **********
C
         G = D(M)
         IF (G.EQ.ZERO) G = B
         H = G
         S = ZERO
         MML = M-L
C
C     ********** FOR I=M-1 STEP -1 UNTIL L DO -- **********
C
         DO 70 II = 1, MML
            I = M-II
            P = G*H
            R = P+E2(I)
            E2(I+1) = S*R
            S = E2(I)/R
            D(I+1) = H+S*(H+D(I))
            G = D(I)-E2(I)/G
            IF (G.EQ.ZERO) G = B
            H = G*P/R
   70    CONTINUE
C
         E2(L) = S*G
         D(L) = H
C
C     ********** GUARD AGAINST UNDERFLOW IN CONVERGENCE TEST **********
C
         IF (H.EQ.ZERO) GO TO 80
         IF (ABS(E2(L)).LE.ABS(C/H)) GO TO 80
         E2(L) = H*E2(L)
         IF (E2(L).NE.ZERO) GO TO 50
   80    P = D(L)+F
C
C     ********** ORDER EIGENVALUES **********
C
         IF (L.EQ.1) GO TO 100
C
C     ********** FOR I=L STEP -1 UNTIL 2 DO -- **********
C
         DO 90 II = 2, L
            I = L+2-II
            IF (P.GE.D(I-1)) GO TO 110
            D(I) = D(I-1)
   90    CONTINUE
C
  100    I = 1
  110    D(I) = P
  120 CONTINUE
C
      GO TO 140
C
C     ********** SET ERROR -- NO CONVERGENCE TO AN
C                EIGENVALUE AFTER 30 ITERATIONS **********
C
  130 IERR = L
  140 RETURN
C
C     ********** LAST CARD OF TQLRAT **********
C
      END
C          
C***********************************************************************
C  TRBAK3
C***********************************************************************
C
      SUBROUTINE trbak3 (NM,N,NV,A,M,Z,IERR)
C
C     CALLED BY:
C                RSP
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION A(NV),Z(NM,M)
      DOUBLE PRECISION H,S
C
C     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE TRBAK3,
C     NUM. MATH. 11, 181-195(1968) BY MARTIN, REINSCH, AND WILKINSON.
C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 212-226(1971).
C
C     THIS SUBROUTINE FORMS THE EIGENVECTORS OF A REAL SYMMETRIC
C     MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
C     SYMMETRIC TRIDIAGONAL MATRIX DETERMINED BY  TRED3.
C
C     ON INPUT-
C
C        NM MUST BE SET TO THE ROW DIMENSION OF TWO-DIMENSIONAL
C          ARRAY PARAMETERS AS DECLARED IN THE CALLING PROGRAM
C          DIMENSION STATEMENT,
C
C        N IS THE ORDER OF THE MATRIX,
C
C        NV MUST BE SET TO THE DIMENSION OF THE ARRAY PARAMETER A
C          AS DECLARED IN THE CALLING PROGRAM DIMENSION STATEMENT,
C
C        A CONTAINS INFORMATION ABOUT THE ORTHOGONAL TRANSFORMATIONS
C          USED IN THE REDUCTION BY  TRED3  IN ITS FIRST
C          N*(N+1)/2 POSITIONS,
C
C        M IS THE NUMBER OF EIGENVECTORS TO BE BACK TRANSFORMED,
C
C        Z CONTAINS THE EIGENVECTORS TO BE BACK TRANSFORMED
C          IN ITS FIRST M COLUMNS.
C
C     ON OUTPUT-
C
C        Z CONTAINS THE TRANSFORMED EIGENVECTORS
C          IN ITS FIRST M COLUMNS.
C
C     NOTE THAT TRBAK3 PRESERVES VECTOR EUCLIDEAN NORMS.
C
C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
C
C     ------------------------------------------------------------------
C
      DATA ZERO / 0.0D0 /
      IF (M.EQ.0) GO TO 60
      IF (N.EQ.1) GO TO 60
C
      DO 50 I = 2, N
         L = I-1
         IZ = (I*L)/2
         IK = IZ+I
         H = A(IK)
         IF (H.EQ.ZERO) GO TO 50
C
         DO 40 J = 1, M
            S = ZERO
            IK = IZ
C
            DO 10 K = 1, L
               IK = IK+1
               S = S+A(IK)*Z(K,J)
   10       CONTINUE
C
C     ********** DOUBLE DIVISION AVOIDS POSSIBLE UNDERFLOW **********
C
            S = S/H
            IK = IZ
C
            DO 30 K = 1, L
               IK = IK+1
               IF (ABS(H).GT.1.0D0) GO TO 20
               SA = S*A(IK)
               IF (ABS(SA).LT.ABS(H)*1.6D+38) GO TO 20
               IERR = 1111
               RETURN
   20          CONTINUE
               Z(K,J) = Z(K,J)-S*A(IK)/H
   30       CONTINUE
C
   40    CONTINUE
C
   50 CONTINUE
C
   60 RETURN
C
C     ********** LAST CARD OF TRBAK3 **********
C
      END
C
C
C***********************************************************************
C  TRED3
C***********************************************************************
C
      SUBROUTINE tred3 (N,NV,A,D,E,E2)
C
C     CALLED BY:
C                 RSP
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION A(NV),D(N),E(N),E2(N)
      DOUBLE PRECISION F,G,H,HH,SCALE
C
C     REAL SQRT,ABS,SIGN
C
C     THIS SUBROUTINE IS A TRANSLATION OF THE ALGOL PROCEDURE TRED3,
C     NUM. MATH. 11, 181-195(1968) BY MARTIN, REINSCH, AND WILKINSON.
C     HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 212-226(1971).
C
C     THIS SUBROUTINE REDUCES A REAL SYMMETRIC MATRIX, STORED AS
C     A ONE-DIMENSIONAL ARRAY, TO A SYMMETRIC TRIDIAGONAL MATRIX
C     USING ORTHOGONAL SIMILARITY TRANSFORMATIONS.
C
C     ON INPUT-
C
C        N IS THE ORDER OF THE MATRIX,
C
C        NV MUST BE SET TO THE DIMENSION OF THE ARRAY PARAMETER A
C          AS DECLARED IN THE CALLING PROGRAM DIMENSION STATEMENT,
C
C        A CONTAINS THE LOWER TRIANGLE OF THE REAL SYMMETRIC
C          INPUT MATRIX, STORED ROW-WISE AS A ONE-DIMENSIONAL
C          ARRAY, IN ITS FIRST N*(N+1)/2 POSITIONS.
C
C     ON OUTPUT-
C
C        A CONTAINS INFORMATION ABOUT THE ORTHOGONAL
C          TRANSFORMATIONS USED IN THE REDUCTION,
C
C        D CONTAINS THE DIAGONAL ELEMENTS OF THE TRIDIAGONAL MATRIX,
C
C        E CONTAINS THE SUBDIAGONAL ELEMENTS OF THE TRIDIAGONAL
C          MATRIX IN ITS LAST N-1 POSITIONS.  E(1) IS SET TO ZERO,
C
C        E2 CONTAINS THE SQUARES OF THE CORRESPONDING ELEMENTS OF E.
C          E2 MAY COINCIDE WITH E IF THE SQUARES ARE NOT NEEDED.
C
C     QUESTIONS AND COMMENTS SHOULD BE DIRECTED TO B. S. GARBOW,
C     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY
C
C     ------------------------------------------------------------------
C
C     ********** FOR I=N STEP -1 UNTIL 1 DO -- **********
C
      DATA ZERO / 0.0D0 /
      DO 90 II = 1, N
         I = N+1-II
         L = I-1
         IZ = (I*L)/2
         H = ZERO
         SCALE = ZERO
         IF (L.LT.1) GO TO 20
C
C     ********** SCALE ROW (ALGOL TOL THEN NOT NEEDED) **********
C
         DO 10 K = 1, L
            IZ = IZ+1
            D(K) = A(IZ)
            SCALE = SCALE+ABS(D(K))
   10    CONTINUE
C
         IF (SCALE.NE.ZERO) GO TO 30
   20    E(I) = ZERO
         E2(I) = ZERO
         GO TO 80
C
   30    DO 40 K = 1, L
            D(K) = D(K)/SCALE
            H = H+D(K)*D(K)
   40    CONTINUE
C
         E2(I) = SCALE*SCALE*H
         F = D(L)
         G = -SIGN(SQRT(H),F)
         E(I) = SCALE*G
         H = H-F*G
         D(L) = F-G
         A(IZ) = SCALE*D(L)
         IF (L.EQ.1) GO TO 80
         F = ZERO
C
         DO 60 J = 1, L
            G = ZERO
            JK = (J*(J-1))/2
C
C     ********** FORM ELEMENT OF A*U **********
C
            DO 50 K = 1, L
               JK = JK+1
               IF (K.GT.J) JK = JK+K-2
               G = G+A(JK)*D(K)
   50       CONTINUE
C
C     ********** FORM ELEMENT OF P **********
C
            E(J) = G/H
            F = F+E(J)*D(J)
   60    CONTINUE
C
         HH = F/(H+H)
         JK = 0
C
C     ********** FORM REDUCED A **********
C
         DO 70 J = 1, L
            F = D(J)
            G = E(J)-HH*F
            E(J) = G
C
            DO 70 K = 1, J
               JK = JK+1
               A(JK) = A(JK)-F*E(K)-G*D(K)
   70    CONTINUE
C
   80    D(I) = A(IZ+1)
         A(IZ+1) = SCALE*SQRT(H)
   90 CONTINUE
C
      RETURN
C
C     ********** LAST CARD OF TRED3 **********
C
      END

C ***********************************************************************
c     below are math routines needed for prjfc. they are basicly just
c     matrix diagonalization routines and should at some point be replaced
c     with the diagonalization routine used in the rest of the program.
c     the routines below have been lifted from GAMESS
C ***********************************************************************

      SUBROUTINE DGEDI(A,LDA,N,IPVT,DET,WORK,JOB)                       
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(LDA,*),DET(2),WORK(*),IPVT(*)                         
C                                                                       
C     DGEDI COMPUTES THE DETERMINANT AND INVERSE OF A MATRIX            
C     USING THE FACTORS COMPUTED BY DGECO OR DGEFA.                     
C                                                                       
C     ON ENTRY                                                          
C                                                                       
C        A       DOUBLE PRECISION(LDA, N)                               
C                THE OUTPUT FROM DGECO OR DGEFA.                        
C                                                                       
C        LDA     INTEGER                                                
C                THE LEADING DIMENSION OF THE ARRAY  A .                
C                                                                       
C        N       INTEGER                                                
C                THE ORDER OF THE MATRIX  A .                           
C                                                                       
C        IPVT    INTEGER(N)                                             
C                THE PIVOT VECTOR FROM DGECO OR DGEFA.                  
C                                                                       
C        WORK    DOUBLE PRECISION(N)                                    
C                WORK VECTOR.  CONTENTS DESTROYED.                      
C                                                                       
C        JOB     INTEGER                                                
C                = 11   BOTH DETERMINANT AND INVERSE.                   
C                = 01   INVERSE ONLY.                                   
C                = 10   DETERMINANT ONLY.                               
C                                                                       
C     ON RETURN                                                         
C                                                                       
C        A       INVERSE OF ORIGINAL MATRIX IF REQUESTED.               
C                OTHERWISE UNCHANGED.                                   
C                                                                       
C        DET     DOUBLE PRECISION(2)                                    
C                DETERMINANT OF ORIGINAL MATRIX IF REQUESTED.           
C                OTHERWISE NOT REFERENCED.                              
C                DETERMINANT = DET(1) * 10.0**DET(2)                    
C                WITH  1.0 .LE. ABS(DET(1)) .LT. 10.0                   
C                OR  DET(1) .EQ. 0.0 .                                  
C                                                                       
C     ERROR CONDITION                                                   
C                                                                       
C        A DIVISION BY ZERO WILL OCCUR IF THE INPUT FACTOR CONTAINS     
C        A ZERO ON THE DIAGONAL AND THE INVERSE IS REQUESTED.           
C        IT WILL NOT OCCUR IF THE SUBROUTINES ARE CALLED CORRECTLY      
C        AND IF DGECO HAS SET RCOND .GT. 0.0 OR DGEFA HAS SET           
C        INFO .EQ. 0 .                                                  
C                                                                       
C     LINPACK. THIS VERSION DATED 08/14/78 .                            
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.      
C                                                                       
C     SUBROUTINES AND FUNCTIONS                                         
C                                                                       
C     BLAS DAXPY,DSCAL,DSWAP                                            
C     FORTRAN ABS,MOD                                                   
C                                                                       
C     COMPUTE DETERMINANT                                               
C                                                                       
      IF (JOB/10 .EQ. 0) GO TO 70                                       
         DET(1) = 1.0D+00                                               
         DET(2) = 0.0D+00                                               
         TEN = 10.0D+00                                                 
         DO 50 I = 1, N                                                 
            IF (IPVT(I) .NE. I) DET(1) = -DET(1)                        
            DET(1) = A(I,I)*DET(1)                                      
C        ...EXIT                                                        
            IF (DET(1) .EQ. 0.0D+00) GO TO 60                           
   10       IF (ABS(DET(1)) .GE. 1.0D+00) GO TO 20                      
               DET(1) = TEN*DET(1)                                      
               DET(2) = DET(2) - 1.0D+00                                
            GO TO 10                                                    
   20       CONTINUE                                                    
   30       IF (ABS(DET(1)) .LT. TEN) GO TO 40                          
               DET(1) = DET(1)/TEN                                      
               DET(2) = DET(2) + 1.0D+00                                
            GO TO 30                                                    
   40       CONTINUE                                                    
   50    CONTINUE                                                       
   60    CONTINUE                                                       
   70 CONTINUE                                                          
C                                                                       
C     COMPUTE INVERSE(U)                                                
C                                                                       
      IF (MOD(JOB,10) .EQ. 0) GO TO 150                                 
         DO 100 K = 1, N                                                
            A(K,K) = 1.0D+00/A(K,K)                                     
            T = -A(K,K)                                                 
            CALL DSCAL(K-1,T,A(1,K),1)                                  
            KP1 = K + 1                                                 
            IF (N .LT. KP1) GO TO 90                                    
            DO 80 J = KP1, N                                            
               T = A(K,J)                                               
               A(K,J) = 0.0D+00                                         
               CALL DAXPY(K,T,A(1,K),1,A(1,J),1)                        
   80       CONTINUE                                                    
   90       CONTINUE                                                    
  100    CONTINUE                                                       
C                                                                       
C        FORM INVERSE(U)*INVERSE(L)                                     
C                                                                       
         NM1 = N - 1                                                    
         IF (NM1 .LT. 1) GO TO 140                                      
         DO 130 KB = 1, NM1                                             
            K = N - KB                                                  
            KP1 = K + 1                                                 
            DO 110 I = KP1, N                                           
               WORK(I) = A(I,K)                                         
               A(I,K) = 0.0D+00                                         
  110       CONTINUE                                                    
            DO 120 J = KP1, N                                           
               T = WORK(J)                                              
               CALL DAXPY(N,T,A(1,J),1,A(1,K),1)                        
  120       CONTINUE                                                    
            L = IPVT(K)                                                 
            IF (L .NE. K) CALL DSWAP(N,A(1,K),1,A(1,L),1)               
  130    CONTINUE                                                       
  140    CONTINUE                                                       
  150 CONTINUE                                                          
      RETURN                                                            
      END                                                               
      SUBROUTINE DGEFA(A,LDA,N,IPVT,INFO)                               
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(LDA,*),IPVT(*)                                        
C                                                                       
C     DGEFA FACTORS A DOUBLE PRECISION MATRIX BY GAUSSIAN ELIMINATION.  
C                                                                       
C     DGEFA IS USUALLY CALLED BY DGECO, BUT IT CAN BE CALLED            
C     DIRECTLY WITH A SAVING IN TIME IF  RCOND  IS NOT NEEDED.          
C     (TIME FOR DGECO) = (1 + 9/N)*(TIME FOR DGEFA) .                   
C                                                                       
C     ON ENTRY                                                          
C                                                                       
C        A       DOUBLE PRECISION(LDA, N)                               
C                THE MATRIX TO BE FACTORED.                             
C                                                                       
C        LDA     INTEGER                                                
C                THE LEADING DIMENSION OF THE ARRAY  A .                
C                                                                       
C        N       INTEGER                                                
C                THE ORDER OF THE MATRIX  A .                           
C                                                                       
C     ON RETURN                                                         
C                                                                       
C        A       AN UPPER TRIANGULAR MATRIX AND THE MULTIPLIERS         
C                WHICH WERE USED TO OBTAIN IT.                          
C                THE FACTORIZATION CAN BE WRITTEN  A = L*U  WHERE       
C                L  IS A PRODUCT OF PERMUTATION AND UNIT LOWER          
C                TRIANGULAR MATRICES AND  U  IS UPPER TRIANGULAR.       
C                                                                       
C        IPVT    INTEGER(N)                                             
C                AN INTEGER VECTOR OF PIVOT INDICES.                    
C                                                                       
C        INFO    INTEGER                                                
C                = 0  NORMAL VALUE.                                     
C                = K  IF  U(K,K) .EQ. 0.0 .  THIS IS NOT AN ERROR       
C                     CONDITION FOR THIS SUBROUTINE, BUT IT DOES        
C                     INDICATE THAT DGESL OR DGEDI WILL DIVIDE BY ZERO  
C                     IF CALLED.  USE  RCOND  IN DGECO FOR A RELIABLE   
C                     INDICATION OF SINGULARITY.                        
C                                                                       
C     LINPACK. THIS VERSION DATED 08/14/78 .                            
C     CLEVE MOLER, UNIVERSITY OF NEW MEXICO, ARGONNE NATIONAL LAB.      
C                                                                       
C     SUBROUTINES AND FUNCTIONS                                         
C                                                                       
C     BLAS DAXPY,DSCAL,IDAMAX                                           
C                                                                       
C     GAUSSIAN ELIMINATION WITH PARTIAL PIVOTING                        
C                                                                       
      INFO = 0                                                          
      NM1 = N - 1                                                       
      IF (NM1 .LT. 1) GO TO 70                                          
      DO 60 K = 1, NM1                                                  
         KP1 = K + 1                                                    
C                                                                       
C        FIND L = PIVOT INDEX                                           
C                                                                       
         L = IDAMAX(N-K+1,A(K,K),1) + K - 1                             
         IPVT(K) = L                                                    
C                                                                       
C        ZERO PIVOT IMPLIES THIS COLUMN ALREADY TRIANGULARIZED          
C                                                                       
         IF (A(L,K) .EQ. 0.0D+00) GO TO 40                              
C                                                                       
C           INTERCHANGE IF NECESSARY                                    
C                                                                       
            IF (L .EQ. K) GO TO 10                                      
               T = A(L,K)                                               
               A(L,K) = A(K,K)                                          
               A(K,K) = T                                               
   10       CONTINUE                                                    
C                                                                       
C           COMPUTE MULTIPLIERS                                         
C                                                                       
            T = -1.0D+00/A(K,K)                                         
            CALL DSCAL(N-K,T,A(K+1,K),1)                                
C                                                                       
C           ROW ELIMINATION WITH COLUMN INDEXING                        
C                                                                       
            DO 30 J = KP1, N                                            
               T = A(L,J)                                               
               IF (L .EQ. K) GO TO 20                                   
                  A(L,J) = A(K,J)                                       
                  A(K,J) = T                                            
   20          CONTINUE                                                 
               CALL DAXPY(N-K,T,A(K+1,K),1,A(K+1,J),1)                  
   30       CONTINUE                                                    
         GO TO 50                                                       
   40    CONTINUE                                                       
            INFO = K                                                    
   50    CONTINUE                                                       
   60 CONTINUE                                                          
   70 CONTINUE                                                          
      IPVT(N) = N                                                       
      IF (A(N,N) .EQ. 0.0D+00) INFO = N                                 
      RETURN                                                            
      END                                                               



