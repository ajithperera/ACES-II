      SUBROUTINE OSL2IAD(L,T,T1,G,T1A,T1B,ISPIN,VRTT1,VRTT2,
     $   VRTL1,VRTL2,POPT1,POPT2,NVRTSQ,
     $   DISSYW,DISSYT,NUMSYW,NUMSYT,LISTL,LISTT,IRREP,TMP,FACT,STRING)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      DOUBLE PRECISION L
      CHARACTER*4 STRING
      INTEGER DISSYT,DISSYW,DIRPRD,VRTT1,VRTL1,VRTL2,POPT1,POPT2,VRTT2
      DIMENSION L(NUMSYW,DISSYW),T(NUMSYT,DISSYT),G(NVRTSQ)
      DIMENSION T1(DISSYW,NUMSYW),TMP(*)
      DIMENSION VRTT1(8),VRTL1(8),VRTL2(8),POPT1(8),POPT2(8),VRTT2(8)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
C
      DATA ONE,ONEM,TWO,HALF /1.0D0,-1.0D0,2.0D0,0.5D0/
C
       CALL FSGET(T1,1,NUMSYW,2,IRREP,LISTL,STRING)
       CALL TRANSP(T1,L,NUMSYW,DISSYW)
C
       CALL ZERO(T1,NUMSYT*DISSYT)
       IF(ISPIN.EQ.1) THEN
          CALL FTAU(T1,T1A,T1B,DISSYT,NUMSYT,POPT1,POPT2,VRTT1,VRTT2,
     $      IRREP,3,ONE)
       ELSE
          CALL FTAU(T1,T1B,T1A,DISSYT,NUMSYT,POPT2,POPT1,VRTT2,VRTT1,
     $      IRREP,3,ONE)
       ENDIF
       CALL TRANSP(T1,T,NUMSYT,DISSYT)
C
      IF(ISPIN.EQ.2) THEN
         CALL SYMTR1(IRREP,VRTL1,VRTL2,NUMSYW,L,TMP,TMP(1+NUMSYW),
     &      TMP(1+2*NUMSYW))
      ENDIF
C
      IOFF=1
      JOFFT=1
      JOFFL=1
      DO 90 IRREPI=1,NIRREP
C          
         NVRTL=VRTL1(IRREPI)
         NVRTT=VRTT2(IRREPI)
C     
         IRREPJ=DIRPRD(IRREP,IRREPI)
         NVRTJ=VRTL2(IRREPJ)
C
         IF(MIN(NVRTJ,NVRTT,NVRTL).NE.0) THEN
            CALL XGEMM('T','N',NVRTT,NVRTL,NUMSYW*NVRTJ,FACT*ONEM,
     &         T(1,JOFFT),NVRTJ*NUMSYW,L(1,JOFFL),
     &         NVRTJ*NUMSYW,ONE,G(IOFF),NVRTT)
         ENDIF
C
         JOFFL=JOFFL+NVRTJ*NVRTL
         JOFFT=JOFFT+NVRTJ*NVRTT
         IOFF=IOFF+NVRTT*NVRTL
 90   CONTINUE
C
      RETURN
      END
