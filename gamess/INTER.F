c reading MOL file generated by ACES (xjoda);
c on entry::
c IO: no.of I/O channel used by the MOL file;
c ISOPEN: .true. if MOL is open while calling GETINF
c IOUT: no. of I/O channel for GAMESS interface log messages

      subroutine GETINF (io,isopen,iout)
      implicit double precision (a-h,o-z)
c maximum number of shells, primitives, orbitals, and atoms
#include "gamess.par"
      PARAMETER (mxpriL=200,mxorbL=20)

      dimension iorder(mxao),coeint(mxao),nAfrst(mxsh),nAstep(mxsh)
      dimension atpos(3,mxatm),exps(mxgtot),coex(mxgtot,0:4)
      dimension kfrst(mxsh),klast(mxsh),katoms(mxsh),kangu(mxsh)
      dimension inL(10),exp(mxpriL),coe(mxpriL,mxorbL)
      logical isopen,sphrcl
      character*4 name
      character*52 string
      data tm6,tiny,zero,one /1.d-6, 1.d-20, 0.d0, 1.d0/
      data half,pt75,pt187,pt6562 /0.5d0, 0.75d0, 1.875d0, 6.5625d0/
      data pi32 / 5.568327996831707d0  /      

      if (.not.isopen) open (io,file='MOL')
      rewind (io)
      read (io,'(a,i6)') string,icart
      sphrcl=.true.
      if (icart.eq.1) sphrcl=.false.
      read (io,*) 
      read (io,*) 
      read (io,*) nats,idummy,cutoff
      read (io,*)

      nshls=0
      nbas=0
      nprims=0
      do 10 nat=1,nats
         read (io,*) Z,idummy,nofLs,(inL(i),i=1,nofLs)
         if (nofLs.gt.5) then
            write (*,*) '@GETINF: FUNCTIONS ABOVE G ARE NOT SUPPORTED'
            call aces_exit(1)
         end if
         read (io,'(a4,3f20.12)') name,x,y,z
         atpos(1,nat)=x
         atpos(2,nat)=y
         atpos(3,nat)=z

         do 100 L=1,nofLs
         Lcurr=L-1
         nshinL=0
         nbas1=nbas+1
         do 101 LL=1,inL(L)
            read (io,*) npri,norb
            if (npri.gt.mxpriL) then
               write (*,'(a,i5)') 
     >               '@GETINF: MAX ALLOWED NO.OF PRIMITIVES PER BLOCK:',
     >               mxpriL
               call aces_exit(1) 
            end if
            if (norb.gt.mxorbL) then
               write (*,'(a,i5)') 
     >               '@GETINF: MAX ALLOWED NO.OF SHELLS PER BLOCK:',
     >               mxorbL
               call aces_exit(1)
            end if
            do 110 i=1,npri
 110        read (io,*) exp(i),(coe(i,j),j=1,norb)

            do 200 j=1,norb
               nfirst=nprims+1
               do 210 i=1,npri
                  if (abs(coe(i,j)).lt.tiny) goto 210
                  nprims=nprims+1
                  exps(nprims)=exp(i)
                  do 220 lx=0,4
 220              coex(nprims,lx)=zero
                  coex(nprims,Lcurr)=coe(i,j)
 210           continue
               nlast=nprims
               if (nlast.ge.nfirst) then
                  nshinL=nshinL+1
                  nshls=nshls+1
                  nbas=nbas +((Lcurr+1)*(Lcurr+2))/2
                  kfrst(nshls)=nfirst
                  klast(nshls)=nlast
                  katoms(nshls)=nat
                  kangu(nshls)=Lcurr
               else
                  write (*,*) '@GETINF: ZERO SHELL ENCOUNTERED'
                  call aces_exit(1)
               end if
 200        continue

 101     continue
         if (nshinL.gt.0) 
     >     call setord (nbas1,Lcurr,nshinL,iorder,coeint,nAfrst,nAstep)
 100     continue
 10   continue

      if (.not.isopen) close (io)

c renormalization
      do 300 nsh=1,nshls
         nfirst=kfrst(nsh)
         nlast=klast(nsh)
         nat=katoms(nsh)

c de-normalization of primitives
         do 310 npri=nfirst,nlast
            ee=exps(npri)+exps(npri)
            ee2=ee*ee
            facs = pi32/(ee*sqrt(ee))
            facp = half*facs/ee
            facd = pt75*facs/ee2
            facf = pt187*facs/(ee2*ee)
            facg = pt6562*facs/(ee2*ee2)
            coex(npri,0) = coex(npri,0)/sqrt(facs)
            coex(npri,1) = coex(npri,1)/sqrt(facp)
            coex(npri,2) = coex(npri,2)/sqrt(facd)
            coex(npri,3) = coex(npri,3)/sqrt(facf)
            coex(npri,4) = coex(npri,4)/sqrt(facg)
 310     continue

c normalization of basis functions
         facs = zero
         facp = zero
         facd = zero
         facf = zero
         facg = zero
         do 320 npri1 = nfirst,nlast
            do 320 npri2 = nfirst,npri1
               ee = exps(npri1)+exps(npri2)
               ee2=ee*ee
               fac = ee*sqrt(ee)
               dums = coex(npri1,0)*coex(npri2,0)/fac
               dump = half*coex(npri1,1)*coex(npri2,1)/(ee*fac)
               dumd = pt75*coex(npri1,2)*coex(npri2,2)/(ee2*fac)
               dumf = pt187*coex(npri1,3)*coex(npri2,3)/(ee2*ee*fac)
               dumg = pt6562*coex(npri1,4)*coex(npri2,4)/(ee2*ee2*fac)
               if(npri1 .ne. npri2) then
                  dums = dums+dums
                  dump = dump+dump
                  dumd = dumd+dumd
                  dumf = dumf+dumf
                  dumg = dumg+dumg
               end if
               facs = facs+dums
               facp = facp+dump
               facd = facd+dumd
               facf = facf+dumf
               facg = facg+dumg
 320     continue
         if(facs .lt. tiny) then
            facs=zero
         else
            facs = one/sqrt(facs*pi32)
            if(abs(facs-one).gt.tm6) write(iout,1000) nat,nsh,'S',facs
         end if
         if(facp .lt. tiny) then
            facp=zero
         else
            facp = one/sqrt(facp*pi32)
            if(abs(facp-one).gt.tm6) write(iout,1000) nat,nsh,'P',facp
         end if
         if(facd .lt. tiny) then
            facd=zero
         else
            facd = one/sqrt(facd*pi32)
            if(abs(facd-one).gt.tm6) write(iout,1000) nat,nsh,'D',facd
         end if
         if(facf .lt. tiny) then
            facf=zero
         else
            facf = one/sqrt(facf*pi32)
            if(abs(facf-one).gt.tm6) write(iout,1000) nat,nsh,'F',facf
         end if
         if(facg .lt. tiny) then
            facg=zero
         else
            facg = one/sqrt(facg*pi32)
            if(abs(facg-one).gt.tm6) write(iout,1000) nat,nsh,'G',facg
         end if
         do 330 npri = nfirst,nlast
            coex(npri,0) = coex(npri,0) * facs
            coex(npri,1) = coex(npri,1) * facp
            coex(npri,2) = coex(npri,2) * facd
            coex(npri,3) = coex(npri,3) * facf
            coex(npri,4) = coex(npri,4) * facg
 330     continue

 300  continue

      call GAMINI (sphrcl,nats,atpos,  nprims,exps,
     >           coex(1,0),coex(1,1),coex(1,2),coex(1,3),coex(1,4),
     >           nshls,kfrst,klast,katoms,kangu,
     >           iorder,coeint,nAfrst,nAstep,cutoff,iout )
 1000 format (1X,'*** WARNING! ATOM',I4,' SHELL',I5,' TYPE ',A1,
     >       ' HAS NORMALIZATION',F13.8)
      end
c--------------------------------------------------------------------------
c GAMESS integrals for one shell quadruplet (ish,jsh,ksh,lsh)
c (a modified internal part of TWOEI)
c IMPORTANT!!!
c GAMESS defines the shell as a set of AO's differing only in the angular 
c part; for example, a single column of contraction coefficients in the
c L=1 block of ACES' MOL file defines a shell of 3 "p" orbitals, but 
c another column in the same block (if present) defines a different shell,
c because contraction coefficients are different.  The numbering of shells
c follows from
c "order of atoms -> order of L-blocks -> order of columns"
c in MOL.  Evidently, all calls to GAMINT must adhere to this convention
c or a mess will occur.
c
c -----on entry-----
c ish,jsh,ksh,lsh: shell numbers
c iexch: 1,2,or 3 (currently not used)
c qq4x: symmetry coefficient for this quadruplet (always 1 in C1 group)
c ghondo: integral buffer, should be declared at least MAXG=NANGM**4,
c   where NANGM depends on the highest angular momentum in the basis set
c   (4 for s or p, 6 for d, 10 for f, 15 for g)
c ddij: density buffer, should be at least 16*MXGSH*MXGSH (MXGSH=30) 
c pople: if .true., use Pople algorithm (if possible) for s,p integrals
c   (currently not used)
c nosame: if .true., do NOT use the supersymmetry i<->k, j<->l, i.e.
c     do calculate the pertinent equal integrals twice
c noflip: if .true.,  never internally flip shells i<->j or k<->l
c     (preserve the original shell index order, perhaps with a minor
c      performance penalty)
c ijgt, klgt: buffers, at least 225 each
c loci,locj,lock,locl: buffers, at least 15 each
c -----on exit-----
c ish,jsh,ksh,lsh: shell numbers (in general, permuted wrt entry!!!)
c done: if .false., the quadruplet was skipped (ghondo empty)
c ghondo: integral values
c pople: if .true., Pople WAS used
c iandj=.true. if ish=jsh,  same=.true. if (ish=ksh and jsh=lsh)
c    (the original values of ish,jsh,ksh,lsh)
c ijind(ijn)+klind(kln): index in ghondo where the integral (ijn,kln) is
c    (see code for explanation of ijn,kln)  
c nofi,...,nofl: number of orbitals in (new) shell ish,...,lsh
c nbai(i): numbers of basis function corresponding to i-th orbital in shell
c    with the (new) number ish; similarly nbaj for shell jsh etc.

      subroutine GAMINT (ish,jsh,ksh,lsh,iexch,qq4x, done,
     >           ghondo,ddij,pople, nosame,noflip,
     >           iandjx,kandlx,samex,nofi,nofj,nofk,nofl,
     >           ijind,klind,nbai,nbaj,nbak,nbal)
      implicit double precision (a-h,o-z)
#include "gamess.par"
      dimension ghondo(*),ddij(*)
      dimension ijind(*),klind(*),nbai(*),nbaj(*),nbak(*),nbal(*)
      logical done,pople, nosame,noflip,flip
      logical IANDJ,KANDL,SAME, iandjx,kandlx,samex
      dimension norgp(3)
      common /shtrue/ inu,jnu,knu,lnu
      common /zmins/ zminx(mxsh)
      COMMON /xGOUT  / GPOPLE(768),NORG
      COMMON /xINTDEX/ IJGT(784),IJX(784),IJY(784),IJZ(784),IK(784),
     >                KLGT(784),KLX(784),KLY(784),KLZ(784)
      COMMON /xMISC  / IANDJ,KANDL,SAME
      COMMON /xNSHEL / EX(MXGTOT),CS(MXGTOT),CP(MXGTOT),CD(MXGTOT),
     >                CF(MXGTOT),CG(MXGTOT),
     >                KSTART(MXSH),KATOM(MXSH),KTYPE(MXSH),KNG(MXSH),
     >                KLOC(MXSH),KMIN(MXSH),KMAX(MXSH),NSHELL
      COMMON /xSHLNOS/ QQ4,LIT,LJT,LKT,LLT,LOCI,LOCJ,LOCK,LOCL,
     >                MINI,MINJ,MINK,MINL,MAXI,MAXJ,MAXK,MAXL,
     >                NIJ,IJ,KL,IJKL
      data norgp /0,256,512/

      flip=.not.noflip
      done=.false.
      zthrsh=0.1d0
      zmin=min( zminx(ish),zminx(jsh),zminx(ksh),zminx(lsh) )
      if (ktype(ish).gt.2) pople=.false.
      if (ktype(jsh).gt.2) pople=.false.
      if (ktype(ksh).gt.2) pople=.false.
      if (ktype(lsh).gt.2) pople=.false.
      if (zmin.lt.zthrsh) pople=.false.
      QQ4=qq4x

c! temporary workaround
      pople=.false.

      if (pople) then
         norg=norgp(iexch)
         call xGENR70 (iexch,.false.)
      else
         norg=0
#if defined(_CRAY_NV1) && 0
         call vxSHELLS(1,ish,jsh,ksh,lsh,flip,nosame)
         call vxIJPRIM(ddij)
         if (nij.eq.0) goto 820
         call vxSHELLS(2,ish,jsh,ksh,lsh,flip,nosame)
         call xZQOUT (ghondo)
         if (ijkl.eq.1) then
            call xS0000 (ghondo,ddij)
         else
            call vxGENRAL (ghondo,ddij)
         end if
#else
         call xSHELLS (1,ish,jsh,ksh,lsh,flip,nosame)
         call xIJPRIM (ddij)
         if (nij.eq.0) goto 820
         call xSHELLS (2,ish,jsh,ksh,lsh,flip,nosame)
         call xZQOUT (ghondo)
         if (ijkl.eq.1) then
            call xS0000 (ghondo,ddij)
         else
            call xGENRAL (ghondo,ddij)
         end if
#endif
         ish=inu
         jsh=jnu
         ksh=knu
         lsh=lnu
         nofi=MAXI-MINI+1
         nofj=MAXJ-MINJ+1
         nofk=MAXK-MINK+1
         nofl=MAXL-MINL+1
         iandjx=IANDJ
         kandlx=KANDL
         samex=SAME

         maxij=nofi*nofj
         if (IANDJ) maxij=nofi*(nofi+1)/2
         maxkl=nofk*nofl
         if (KANDL) maxkl=nofk*(nofk+1)/2
         do 10 i=1,maxij
 10      ijind(i)=IJGT(i)
         do 11 i=1,maxkl
 11      klind(i)=KLGT(i)

         n=0
         do 21 i=MINI,MAXI
            n=n+1
            nbai(n)=LOCI+i
 21      continue
         n=0
         do 22 j=MINJ,MAXJ
            n=n+1
            nbaj(n)=LOCJ+j
 22      continue
         n=0
         do 23 k=MINK,MAXK
            n=n+1
            nbak(n)=LOCK+k
 23      continue
         n=0
         do 24 l=MINL,MAXL
            n=n+1
            nbal(n)=LOCL+l
 24      continue
      end if
      done=.true.
 820  continue
      end
c--------------------------------------------------------------------------
c adjust norm.constants of Cartesian d,f, and g functions using the array
c COEINT (ACES and GAMESS use here different conventions);
c This routine is called only for SPHRCL=.true., because for Cartesian
c basis sets the adjustment is done while building the Fock matrix in SCFINT

      subroutine GAMdfg (ghondo,nofi,nofj,nofk,nofl, 
     >  nbai,nbaj,nbak,nbal, iandj,kandl,same, ijind,klind)
      implicit double precision (a-h,o-z)
#include "gamess.par"
      common /GMSorder/ coeint(MXAO),iorder(MXAO),
     >               nAfrst(MXSH),nAstep(MXSH),sphrcl
      dimension ghondo(*),ijind(*),klind(*)
      dimension nbai(*),nbaj(*),nbak(*),nbal(*)
      logical iandj,kandl,same,sphrcl

      jmax=nofj
      lmax=nofl
      ijn=0
      do 110 i=1,nofi
        ibasG=nbai(i)
        coei=coeint(ibasG)
        if (iandj) jmax=i
        do 120 j=1,jmax
          ijn=ijn+1
          n1=ijind(ijn)
          jbasG=nbaj(j)
          coej=coei*coeint(jbasG)

          kln=0
          do 130 k=1,nofk
            kbasG=nbak(k)
            coek=coej*coeint(kbasG)
            if (kandl) lmax=k
            do 140 l=1,lmax
              kln=kln+1
              if (same.and.kln.gt.ijn) goto 120
              lbasG=nbal(l)
              coe=coek*coeint(lbasG)
              nn=n1+klind(kln)
              ghondo(nn) = ghondo(nn)*coe
 140       continue
 130    continue
 120  continue
 110  continue
      end
c-------------------------------------------------------------------------
c establish NBA?A and new values of NOF?, valid after transformation
c of the current shell quadruplet to the spherical harm. ACES basis.
c NOFI etc. gets reduced to account for eliminated components of lower sym.
c NBAIA(i) is the global number of i-th (i=1,..,NOFI) sph.harm. orbital
c in the shell ISH according to the ACES basis set ordering

      subroutine shftbs (ish,jsh,ksh,lsh, nofi,nofj,nofk,nofl,
     >           nbaiA,nbajA,nbakA,nbalA)
      implicit double precision (a-h,o-z)
#include "gamess.par"
      common /GMSorder/ coeint(MXAO),iorder(MXAO),
     >               nAfrst(MXSH),nAstep(MXSH),sphrcl
      dimension nbaiA(*),nbajA(*),nbakA(*),nbalA(*)
      dimension Ltab(15)
      logical sphrcl
      data Ltab /1,-1, 3,-1,-1, 5,-1,-1,-1, 7,-1,-1,-1,-1, 10/
      
      nofi=Ltab(nofi)
      nofj=Ltab(nofj)
      nofk=Ltab(nofk)
      nofl=Ltab(nofl)

      nba=nAfrst(ish)
      do 510 i=1,nofi
      nbaiA(i)=nba
      nba=nba+nAstep(ish)
 510  continue

      nba=nAfrst(jsh)
      do 520 j=1,nofj
      nbajA(j)=nba
      nba=nba+nAstep(jsh)
 520  continue

      nba=nAfrst(ksh)
      do 530 k=1,nofk
      nbakA(k)=nba
      nba=nba+nAstep(ksh)
 530  continue

      nba=nAfrst(lsh)
      do 540 l=1,nofl
      nbalA(l)=nba
      nba=nba+nAstep(lsh)
 540  continue

      end
c--------------------------------------------------------------------
c returns the value VAL of the (ij|kl) integral in the spherical harmonic 
c basis within the current shell quadruplet; 
c I,J,K,L can take values from 1 to 9 (for G shells) according to
c the standard ACES ordering of sph.harm. shells (see data xP etc. below);
c Lish etc. = 0 (S shell) through 4 (G shell);
c Call to GAMsph follows a call to GAMINT and uses the parameters returned
c there: ghondo, iandj,kandl,same, ijind,klind;
c
c Since GAMsph is a small routine called very often, the parameter list
c has been moved to the common /GMSfast/.

c      subroutine GAMsph (ghondo, i,j,k,l, val,
c     >     Lish,Ljsh,Lksh,Llsh, iandj,kandl,same, ijind,klind)
c      dimension ghondo(*),ijind(*),klind(*)

      subroutine GAMsph (val)

      implicit double precision (a-h,o-z)
      common /GMSfast/ ghondo(50625),i,j,k,l,
     >    Lish,Ljsh,Lksh,Llsh, iandj,kandl,same, ijind(225),klind(225)
      save igt,jgt,kgt,lgt

      logical iandj,kandl,same,first
      dimension ncntrb(9,0:4)
      dimension xcntrb(6,9,0:4)
      dimension icntrb(6,9,0:4)

c the one-dimensional arrays for faster access
      dimension xcntr(270),icntr(270)
      equivalence (xcntrb(1,1,0),xcntr)
      equivalence (icntrb(1,1,0),icntr)

c... and the two-dimensional for more clarity of "data" statements
      dimension xS(6,9),xP(6,9),xD(6,9),xF(6,9),xG(6,9)
      dimension iS(6,9),iP(6,9),iD(6,9),iF(6,9),iG(6,9)
      equivalence (xS,xcntrb(1,1,0))
      equivalence (xP,xcntrb(1,1,1))
      equivalence (xD,xcntrb(1,1,2))
      equivalence (xF,xcntrb(1,1,3))
      equivalence (xG,xcntrb(1,1,4))
      equivalence (iS,icntrb(1,1,0))
      equivalence (iP,icntrb(1,1,1))
      equivalence (iD,icntrb(1,1,2))
      equivalence (iF,icntrb(1,1,3))
      equivalence (iG,icntrb(1,1,4))

      data zero /0.d0/
      data first /.true./

      data ncntrb / 1,8*0,  3*1,6*0,  3,1,1,2,1,4*0, 
     >              3,3,3,2,1,2,2,2*0,  6,3,3,3,2,4,2,2,3 /

      data xS /  1.d0, 53*0.d0 /
      data iS /  1, 53*0 /
      data xP /  1.d0,  5*0.d0,    ! 2px
     >           1.d0,  5*0.d0,    ! 2py
     >           1.d0,  5*0.d0,    ! 2pz
     >                 36*0.d0 / 
      data iP /  1, 5*0, 2, 5*0, 3, 5*0, 36*0 /
      data xD / -1.d0, -1.d0, 2.d0, 3*0.d0,    ! 3d( 0)
     >           1.d0,              5*0.d0,    ! 3d(-2)
     >           1.d0,              5*0.d0,    ! 3d(+1)
     >           1.d0, -1.d0,       4*0.d0,    ! 3d(+2)
     >           1.d0,              5*0.d0,    ! 3d(-1)
     >                             24*0.d0 /
      data iD /  1, 2, 3,  3*0,    ! xx, yy, zz
     >           4,        5*0,    ! xy
     >           5,        5*0,    ! xz
     >           1, 2,     4*0,    ! xx, yy
     >           6,        5*0,    ! yz
     >                    24*0 /
      data xF / -1.d0, -1.d0, 4.d0, 3*0.d0,    ! 4f(+1)
     >          -1.d0, -1.d0, 4.d0, 3*0.d0,    ! 4f(-1)
     >          -3.d0, -3.d0, 2.d0, 3*0.d0,    ! 4f( 0)
     >           1.d0, -3.d0,       4*0.d0,    ! 4f(+3)
     >           1.d0,              5*0.d0,    ! 4f(-2)
     >           3.d0, -1.d0,       4*0.d0,    ! 4f(-3)
     >           1.d0, -1.d0,       4*0.d0,    ! 4f(+2)
     >                             12*0.d0 /
      data iF /  1, 6, 8,  3*0,    ! xxx, xyy, xzz
     >           4, 2, 9,  3*0,    ! xxy, yyy, yzz
     >           5, 7, 3,  3*0,    ! xxz, yyz, zzz
     >           1, 6,     4*0,    ! xxx, xyy
     >          10,        5*0,    ! xyz
     >           4, 2,     4*0,    ! xxy, yyy
     >           5, 7,     4*0,    ! xxz, yyz
     >                    12*0 /  
      data xG / 3.d0,  6.d0,-24.d0, 3.d0 ,-24.d0, 8.d0 ,    ! 5g( 0)
     >         -1.d0, -1.d0,  6.d0,              3*0.d0,    ! 5g(-2)   
     >         -3.d0, -3.d0,  4.d0,              3*0.d0,    ! 5g(+1)
     >          1.d0, -6.d0,  1.d0,              3*0.d0,    ! 5g(+4)
     >          3.d0, -1.d0,                     4*0.d0,    ! 5g(-3)
     >         -1.d0,  6.d0,  1.d0,-6.d0 ,       2*0.d0,    ! 5g(+2)
     >          1.d0, -1.d0,                     4*0.d0,    ! 5g(-4)
     >          1.d0, -3.d0,                     4*0.d0,    ! 5g(+3)
     >         -3.d0, -3.d0,  4.d0,              3*0.d0 /   ! 5g(-1)
      data iG /  1,10,11, 2,12, 3,   ! xxxx, xxyy, xxzz, yyyy, yyzz, zzzz 
     >           4, 6,15,     3*0,   ! xxxy, xyyy, xyzz
     >           5,14, 8,     3*0,   ! xxxz, xyyz, xzzz
     >           1,10, 2,     3*0,   ! xxxx, xxyy, yyyy
     >          13, 7,        4*0,   ! xxyz, yyyz
     >           1,11, 2,12,  2*0,   ! xxxx, xxzz, yyyy, yyzz
     >           4, 6,        4*0,   ! xxxy, xyyy
     >           5,14,        4*0,   ! xxxz, xyyz,
     >          13, 7, 9,     3*0 /  ! xxyz, yyyz, yzzz

      IF(FIRST) THEN
         FIRST=.FALSE.
         CALL xBASCHK(LMAX)
                       NANGM =  4
         IF(LMAX.EQ.2) NANGM =  6
         IF(LMAX.EQ.3) NANGM = 10
         IF(LMAX.EQ.4) NANGM = 15
         LGT = 1
         KGT = LGT * NANGM
         JGT = KGT * NANGM
         IGT = JGT * NANGM
      END IF

      nofj= ((Ljsh+1)*(Ljsh+2))/2
      nofl= ((Llsh+1)*(Llsh+2))/2

      ni=ncntrb(i,Lish)
      nj=ncntrb(j,Ljsh)
      nk=ncntrb(k,Lksh)
      nl=ncntrb(l,Llsh)

      val=zero
      
      ii=(i-1)*6 + Lish*54
      jj0=(j-1)*6 + Ljsh*54
      kk0=(k-1)*6 + Lksh*54
      ll0=(l-1)*6 + Llsh*54

      do 210 ix=1,ni
c         xi=xcntrb(ix,i,Lish)
c         ic=icntrb(ix,i,Lish)
         ii=ii+1
         xi=xcntr(ii)
         ic=icntr(ii)

         jj=jj0
         do 220 jx=1,nj
c            xj=xi *xcntrb(jx,j,Ljsh)
c            jc=icntrb(jx,j,Ljsh)
            jj=jj+1
            xj=xi *xcntr(jj)
            jc=icntr(jj)

            if (iandj) then
               icc=max(ic,jc)
               jcc=min(ic,jc)
               ijn=((icc-1)*icc)/2 +jcc
            else
               icc=ic
               jcc=jc
               ijn=(icc-1)*nofj +jcc
            end if

            kk=kk0
            do 230 kx=1,nk
c               xk=xj *xcntrb(kx,k,Lksh)
c               kc=icntrb(kx,k,Lksh)
               kk=kk+1
               xk=xj *xcntr(kk)
               kc=icntr(kk)

               ll=ll0
               do 240 lx=1,nl
c                  x=xk *xcntrb(lx,l,Llsh)
c                  lc=icntrb(lx,l,Llsh)
                  ll=ll+1
                  x=xk *xcntr(ll)
                  lc=icntr(ll)

                  if (kandl) then
                     kcc=max(kc,lc)
                     lcc=min(kc,lc)
                     kln=((kcc-1)*kcc)/2 +lcc
                  else
                     kcc=kc
                     lcc=lc
                     kln=(kcc-1)*nofl +lcc
                  end if

                  if ((same).and.
     >             ((icc.lt.kcc).or.(icc.eq.kcc.and.jcc.lt.lcc))) then
                     nn=ijind(kln)+klind(ijn)
                  else
                     nn=ijind(ijn)+klind(kln)
                  end if

                val=val +ghondo(nn)*x

 240         continue
 230      continue
 220   continue
 210  continue
      
      end
