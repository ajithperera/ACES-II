      SUBROUTINE Q2AB(T,W,Z,T1A,T1B,TAU,ISPIN,POP1,POP2,VRT1,
     &                VRT2,NOCCSQ,DISSYW,DISSYT,NUMSYW,NUMSYT,
     &                 IRREP,TMP,IUHF,FACT,UCC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAl TAU,UCC
      INTEGER DISSYT, DISSYW, DIRPRD,POP1,POP2,VRT1,VRT2
      DIMENSION W(DISSYW,NUMSYW),T(DISSYT,NUMSYT),Z(NOCCSQ)
      DIMENSION TMP(1)
      DIMENSION POP1(8),POP2(8),T1A(1),T1B(1),VRT1(8),VRT2(8) 
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
C
      DATA ONE,ONEM,TWO /1.0D0,-1.D0,2.D0/,HALF /0.5D0/
C
C      PICK UP FIRST THE RELEVANT T2 AND W PIECES
C
C     write(6,*) numsyw,irrep,numsyt,iuhf,ispin
C     CALL GETLST(W,1,NUMSYW,2,IRREP,16)
      LISTW = 46
      CALL GETLST(W,1,NUMSYW,2,IRREP,LISTW)
C
C SPIN ADAPTED CODE FOR RHF
C
      IF(IUHF.EQ.0) THEN
       CALL SPINAD1(IRREP,POP1,DISSYW,W,TMP,TMP(1+DISSYW))
      ENDIF
C
C     write(6,*) dissyt,dissyw,irrep,numsyt,pop1,pop2,vrt1,vrt2
C     CALL GETLST(T,1,NUMSYT,1,IRREP,46)
      LISTT = 46
      CALL GETLST(T,1,NUMSYT,1,IRREP,LISTT)
C
      IF(TAU) THEN
       IF(ISPIN.EQ.1) THEN
        CALL FTAU(T,T1A,T1B,DISSYT,NUMSYT,POP1,POP2,
     &            VRT1,VRT2,IRREP,3,HALF)
       ELSE
        CALL FTAU(T,T1A,T1B,DISSYT,NUMSYT,POP2,POP1,
     &            VRT2,VRT1,IRREP,3,HALF)
       ENDIF
      ENDIF
C
      IF(IUHF.EQ.1.AND.ISPIN.EQ.1) THEN 
       CALL SYMTR1(IRREP,POP1,POP2,DISSYW,W,TMP,TMP(1+DISSYW),
     &             TMP(1+2*DISSYW))
       CALL SYMTR1(IRREP,POP1,POP2,DISSYT,T,TMP,TMP(1+DISSYT),
     &             TMP(1+2*DISSYT))
      ENDIF
C
         JOFF=1
         IOFF=1
         DO 90 IRREPI=1,NIRREP
C          
C        GET OCCUPATION NUMBER FOR JRREP     
C
           NOCCI=POP1(IRREPI)
C
C
C        IF ZERO, NOTHING TO COMPUTE
C
           IF(NOCCI.EQ.0) GO TO 90
C
C        DETERMINE KRREP WHOSE DIRECT PRODUCT WITH JRREP GIVES IRREP
C
           IRREPJ=DIRPRD(IRREP,IRREPI)
C
C        GET OCCUPATION NUMBER FOR KRREP
C
           NOCCJ=POP2(IRREPJ)
C
C        IF ZERO, NOTHING TO COMPUTE
C
           IF(NOCCJ.EQ.0) GO TO 80
C
            CALL XGEMM('T','N',NOCCI,NOCCI,DISSYW*NOCCJ,FACT,
     &                 W(1,JOFF),NOCCJ*DISSYW,T(1,JOFF),      
     &                 NOCCJ*DISSYW,ONE,Z(IOFF),NOCCI)
            IF(UCC) CALL DT(ONE,Z(IOFF),NOCCI,NOCCI,'ADD')
C
           JOFF=JOFF+NOCCJ*NOCCI
80         CONTINUE
C
C         UPDATE THE OFFSET FOR THE INTERMEDIATE Z
C
            IOFF=IOFF+POP1(IRREPI)**2
90        CONTINUE
C
      RETURN
      END
