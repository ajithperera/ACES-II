      SUBROUTINE DOOAB(T1,T2,DOO,FACT,ISPIN,POP1,POP2,
     &                 VRT1,VRT2,DISSYT,NUMSYT,LISTT1,LISTT2,
     &                 LISTT3,IRREP,TMP,IUHF,IFLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT,DIRPRD,POP1,POP2,VRT1,VRT2
C
      DIMENSION T1(DISSYT,NUMSYT),T2(DISSYT,NUMSYT),
     &          DOO(1),TMP(1)
      DIMENSION POP1(8),POP2(8),VRT1(8),VRT2(8) 
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,ILONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
C
      DATA ONE /1.0D0/,HALF /0.5D0/,ONEM /-1.D0/, TWO /2.D0/
C
C PICK UP THE T1 AND T2 AMPLITUDES, CHECK IFLAG IN ORDER WHAT TO DO
C
      CALL GETLST(T1,1,NUMSYT,1,IRREP,LISTT1)
C
      IF(IFLAG.GT.1) THEN
C
C GENERAL CASE, GET T AND L AMPLITUDES (CC-METHODS)
C
       CALL GETLST(T2,1,NUMSYT,2,IRREP,LISTT2)
C
       IF(IFLAG.EQ.3) THEN
C
C FOR MBPT(3), FORM T[2] + 1/2 T[1], NOTE THAT THE VECTOR T2 CONTAINS
C T[1] + T[2], THEREFORE THE FACTOR IS ONEM
C
        CALL SSCAL(NUMSYT*DISSYT,TWO,T2,1)
        CALL SAXPY(NUMSYT*DISSYT,ONEM,T1,1,T2,1)
C
       ELSE IF(IFLAG.EQ.4) THEN
C
C FOR SECOND CALL MBPT(4), ...
C
        CALL SSCAL(NUMSYT*DISSYT,TWO,T1,1)
        CALL SAXPY(NUMSYT*DISSYT,ONE,T2,1,T1,1)
        CALL GETLST(T2,1,NUMSYT,2,IRREP,LISTT3)
C
       ELSE IF(IFLAG.EQ.5) THEN
C
C ROHF-MBPT(3), FORM  T[1] + T[2] + L[2]
C
        CALL SAXPY(NUMSYT*DISSYT,ONE,T1,1,T2,1)
        CALL GETLST(T1,1,NUMSYT,1,IRREP,LISTT3)
        CALL SAXPY(NUMSYT*DISSYT,ONE,T1,1,T2,1)
C       
       ENDIF
      ELSE
C
C T1 AND T2 ARE IDENTICAL (MBPT(2) AND FIRST CALL MBPT(4)
C
c YAU : old
c      CALL ICOPY(NUMSYT*DISSYT*IINTFP,T1,1,T2,1)
c YAU : new
       CALL DCOPY(NUMSYT*DISSYT,T1,1,T2,1)
c YAU : end
C
      ENDIF
C
C SPIN ADAPTED CODE FOR RHF
C
      IF(IUHF.EQ.0) THEN
       CALL SPINAD1(IRREP,POP1,DISSYT,T2,TMP,TMP(1+DISSYT))
      ENDIF
C
C TRANSPOSE THE LAST TWO INDICES IN THE AA CASE
C
C HOWEVER, IN RHF TAKE ADVANTAGE IF THE SPIN SYMMETRY
C
      IF(IUHF.EQ.1.AND.ISPIN.EQ.1) THEN 
       CALL SYMTR1(IRREP,POP1,POP2,DISSYT,T1,TMP,TMP(1+DISSYT),
     &             TMP(1+2*DISSYT))
       CALL SYMTR1(IRREP,POP1,POP2,DISSYT,T2,TMP,TMP(1+DISSYT),
     &              TMP(1+2*DISSYT))
      ENDIF
C
C  PERFORM MULTIPLICATION
C
C  JOFF OFFSET IN THE OCCUPIED-OCCUPIED BLOCK OF T1 AND T2
C  IOFF OFFSET IN DOO
C
      JOFF=1
      IOFF=1
      DO 90 IRREPI=1,NIRREP
C          
C        GET OCCUPATION NUMBER FOR JRREP     
C
       NOCCI=POP1(IRREPI)
C
C        DETERMINE IRREPJ WHOSE DIRECT PRODUCT WITH IRREPI GIVES IRREP
C
       IRREPJ=DIRPRD(IRREP,IRREPI)
C
C        GET OCCUPATION NUMBER FOR IRREPJ
C
       NOCCJ=POP2(IRREPJ)
C
C        IF ZERO, NOTHING TO COMPUTE
C
       IF(MIN(NOCCI,NOCCJ).NE.0) THEN
C
        CALL XGEMM('T','N',NOCCI,NOCCI,DISSYT*NOCCJ,FACT,
     &             T1(1,JOFF),NOCCJ*DISSYT,T2(1,JOFF),      
     &             NOCCJ*DISSYT,ONE,DOO(IOFF),NOCCI)
C
       ENDIF
C
C  UODATE OFFSETS
C
       JOFF=JOFF+NOCCJ*NOCCI
       IOFF=IOFF+NOCCI*NOCCI
90    CONTINUE
C
      RETURN
      END
