
C DRIVER FOR SORTING <AB|CI> (SPIN CASE ALPHA-BETA, I BETA) INTEGRALS.

      SUBROUTINE DABCI1(ICORE,MEMSIZ,NUMIRW,ISYM,IPW,IPDIS,
     &                  IPDSZ,NWDIS,NMO,IRRVEC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSIZ,DIRPRD
      DIMENSION ICORE(MEMSIZ),NUMIRW(2*NIRREP),ISYM(1),IPW(8),
     &          IPDIS(8),IPDSZ(8),IRRVEC(NMO,2)
C
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
 
#include "icdacc.com"
 
      COMMON /BUFLEN/ ILNBUF
      COMMON /SYMINF/ NSTART,NIRREP,IRREPY(255,2),DIRPRD(8,8)
C
C  ILNBUF - THE NUMBER OF INTEGRALS IN AN INDIVIDUAL BUFFER IN THE
C           PPPHAB FILE.
C
C  LENINT - THE NUMBER OF BYTES REQUIRED FOR STORAGE OF AN INTEGRAL AND
C           ITS INDX.
C
C  MEMINT - THE SIZE OF AVAILABLE MEMORY IN UNITS OF "INTEGRAL LENGTHS".
C           (HOW MANY INTEGRALS AND INDICES WHICH CAN BE HELD IN CORE
C           SIMULTANEOUSLY.)
C
C  NUMDIS - THE NUMBER OF DISTRIBUTIONS (NOCA*NVRTB OR NOCB*NVRTA).
C
C  DISSIZ - THE SIZE OF THE DISTRIBUTION (NVRTA*NVRTB ALWAYS).
C
C  NINCOR - THE NUMBER OF DISTRIBUTIONS WHICH CAN BE HELD IN CORE
C           SIMULTANEOUSLY.  (THE NUMBER IN A "BUCKET").
C
C  NBKINT - THE NUMBER OF INTEGRALS TO BE HELD IN AN INDIVIDUAL BUCKET
C           BUFFER. (FIXED).
C
C  MEMSIZ - THE AVAILABLE MEMORY, IN WORDS.
C
C
C  DETERMINE MAXIMUM DISTRIBUTION SIZE AND THE TOTAL NUMBER
C  OF DISTRIBUTION
C
      NUMDIS=0
      DISSIZ=0
      DO 10 IRREP=1,NIRREP
      DISSIZ=MAX(DISSIZ,NUMIRW(IRREP+NIRREP))
      NUMDIS=NUMDIS+NUMIRW(IRREP)
10    CONTINUE
C
      CALL IZERO(ICORE,MEMSIZ)
      LENINT=1+IINTFP
      NBKINT=(32768-2*IINTLN)/(IINTLN*(1+IINTFP))
      MEMSZ=MEMSIZ
C
C  SUBTRACT AWAY THE SPACE NEEDED FOR INTEGRAL BUFFERS.
C
      MEMSIZ=MEMSIZ-LENINT*NBKINT 
C
C  SUBTRACT AWAY SPACE NEEDED FOR SORT CHAIN VECTOR (UPPER LIMIT).
C
      MEMSIZ=MEMSIZ-NUMDIS
C
C DETERMINE HOW MANY DISTRIBUTIONS WHICH CAN FIT INTO THE CORE
C  SPACE THAT REMAINS.  NOTE THAT WE DON'T HAVE TO WORRY ABOUT
C  INDICES HERE, SINCE THEY ARE NOT BEING WRITTEN OUT IN CHAN01.
C
      MEMINT=MEMSIZ/IINTFP
      NINCOR=MIN(NUMDIS,MEMINT/DISSIZ)
C
C NOW FIGURE OUT HOW MANY SORTFILE BUCKETS ARE NEEDED AND HOW BIG THEY
C   HAVE TO BE.
C
C  NBUCK  - THE NUMBER OF BUCKETS.
C
C  NDBCK  - THE NUMBER OF DISTRIBUTIONS PER BUCKET.
C
C  NBKINT - THE NUMBER OF INTEGRALS IN A BUCKET.
C
C  IOFF   - THE NUMBER OF WORDS REQUIRED TO HOLD THE INTEGRAL VALUES IN
C           GIVEN BUCKET.
C
      IF(NINCOR.EQ.0)THEN
       WRITE(6,4000)NUMDIS*LENINT,MEMSIZ
4000   FORMAT(T3,'@DABCI1-F, Not enough core to hold one integral ',
     &        'distribution.',/,
     & T3,'       Space needed (words):   ',I10,/,
     & T3,'       Space available (words):',I10)
       CALL ERREX
      ENDIF
C
C FIGURE OUT HOW MANY BUCKETS ARE REQUIRED.
C
      NBUCK=NUMDIS/NINCOR
      IF(MOD(NUMDIS,NINCOR).NE.0)NBUCK=NBUCK+1
C
C NDBCK IS THE NUMBER OF DISTRIBUTIONS IN AN INDIVIDUAL BUCKET.
C
      NDBCK=NUMDIS/NBUCK
      IF(MOD(NUMDIS,NBUCK).NE.0)NDBCK=NDBCK+1
C
C WHY IS THE LAST LINE NEEDED?
C

c YAU - old
cC NOW SET THE RECORD LENGTH FOR THE SORT FILE.
cC      IRECL=IINTLN*(NBKINT*(1+IINTFP)+2)
c      if(iintfp.eq.1)then
c        IRECL=IINTLN*(NBKINT*(1+IINTFP)+2)
c      else
c        IRECL=idaccm*(NBKINT*(1+IINTFP)+2)
c      endif
c YAU - new
      IRECL=idaccm*(NBKINT*(1+IINTFP)+2)
c YAU - end

C
C NOW ALLOCATE CORE FOR THE SORT!  THIS WILL TYPICALLY BE MUCH LESS
C  THAN THE TOTAL AVAILABLE MEMORY.
C
      I000=1
      I010=NBKINT*IINTFP*NBUCK+I000
      I020=ILNBUF*IINTFP+I010
      I030=NBKINT*NBUCK+I020
      I040=ILNBUF+I030
      I050=NBUCK+I040
      I060=NBUCK+I050
      IF(MOD(I060,2).NE.1)I060=I060+1
      I070=2*ILNBUF*IINTFP+I060
      I080=2*ILNBUF+I070
      I090=2*ILNBUF+I080
      I095=2*ILNBUF+I090
      I100=NDBCK*NBUCK+I095 
CSSS      WRITE(6,*)' I100 Is ',I100,'  MEMSIZ IS ',MEMSIZ
      IF(I100.GT.MEMSZ)THEN
       WRITE(6,5000)
5000   FORMAT(T3,'@DABCI1-F, Insufficient core to perform sort.')
       CALL INSMEM('DABCI1',I100,MEMSZ)
       CALL ERREX
      ENDIF
      WRITE(6,1000)MEMSZ,MEMSIZ,DISSIZ*LENINT,NUMDIS,NINCOR,NBUCK,
     &        NDBCK,NBKINT,IRECL,I100
1000   FORMAT(T3,'@DABCI1-I, Information for AO integral sort',/,
     &   '        Total available memory (words)         ',I10,'.',/,
     &   '        Available memory for buckets (words)   ',I10,'.',/,
     &   '        Maximum Distribution length (words)    ',I10,'.',/,
     &   '        Number of distributions                ',I10,'.',/,
     &   '        Number which can be held in core       ',I10,'.',/,
     &   '        Number of sortfile buckets             ',I10,'.',/,
     &   '        Number of distributions per bucket     ',I10,'.',/,
     &   '        Number of integrals per bucket         ',I10,'.',/,
     &   '        Sortfile record length (bytes)         ',I10,'.',/,
     &   '        Total utilized memory (words)          ',I10,'.')
      CALL SABCI1(ICORE(I000),ICORE(I010),ICORE(I020),ICORE(I030),
     &            ICORE(I040),ICORE(I050),NBUCK,NDBCK,
     &            NBKINT,NREC,IRECL,ILNBUF,ISYM,
     &            ICORE(I060),ICORE(I070),ICORE(I080),ICORE(I090),
     &            ICORE(I095))
C
C MOVE CHAIN VECTOR TO BOTTOM OF CORE.
C
      CALL ICOPY(NBUCK,ICORE(I050),1,ICORE(I000),1)
C
C FPS-500 KLUDGE
C
      IADD=0
      IF(MOD(NBUCK,2).EQ.1)IADD=1
C
C ALLOCATE CORE FOR SORTFILE PROCESSING.
C
      I000=1
      I010=I000+NBUCK+IADD
      I020=I010+DISSIZ*NDBCK*IINTFP
      I030=I020+NBKINT*IINTFP
      I040=I030+NBKINT
      WRITE(6,200)I040,MEMSZ
200   FORMAT(T3,'@DABCI1-I, Sort chain processing uses ',I10,
     &          ' out of ',I10,' words.')
      IF(I060.GT.MEMSZ)THEN
       WRITE(6,300)I060,MEMSZ
       CALL ERREX
300    FORMAT(T3,'@DABCI1-F, Core screwup. ',I10,' words needed.',
     &           I10,' words available.')
      ENDIF
      CALL CABCI1(ICORE(I010),ICORE(I020),ICORE(I030),
     &            ICORE(I000),DISSIZ,NDBCK,NBKINT,NBUCK,
     &            IRECL,NUMIRW,ISYM,IPW,IPDIS,IPDSZ,NWDIS,
     &            IRRVEC(1,1),IRRVEC(1,2))
      RETURN
      END
