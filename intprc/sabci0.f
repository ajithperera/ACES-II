
      SUBROUTINE SABCI0(BUCK,BUF,IBUCK,IBUF,NINBCK,ICHAIN,
     &                  NBUCK,NDBCK,NBKINT,NREC,IRECL,
     &                  ILNBUF,ISPIN,ISYM,BUF2,IBUF2,IWHERE,
     &                  ILOOKUP,IMASTER)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      CHARACTER*8 INAME
      CHARACTER*80 FNAME
      INTEGER DISIL,DISKL,A,B,C,AND,OR
      PARAMETER (LUINT=10)
      PARAMETER (LUSRT=15)
      DIMENSION BUCK(NBKINT,NBUCK),IBUCK(NBKINT,NBUCK),ISYM(1)
      DIMENSION IBUF(ILNBUF),NINBCK(NBUCK),ICHAIN(NBUCK),BUF(ILNBUF)
      DIMENSION BUF2(2*ILNBUF),IBUF2(2*ILNBUF),IWHERE(2*ILNBUF)
      DIMENSION ILOOKUP(2*ILNBUF),IMASTER(NDBCK*NBUCK)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /INFO/ NOCCO(2),NVRTO(2)
C
C SUBROUTINE CREATES A SORT FILE FOR <AB|CI> INTEGRALS, AB SPIN
C  CASE, I BETA SPIN.
C
C   BUCK   - SCRATCH ARRAY TO HOLD BUCKET BUFFER VALUES.
C
C   IBUCK  - SCRATCH ARRAY TO HOLD BUCKET BUFFER INDICES.
C
C   BUF    - HOLDS A BUFFER OF INTEGRAL VALUES.
C
C   IBUF   - HOLDS A BUFFER OF INTEGRAL INDICES.
C
C   NINBCK- BUCKET POPULATION VECTOR -- KEEPS TRACK OF THE NUMBER OF ELE
C           IN EACH BUCKET AT A GIVEN TIME.
C
C   ICHAIN- SORT CHAIN VECTOR.  ICHAIN(J) ALWAYS HOLDS THE VALUE OF THE
C           RECORD NUMBER WHICH CORRESPONDS TO THE LAST RECORD HOLDING
C           MEMBERS OF DISTRIBUTION J.
C
C   NBUCK - THE NUMBER OF BUCKETS USED IN THE SORT.
C
C   NDBCK - THE NUMBER OF DISTRIBUTIONS PER BUCKET.
C
C   NBKINT- NUMBER OF INTEGRALS PER BUCKET.
C
C   NREC  - NUMBER OF RECORDS IN SORTFILE (RETURNED).
C
C   IRECL - RECORD LENGTH FOR SORTFILE.
C
C   ILNBUF- THE SIZE OF AN INTEGRAL BUFFER. (600 FOR VMOL).
C
C
C STATEMENT FUNCTIONS FOR BIT UNPACKING.
C
      IUPKI(INT)=AND(INT,IALONE)
      IUPKJ(INT)=AND(ISHFT(INT,-IBITWD),IALONE)
      IUPKK(INT)=AND(ISHFT(INT,-2*IBITWD),IALONE)
      IUPKL(INT)=AND(ISHFT(INT,-3*IBITWD),IALONE)
      IPACK(I,J,K,L)=OR(OR(OR(I,ISHFT(J,IBITWD)),ISHFT(K,2*IBITWD)),
     &                  ISHFT(L,3*IBITWD))
C
C STATEMENT FUNCTIONS FOR SQUARE TRIANGULAR INDEXING.
C
      INDX(I,J,N)=I+(J-1)*N
C
C OPEN UP SORTFILE AND INTEGRAL FILE.
C
      NOC=NOCCO(ISPIN)
      NVRT=NVRTO(ISPIN)
      IF(ISPIN.EQ.1)INAME='PPPHAA  '
      IF(ISPIN.EQ.2)INAME='PPPHBB  '
      CALL GFNAME(INAME,FNAME,ILENGTH)
      OPEN(UNIT=LUINT,FILE=FNAME(1:ILENGTH),FORM='UNFORMATTED',
     &     STATUS='OLD',ACCESS='SEQUENTIAL')
      CALL GFNAME('SRTFIL  ',FNAME,ILENGTH)
      OPEN(UNIT=LUSRT,FILE=FNAME(1:ILENGTH),FORM='UNFORMATTED',
     &     ACCESS='DIRECT',RECL=IRECL)
C
C INITIALIZE SOME CRAP AND SET UP MASTER INDEX.
C
      NREC=1
      NUMINT=0
      CALL IZERO(NINBCK,NBUCK)
      CALL IZERO(ICHAIN,NBUCK)
      IOFF=0
      DO 5 I=1,NBUCK
       DO 6 J=1,NDBCK
        IOFF=IOFF+1
        IMASTER(IOFF)=I
6      CONTINUE
5     CONTINUE
C
C READ A BUFFER OF INTEGRALS AND DEAL WITH IT.
C
1     READ(LUINT)BUF,IBUF,NUT
      ISTICK=0
      CALL IZERO(IWHERE,2*ILNBUF)
CDIR$ IVDEP
*VOCL LOOP,NOVREC
      DO 10 INT=1,NUT
       I=IUPKI(IBUF(INT))
       A=IUPKJ(IBUF(INT))
       B=IUPKK(IBUF(INT))
       C=IUPKL(IBUF(INT))
C
C ASSIGN THE DISTRIBUTION NUMBER.
C
       DISKL=ISYM(INDX(A,I,NVRT))
C
C PUT THIS INTEGRAL INTO A BUCKET BASED ON THE KL INDEX.  DO YOU
C   UNDERSTAND THE LOGIC OF THE ASSIGNMENT?
C
       IBKET=IMASTER(DISKL)
       IBUF(INT)=IPACK(C,B,A,I)
       IWHERE(ISTICK+1)=IBKET
       IBUF2(ISTICK+1) =IBUF(INT)
       BUF2(ISTICK+1)  =BUF(INT)
C
C IF THE INTEGRAL IS OF TYPE (AB|AI), THEN IT WILL ONLY BE PLUNKED
C  INTO ONE BUCKET.  ANY OTHER TYPE GOES INTO TWO.  NOTE THAT THE
C  <CB|AI> INTEGRAL IS USED HERE.
C
       IF(A.NE.C)THEN
        DISIL=ISYM(INDX(C,I,NVRT))
        IBUF(INT)=IPACK(A,B,C,I)
        IBKET=IMASTER(DISIL)
        IWHERE(ISTICK+2)=IBKET
        IBUF2(ISTICK+2) =IBUF(INT)
        BUF2(ISTICK+2)  =BUF(INT)
       ENDIF
       ISTICK=ISTICK+2
10    CONTINUE
      NUMINT=NUMINT+NUT
C
C DEAL WITH STUFF NOW
C
      DO 120 ITYPE=1,NBUCK
       CALL WHENEQ(2*ILNBUF,IWHERE,1,ITYPE,ILOOKUP,NVAL)
       ioff=1
       inbuck=ninbck(itype)
11     idump=min(nval,nbkint-inbuck)
       call gather(idump,buck(inbuck+1,itype),buf2,ilookup(ioff))
       call igather(idump,ibuck(inbuck+1,itype),ibuf2,ilookup(ioff))
       inbuck=inbuck+idump 
       if(inbuck.eq.nbkint)then
        call plunk(lusrt,buck(1,itype),ibuck(1,itype),ichain(itype),
     &              inbuck,nbkint,nrec)
        nval=nval-idump
        ioff=ioff+idump
        if(nval.ne.0)goto 11
       endif
       ninbck(itype)=inbuck
120   CONTINUE
      IF(NUT.EQ.ILNBUF)GOTO 1
      WRITE(6,1400)NUMINT
1400  FORMAT(T3,'@SABCI0-I, ',I8,' PPPH integrals sorted.')
C
C FLUSH REMAINING BUFFERS.
C
      DO 20 I=1,NBUCK
       CALL PLUNK(LUSRT,BUCK(1,I),IBUCK(1,I),ICHAIN(I),NINBCK(I),
     &            NBKINT,NREC)
20    CONTINUE
      NREC=NREC-1
      CLOSE(UNIT=LUINT,STATUS='DELETE')
      CLOSE(UNIT=LUSRT,STATUS='KEEP')
      RETURN
      END
