#include "flags.h"
      SUBROUTINE STT4AA(W,WABIJ,BUF,IBUF,ISYMVO,ISIZVO,
     &                  IOFFVO,IOFFW,ITMP1,ITMP2,ITMP3,
     &                  ITMP4,LENW,ISPIN,IUHF,NMO,IRREPS)
C
C THIS SUBROUTINE PROCESSES THE <AI||BJ> INTEGRALS FOR SPIN CASES AAAA
C  AND BBBB, PUTS THEM INTO A SYMMETRY PACKED LIST, AND WRITES THEM TO
C  DISK AS AN ANTISYMMETRIZED SYMMETRY PACKED LIST.  THIS ROUTINE 
C  ALSO HANDLES THE ABAB SPIN CASE FOR RHF.  THESE ARE RING INTEGRALS
C  AND ARE WRITTEN IN THE MATRIX FORM W(AJ,BI).
C
CEND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER A,B,DIRPRD,POP,VRT,AND
      CHARACTER*4 SPCASE(2)
      CHARACTER*8 INAME
      CHARACTER*80 FNAME
      LOGICAL DRCCD
      DIMENSION BUF(ILNBUF),IBUF(ILNBUF),W(LENW),WABIJ(LENW)
      DIMENSION ISYMVO(1),IOFFW(NIRREP),ITMP1(ILNBUF),ITMP2(ILNBUF)
      DIMENSION ITMP3(ILNBUF),ITMP4(ILNBUF)
      DIMENSION ISIZVO(NIRREP),IOFFVO(NIRREP)
      DIMENSION IRREPS(NMO,2)
C
      COMMON /FLAGS/ IFLAGS(100)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPY(255,2),DIRPRD(8,8)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON /SYM/ POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
      COMMON /FILES/ LUOUT,MOINTS
      COMMON /BUFLEN/ ILNBUF
      COMMON /INFO/ NOCCO(2),NVRTO(2)
      COMMON /SHIFT/ ISHIFT,NDRGEO

C Common block for parametrized CC (intialized by parread from main),
#include "parcc.com"
C
      DATA SPCASE /'AAAA','BBBB'/
      DATA ONEM /-1.0/
C
      IUPKI(INT)=AND(INT,IALONE)
      IUPKJ(INT)=AND(ISHFT(INT,-IBITWD),IALONE)
      IUPKK(INT)=AND(ISHFT(INT,-2*IBITWD),IALONE)
      IUPKL(INT)=AND(ISHFT(INT,-3*IBITWD),IALONE)
      INDXF(I,J,N)=I+(J-1)*N
C
      NOCC=NOCCO(ISPIN)
      NVRT=NVRTO(ISPIN)
      DRCCD  = (IFLAGS(h_IFLAGS_calclevel) .EQ. 49)
C
      IF(IFLAGS(1).GE.1)WRITE(LUOUT,2000)SPCASE(ISPIN)
2000  FORMAT(T3,'@STT4AA-I, Processing integral type PHPH, ',
     &       'spin case ',A4,'.')
      INAME='PHPH'//SPCASE(ISPIN)(1:2)//'  '
      CALL GFNAME(INAME,FNAME,ILENGTH)
      OPEN(UNIT=15,FILE=FNAME(1:ILENGTH),
     &FORM='UNFORMATTED',ACCESS='SEQUENTIAL',STATUS='OLD')
      CALL ZERO(W,LENW)
C
C PICK UP A BUFFER OF INTEGRALS
C
1     READ(15)BUF,IBUF,NUT
      DO 10 INT=1,NUT
       ITMP1(INT)=IUPKI(IBUF(INT))
       ITMP2(INT)=IUPKJ(IBUF(INT))
       ITMP3(INT)=IUPKK(IBUF(INT))
       ITMP4(INT)=IUPKL(IBUF(INT))
       I=ITMP1(INT)
       A=ITMP2(INT)
       J=ITMP3(INT)
       B=ITMP4(INT)
       X=BUF(INT)
       IRRA=IRREPS(A+NOCC,ISPIN)
       IRRJ=IRREPS(J,ISPIN)
       IRDPD=DIRPRD(IRRA,IRRJ)
C
C GET AJ AND BI ABSOLUTE OFFSETS
C
       IOFFAJ=INDXF(A,J,NVRT)
       IOFFBI=INDXF(B,I,NVRT)
C
C NOW GET RELATIVE AJ SYMMETRY OFFSET WITHIN THE DPD BLOCK AND DO SAME
C  FOR BI
C
       IOFAJS=ISYMVO(IOFFAJ)-IOFFVO(IRDPD)
       IOFBIS=ISYMVO(IOFFBI)-IOFFVO(IRDPD)
C
C NOW CALCULATE ABSOLUTE POSITION IN W VECTOR WHERE THIS ELEMENT
C  BELONGS
C
       IABSOF=IOFFW(IRDPD)
       IRELOF=INDXF(IOFAJS,IOFBIS,ISIZVO(IRDPD))
       IOFF=IRELOF+IABSOF
       W(IOFF)=X
10    CONTINUE
C
C REVERSE SENSE OF A-B  
C
      DO 20 INT=1,NUT
       I=ITMP1(INT)
       B=ITMP2(INT)
       J=ITMP3(INT)
       A=ITMP4(INT)
       X=BUF(INT)
       IRRA=IRREPS(A+NOCC,ISPIN)
       IRRJ=IRREPS(J,ISPIN)
       IRDPD=DIRPRD(IRRA,IRRJ)
       IOFFAJ=INDXF(A,J,NVRT)
       IOFFBI=INDXF(B,I,NVRT)
       IOFAJS=ISYMVO(IOFFAJ)-IOFFVO(IRDPD)
       IOFBIS=ISYMVO(IOFFBI)-IOFFVO(IRDPD)
       IABSOF=IOFFW(IRDPD)
       IRELOF=INDXF(IOFAJS,IOFBIS,ISIZVO(IRDPD))
       IOFF=IRELOF+IABSOF
       W(IOFF)=X
20    CONTINUE
C
C REVERSE SENSE OF I-J  
C
      DO 30 INT=1,NUT
       J=ITMP1(INT)
       A=ITMP2(INT)
       I=ITMP3(INT)
       B=ITMP4(INT)
       X=BUF(INT)
       IRRA=IRREPS(A+NOCC,ISPIN)
       IRRJ=IRREPS(J,ISPIN)
       IRDPD=DIRPRD(IRRA,IRRJ)
       IOFFAJ=INDXF(A,J,NVRT)
       IOFFBI=INDXF(B,I,NVRT)
       IOFAJS=ISYMVO(IOFFAJ)-IOFFVO(IRDPD)
       IOFBIS=ISYMVO(IOFFBI)-IOFFVO(IRDPD)
       IABSOF=IOFFW(IRDPD)
       IRELOF=INDXF(IOFAJS,IOFBIS,ISIZVO(IRDPD))
       IOFF=IRELOF+IABSOF
       W(IOFF)=X
30    CONTINUE
C
C REVERSE SENSE OF A-B AND I-J
C
      DO 40 INT=1,NUT
       J=ITMP1(INT)
       B=ITMP2(INT)
       I=ITMP3(INT)
       A=ITMP4(INT)
       X=BUF(INT)
       IRRA=IRREPS(A+NOCC,ISPIN)
       IRRJ=IRREPS(J,ISPIN)
       IRDPD=DIRPRD(IRRA,IRRJ)
       IOFFAJ=INDXF(A,J,NVRT)
       IOFFBI=INDXF(B,I,NVRT)
       IOFAJS=ISYMVO(IOFFAJ)-IOFFVO(IRDPD)
       IOFBIS=ISYMVO(IOFFBI)-IOFFVO(IRDPD)
       IABSOF=IOFFW(IRDPD)
       IRELOF=INDXF(IOFAJS,IOFBIS,ISIZVO(IRDPD))
       IOFF=IRELOF+IABSOF
       W(IOFF)=X
40    CONTINUE
C
C WRITE THESE INTEGRALS TO DISK IF THIS IS RHF.
C
      IF(NUT.EQ.ILNBUF)GOTO 1
      IF(IUHF.EQ.0)THEN
       CALL PUTALL(W,LENW,1,25 + ISHIFT) 
      ENDIF

C Save the Coulomb only contribution parametrized CC.

      IF ((ISPAR .AND. COULOMB) .OR. DRCCD) THEN
         CALL PUTALL(W,LENW,1,122+ISPIN + ISHIFT) 
      ENDIF 
#ifdef _DEBUG_LVLM
      write(6,"(6(1x,F15.8))") (w(i),i=1,lenw)
      call checksum("sw:",w,LENW)
#endif 
C
C NOW ANTISYMMETRIZE THE INTEGRALS AND WRITE THEM TO DISK.
C
      CALL SAXPY(LENW,ONEM,WABIJ,1,W,1)
      CALL PUTALL(W,LENW,1,22+ISPIN + ISHIFT) 
#ifdef _DEBUG_LVLM
      write(6,"(6(1x,F15.8))") (w(i),i=1,lenw)
      call checksum("aw:",w,LENW)
#endif 
C
      CLOSE(UNIT=15,STATUS='DELETE')
      RETURN
      END
