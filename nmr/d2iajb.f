      SUBROUTINE D2IAJB(UAIA,UAIB,SIJA,SIJB,UIAA,UIAB,SABA,SABB,
     &                  ICORE,MXCOR,IRREPX,IPERT,IUHF,STERM,ANTI)
C
C  THIS ROUTINE CALCULATES THE DERIVATIVE INTEGRALS d <IA//JB> / d chi
C
C   THERE ARE EIGHT DIFFERENT TERMS
C
C   DUE TO PERMUTATIONAL SYMMETRY THEY REDUCE TO FOUR
C      (<iA||jB> <--> <jB||iA>
C
CEND
C
C CODED SEP/91 JG UNIVERSITY OF KARLSRUHE
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,DISSYW,DISSYD,POP,VRT
      LOGICAL FIELD,GEOM,ROHF,QRHF,SEMI,STERM,ANTI
      DIMENSION ICORE(MXCOR) 
      DIMENSION UAIA(1),UAIB(1),UIAA(1),UIAB(1)
      DIMENSION SIJA(1),SIJB(1),SABA(1),SABB(1)
C
      COMMON/OFFSETS/IOFFU(8,2),IOFFS1(8,2),IOFFS2(8,2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREPAA(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),NJUNK(18)
      COMMON/DTRAN/FIELD,GEOM,ROHF,QRHF,SEMI
      COMMON /TIMEINFO/ TIMEIN, TIMENOW, TIMETOT, TIMENEW 
C
      DATA AZERO,ONE,ONEM /0.D0,1.D0,-1.D0/
C
      CALL TIMER(1)
C
C  INCORE ALGORITHM
C
C  LOOP OVER ALL IRREPS OF THE DERIVATIVE INTEGRALS
C
      DO 1000 IRREPR=1,NIRREP
C
C  THE IRREP ON THE LEFT SIDE IS THEN GIVEN AS THE DIRECT PRODUCT
C   OF IRREPP AND IRREPR
C
       IRREPL=DIRPRD(IRREPR,IRREPX)
C
C DETERMINE LENGTH OF TARGET ARRAY
C
       LISTD=325
       NUMSYD=IRPDPD(IRREPR,ISYTYP(2,LISTD))
       DISSYD=IRPDPD(IRREPL,ISYTYP(1,LISTD))
C
C ALLOCATE CORE FOR TARGET ARRAY
C
       ID=1
       IREST=ID+IINTFP*NUMSYD*DISSYD
       IF(IREST.GE.MXCOR) CALL INSMEM('D2IAJB1',IREST,MXCOR)
C
C  ZERO TARGET LIST
C
       CALL ZERO(ICORE(ID),NUMSYD*DISSYD)
C
C FIRST TERM: 
C
C CONSIDER FIRST ALL TERMS WHICH INCLUDE U(IA)
C
C    <Mi||Bj> U(MA) 
C
C  THE IRREP ON THE RIGHT SIDE IS UNCHANGED, SO IRREPR DETERMINES
C  THE LISTS OF ORIGINAL ZEROTH ORDER INTEGRALS
C
       LISTW=10-IUHF
       NUMSYW=IRPDPD(IRREPR,ISYTYP(2,LISTW))
       DISSYW=IRPDPD(IRREPR,ISYTYP(1,LISTW))
C
C  ALLOCATE CORE MEMORY
C
       IW=IREST
       IW2=IW+IINTFP*NUMSYW*DISSYW
       ITMP=IW2
       IEND1=IW2+IINTFP*NUMSYW*DISSYW
       IEND2=ITMP+3*IINTFP*MAX(NUMSYD,DISSYD,NUMSYW,DISSYW)
       IEND=MAX(IEND1,IEND2)
C
       IF(IEND.GE.MXCOR) THEN
        IEND=ITMP+3*IINTFP*MAX(NUMSYW,DISSYW,DISSYD,NUMSYD)
        IF(IEND.GE.MXCOR) CALL INSMEM('D2IAJB2',IEND,MXCOR)
C
        CALL GETTRN(ICORE(IW),ICORE(ITMP),DISSYW,NUMSYW,1,IRREPR,LISTW)
C
       ELSE
C
C  READ IN THE <Mi||Bj> AS  Mi,Bj (UHF) OR iM,jB (RHF)
C
        CALL GETLST(ICORE(IW2),1,NUMSYW,1,IRREPR,LISTW)
C
C TRANSPOSE Mi,Bj TO Bj, Mi (OR  iM, jB TO jB, iM)
C
        CALL TRANSP(ICORE(IW2),ICORE(IW),NUMSYW,DISSYW)
C
       ENDIF
C
C FOR UHF TRANSPOSE M AND I
C
       IF(IUHF.EQ.1) THEN
C
        CALL SYMTR1(IRREPR,POP(1,1),POP(1,2),NUMSYW,ICORE(IW),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYW),
     &              ICORE(ITMP+2*IINTFP*NUMSYW))
C
       ENDIF
C
C  (Bj,iA) (R,L) <------ (Bj,iM) (R,R) (A,M) (X) (UHF)
C  (jB,iA) (R,L) <------ (jB,iM) (R,R) (A,M) (X) (RHF)
C
       CALL DFINDT(ICORE(ID),ICORE(IW),UIAA,NUMSYD,DISSYD,
     &             NUMSYW,DISSYW,POP(1,2),POP(1,1),
     &             VRT(1,1),IRREPR,IRREPL,IRREPX,
     &             IOFFU(1,1),2)
C
C  TRANSPOSE THE TARGET LIST   
C
C   Bj,iA TO Bj,Ai
C   jB,iA TO jB,Ai
C
       CALL SYMTR1(IRREPL,POP(1,2),VRT(1,1),NUMSYD,
     &             ICORE(ID),ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYD),
     &             ICORE(ITMP+2*IINTFP*NUMSYD))
C
       IF(IUHF.EQ.0) THEN
C
C FOR RHF TRANSPOSE ALSO jB,Ai TO Bj,AI
C
        CALL SYMTR3(IRREPR,POP(1,2),VRT(1,1),NUMSYD,DISSYD,
     &              ICORE(ID),ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYD),
     &              ICORE(ITMP+2*IINTFP*DISSYD))
C
       ENDIF
C
C SECOND TERM:
C  
C  NOW DO <Bj||Ae> U(e,i)
C         <Bj||Ae> U(e,i)
C
       LISTW=30
       NUMSYW=IRPDPD(IRREPR,ISYTYP(2,LISTW))
       DISSYW=IRPDPD(IRREPR,ISYTYP(1,LISTW))
C
C  ALLOCATE CORE MEMORY
C
       IW=IREST
       ITMP=IW+IINTFP*NUMSYW*DISSYW
       IEND=ITMP+3*IINTFP*MAX(NUMSYD,DISSYD,NUMSYW,DISSYW)
C
       IF(IEND.GE.MXCOR) THEN
C
C OUT-OF-CORE ALGORITHM
C
        ITMP=IREST
        IW=ITMP+3*IINTFP*MAX(NUMSYW,NUMSYD,DISSYW,DISSYD)
        ISTART=1
        NLEFT=NUMSYW
        MEM=MXCOR-IW
        NDIS=MEM/(IINTFP*DISSYW)
        IF(NDIS.EQ.0) THEN
         write(*,*) ' @-D2IAJB-F, Out-of-core algorithm not possible.'
         CALL ERREX
        ENDIF
C
C   TRANSPOSE FOR OUT-OF-CORE THE TWO RIGHT INDICES OF D 
C
        CALL SYMTR1(IRREPL,VRT(1,1),POP(1,2),NUMSYD,ICORE(ID),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYD),
     &              ICORE(ITMP+2*IINTFP*NUMSYD))
C
900     CONTINUE
C
        NREAD=MIN(NLEFT,NDIS)
        NLEFT=NLEFT-NREAD
        IEND=ISTART+NREAD-1
        CALL GETTRN3(ICORE(IW),ICORE(ITMP),DISSYW,
     &               ISTART,IEND,NREAD,1,IRREPR,LISTW)
C
C  (Bj;Ai) (R,L) <----- (Bj;Ae) (R,R) (e,i) (X)
C
C   TRANSPOSE FIRST TWO RIGHT INDICES OF W
C
        CALL SYMTR1(IRREPR,VRT(1,1),VRT(1,2),NREAD,ICORE(IW),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*NREAD),
     &              ICORE(ITMP+2*IINTFP*NREAD))
C
        CALL DFINDT2(ICORE(ID),ICORE(IW),UAIB,ISTART,IEND,
     &               NUMSYD,DISSYD,NREAD,DISSYW,VRT(1,1),
     &               VRT(1,2),POP(1,2),IRREPR,IRREPL,
     &               IRREPX,IOFFU(1,2),1)
C
        ISTART=IEND+1
        IF(NLEFT.NE.0) GO TO 900
C
C ALL DONE, TRANSPOSE TWO RIGHT INDICES OF D BACK TO ORIGINAL ORDER
C
        CALL SYMTR1(IRREPL,POP(1,2),VRT(1,1),NUMSYD,ICORE(ID),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYD),
     &              ICORE(ITMP+2*IINTFP*NUMSYD))
C
       ELSE
C
C  IN-CORE ALGORITHM
C
C  READ IN THE <Ae||Bj> AS Ae, Bj
C
C  TRANSPOSE FROM Ac,Bj TO Bj,Ae
C  (CALL HERE GETTRN)
C
        CALL GETTRN(ICORE(IW),ICORE(ITMP),DISSYW,NUMSYW,1,
     &              IRREPR,LISTW)
C
C  (Bj;Ai) (R,L) <----- (Bj;Ae) (R,R) (e,i) (X)
C
        CALL DFINDT(ICORE(ID),ICORE(IW),UAIB,NUMSYD,DISSYD,
     &              NUMSYW,DISSYW,VRT(1,1),VRT(1,2),POP(1,2),
     &              IRREPR,IRREPL,IRREPX,IOFFU(1,2),1)
C
       ENDIF
C
       IF(STERM) THEN
C
C THIRD TERM:
C
C CONSIDER FIRST ALL TERMS WHICH INCLUDE S(AE)
C
C    <Bj|Am> (-1/2 S(mi))
C
C  THE IRREP ON THE RIGHT SIDE IS UNCHANGED, SO IRREPR DETERMINES
C  THE LISTS OF ORIGINAL ZEROTH ORDER INTEGRALS
C
        LISTW=25
        NUMSYW=IRPDPD(IRREPR,ISYTYP(2,LISTW))
        DISSYW=IRPDPD(IRREPR,ISYTYP(1,LISTW))
C
C  ALLOCATE CORE MEMORY
C
        ITMP=IW+IINTFP*NUMSYW*DISSYW
        IEND=ITMP+3*IINTFP*MAX(DISSYW,NUMSYD)
C
        IF(IEND.GE.MXCOR) CALL INSMEM('D2IAJB3',IEND,MXCOR)
C
C  READ IN THE <Bj||Am> AS Bj,Am 
C
        CALL GETLST(ICORE(IW),1,NUMSYW,1,IRREPR,LISTW)
C
C  (Bj;Am) (R,L) <----- (Bj;Am) (R,R) (mi) (X)
C
        CALL DFINDT(ICORE(ID),ICORE(IW),SIJB,NUMSYD,DISSYD,
     &              DISSYW,NUMSYW,VRT(1,1),POP(1,2),POP(1,2),
     &              IRREPR,IRREPL,IRREPX,IOFFS1(1,2),1)
C
C  TRANSPOSE THE TARGET LIST    Bj;Ai --> Bj,iA
C
        CALL SYMTR1(IRREPL,VRT(1,1),POP(1,2),NUMSYD,ICORE(ID),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYD),
     &              ICORE(ITMP+2*IINTFP*NUMSYD))
C
C TRANSPOSE THE INTEGRAL LIST
C
        CALL SYMTR1(IRREPR,VRT(1,1),POP(1,2),DISSYW,ICORE(IW),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYW),
     &              ICORE(ITMP+2*IINTFP*DISSYW))
C
C  (Bj;iA) (R,L) <----- (Bj;iE) (R,R) (EA) (X)
C
        CALL DFINDT(ICORE(ID),ICORE(IW),SABA,NUMSYD,DISSYD,
     &              DISSYW,NUMSYW,POP(1,2),VRT(1,1),VRT(1,1),
     &              IRREPR,IRREPL,IRREPX,IOFFS2(1,1),1)
C
C
C  TRANSPOSE THE TARGET LIST    Bj;iA --> Bj,Ai
C
        CALL SYMTR1(IRREPL,POP(1,2),VRT(1,1),NUMSYD,ICORE(ID),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYD),
     &              ICORE(ITMP+2*IINTFP*NUMSYD))
C
       ENDIF 
C
C ALL DONE, SAVE THE INTEGRAL DERIVATIVES ON DISK
C HOWEVER, EACH CONTRIBUTION HAS TO BE ADDED TWICE TO THE
C CORRESPONDING INTEGRAL DERIVATIVES
C
C  FIRST, WE HAVE TO ADD    (R,L) TYPES WITH DERIVATIVES TAKEN
C  WITH RESPECT TO THE LEFT SIDE
C  SECOND WE HAVE TO TRANSPOSE THE WHOLE STUFF AND HAVE TO
C  ADD IT TO THOSE DERIVATIVES WHERE IT CORRESPONDS TO 
C  THE DERIVATIVES TAKEN WITh RESPECT TO THE LEFT SIDE
C
C  IRREPR LT IRREPL (MEANING FIRST CONTRIBUTION) AND NOT STERM,
C  INITIALIZE LIST, OTHERWISE UPDATE
C
       call checksum('d2iajb d',icore(id),numsyd*dissyd)
       IF((IRREPR.GT.IRREPL).OR.STERM) THEN
C
C UPDATE
C
        ID2=IREST
        IEND=ID2+IINTFP*NUMSYD*DISSYD
        IF(IEND.GE.MXCOR) CALL INSMEM('D2IAJB4',IEND,MXCOR)
C
C GET INTEGRAL DERIVATIVES FROM DISK
C
        CALL GETLST(ICORE(ID2),1,DISSYD,1,IRREPL,LISTD)
C
        CALL SAXPY(NUMSYD*DISSYD,ONE,ICORE(ID),1,ICORE(ID2),1)
C
        CALL PUTLST(ICORE(ID2),1,DISSYD,1,IRREPL,LISTD)
        call checksum('d2iajb t',icore(id2),numsyd*dissyd)
C
       ELSE  
C
C INITIALIZE
C
        CALL PUTLST(ICORE(ID),1,DISSYD,1,IRREPL,LISTD)
C
       ENDIF
C 
C  TRANSPOSE TARGET LIST
C
       ID2=IREST
       IEND=ID2+IINTFP*NUMSYD*DISSYD
       IF(IEND.GE.MXCOR) CALL INSMEM('D2IAJB5',IEND,MXCOR)
C
       CALL TRANSP(ICORE(ID),ICORE(ID2),DISSYD,NUMSYD)
C
       IF((IRREPR.GE.IRREPL).OR.STERM) THEN
C
C UPDATE
C
        CALL GETLST(ICORE(ID),1,NUMSYD,1,IRREPR,LISTD)
C
        IF(.NOT.ANTI) THEN
         CALL SAXPY(NUMSYD*DISSYD,ONE,ICORE(ID2),1,ICORE(ID),1)
        ELSE
         CALL SAXPY(NUMSYD*DISSYD,ONEM,ICORE(ID2),1,ICORE(ID),1)
        ENDIF
C
        CALL PUTLST(ICORE(ID),1,NUMSYD,1,IRREPR,LISTD)
        call checksum('d2iajb t',icore(id),numsyd*dissyd)
C
       ELSE
C
C INITIALIZE
C
        CALL PUTLST(ICORE(ID2),1,NUMSYD,1,IRREPR,LISTD)
C
       ENDIF
C
1000  CONTINUE
C
C ALL DONE SO FAR, WRITE OUT INFO MESSAGE AND GET CPU-TIMINGS
C
      CALL TIMER(1)
      write(6,6000) TIMENEW
6000  FORMAT(' Integral derivatives d <ia||jb>/d',
     &       ' chi have been formed in ',f5.1,' seconds.')
C
      RETURN
C
      END
