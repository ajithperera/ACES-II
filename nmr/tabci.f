      SUBROUTINE TABCI(ICORE,MAXCOR,UAIA,UAIB,SIJA,SIJB,
     &                 IUHF,IRREPX,IPERT)
C
C THIS ROUTINE DRIVES THE TRANSFORMATION OF THE AO-2E-INTEGRALS
C TO THE MO-BASIS WITH THE FIRST INDEX REFERING TO A PERTURBED 
C OCCUPIED ORBITAL AND THE REMAINING INDEX REFERING TO UNPERTURBED
C VIRTUAL MOS.
C
CEND
C
C  JG, UNIVERSITY KARLSRUHE
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL RHF,NLEFT
      INTEGER DIRPRD,AOPOP,POP,VRT
      CHARACTER*4 NAME(4) 
C           
      DIMENSION ICORE(MAXCOR)
      DIMENSION UAIA(1),UAIB(1),SIJA(1),SIJB(1)
      DIMENSION ISIZE2(8),ISIZE3(8),ISIZE4(8),
     &          IOFFAO(8),NSIZE2(8),ISIZT(8,8),
     &          ISIZE22(8,8),ISIZE32(8,8),ISIZE42(8,8),
     &          ISIZE24(8,8),ISIZE34(8,8,8),ISIZE44(8,8,8),
     &          IOFF2(8,8,8),IOFF4(8,8),ISIZE3T(8,8),
     &          ISIZE3TT(8),IOFFI(8),NSTART(8),NEND(8)
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/INFO/NOCCO(2),NVRTO(2)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/SYMINF/NDUMMY,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/AOPOPS/AOPOP(8)
      COMMON/AOOFST/INDOCC(8,2)
      COMMON/INFOT/NPASS1,NPASS2,NPASS3,NPASS4,
     &             NREAD1,NREAD2,NREAD3,NREAD4,
     &             TIME1L,TIME2L,TIME3L,TIME4L,
     &             TIME1S,TIME2S,TIME3S,TIME4S
      COMMON /TIMEINFO/ TIMEIN, TIMENOW, TIMETOT, TIMENEW 
C
      DATA ZERO/0.D0/
      DATA NAME/'IIII','IIJJ','IJIJ','IJKL'/
C
      NNP1O2(I)=(I*(I+1))/2
C
      CALL TIMER(1)
C
      NPASS1=0
      NPASS2=0
      NPASS3=0
      NPASS4=0
      TIME1L=ZERO
      TIME2L=ZERO
      TIME3L=ZERO
      TIME4L=ZERO
      TIME1S=ZERO
      TIME2S=ZERO
      TIME3S=ZERO
      TIME4S=ZERO
C
      WRITE(6,20000) 
20000 FORMAT(' Formation of <ab||ci>^chi using AO integrals:')
C
C SET MXCOR
C
      MXCOR=MAXCOR
C
C SET RHF/UHF FLAG AS WELL AS NBAS AND NBAS2
C
      RHF=IUHF.EQ.0
      NBAS=NOCCO(1)+NVRTO(1)
      NBAS2=NBAS*NBAS
C
 
C GET EIGENVECTORS
C
      I000=1
      I010=I000+NBAS2*(1+IUHF)*IINTFP 
      CALL PROCEVEC(ICORE,MXCOR,IUHF)
C
C DETERMINE MAXIMUM DISTRIBUTION LENGTHS (ONLY LIST 316)
C
      MAXDIS=0
      DO 1 IRREP=1,NIRREP
       MAXDIS=MAX(MAXDIS,IRPDPD(IRREP,ISYTYP(1,330)))
1     CONTINUE
C
C FORM PERTURBED EIGEN VECTORS
C
      I020=I010+(NOCCO(1)+IUHF*NOCCO(2))*NBAS*IINTFP
C
      CALL FPMO(ICORE(I000),ICORE(I010),UAIA,UAIB,SIJA,SIJB,
     &          IRREPX,IUHF)
C
      write(6,20100) NAME(1)
20100 FORMAT(' Transformation of ',A4,' integrals:')
C
C CREATE LOOK UP VECTOR FOR IRREP OF EACH AO
C
      I030=I020+NBAS
      IF(MOD(I030,IINTFP).NE.1) I030=I030+1
      IND=0
      DO 2 IRREP=1,NIRREP
       DO 2 I=1,AOPOP(IRREP)
        ICORE(I020+IND)=IRREP
        IND=IND+1
2     CONTINUE
C
C ALLOCATE MEMORY FOR INTEGRAL BUFFERS
C
      ILNBUF=600
      I040=I030+ILNBUF*IINTFP
      I050=I040+ILNBUF
C
C LOAD UP AO INTEGRALS
C
C    MEMORY ALLOCATION FOR LOADS STEP
C
C     I000  ..... MO COEFFICIENTS
C     I010  ..... PERTURBED MO COEFFICIENTS (OCCUPIED ORBITALS ONLY)
C     I020  ..... LOOK-UP VECTOR
C     I030  ..... INTEGRAL BUFFER (VALUES)
C     I040  ..... INTEGRAL BUFFER (INDICES)
C     I050  ..... INTEGRAL ARRAY
C     I060  ..... SCRATCH ARRAY
C
      CALL IZERO(IOFFAO,8)
      CALL IZERO(IOFFI,8)
      CALL IZERO(ISIZE3,8)
C
      DO 1001 IRREP=1,NIRREP
       NSTART(IRREP)=1
       NEND(IRREP)=POP(IRREP,1)
1001  CONTINUE
C
      NSIZE=0
      MSIZE=0
      MSIZE1=0
      IAO=0
      DO 1010 IRREPR=1,NIRREP
       IRREPL=DIRPRD(IRREPX,IRREPR)
       IOFFAO(IRREPR)=IAO
       IAO=IAO+AOPOP(IRREPR)
       IOFFI(IRREPR)=NSIZE
       ISIZ2=NNP1O2(AOPOP(IRREPL))
       ISIZE3(IRREPR)=ISIZ2*AOPOP(IRREPL)
       NSIZE=NSIZE+ISIZE3(IRREPR)*POP(IRREPR,1)
       MSIZE=MAX(MSIZE,ISIZE3(IRREPR))
       MSIZE1=MAX(MSIZE1,AOPOP(IRREPR)*AOPOP(IRREPR))
1010  CONTINUE
C
      MSIZE=MSIZE+MAX(MSIZE1,MAXDIS)
C
      I060=I050+NSIZE*IINTFP
      IEND=I060+MAX(NOCCO(1),MSIZE)*IINTFP
      NLEFT=.FALSE.
C
      IF(IEND.LT.MXCOR) GO TO 1030
C
C OUT-OF-CORE ALGORITHM
C
1025  CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
      CALL IZERO(NEND,NIRREP)
      NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
      MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I050+1
      MEM=MEMLEFT/IINTFP
      IF(MEM.LT.0) CALL INSMEM('TABCI1A',MEM,MXCOR)
      NUMTOT=0
      DO 1028 IRREP1=1,NIRREP
       NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
       IF(NUMLEFT.EQ.0) THEN
        NEND(IRREP1)=NSTART(IRREP1)-1
       ELSE
        NUMTREAT=MEM/ISIZE3(IRREP1)
        IF(NUMTREAT.LT.NUMLEFT) THEN
         NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
         NUMTOT=NUMTOT+NUMTREAT
         GO TO 1029
        ELSE
         NEND(IRREP1)=POP(IRREP1,1)
         MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
         NUMTOT=NUMTOT+POP(IRREP1,1)
        ENDIF
       ENDIF
1028  CONTINUE
      NLEFT=.FALSE.
1029  CONTINUE
C
      IF(NLEFT.AND.NUMTOT.EQ.0)
     &       CALL INSMEM('TABCI1B',IEND,MXCOR)
C
      NSIZE=0
      DO 1040 IRREP=1,NIRREP
       IOFFI(IRREP)=NSIZE
       NSIZE=NSIZE+ISIZE3(IRREP)*(NEND(IRREP)-NSTART(IRREP)+1)
1040  CONTINUE
C
C ALLOCATE ADDITIONAL MEMORY
C
      I060=I050+NSIZE*IINTFP
      IEND=I060+MAX(NOCCO(1),MSIZE)*IINTFP
      IF(IEND.GE.MXCOR) CALL INSMEM('TABCI1',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
1030  CONTINUE
C
      CALL LOADS1(ICORE(I010),ICORE(I050),ICORE(I060),ICORE(I030), 
     &            ICORE(I040),ICORE(I020),AOPOP,NSTART,NEND,
     &            ISIZE3,IOFFAO,IOFFI,NSIZE,ILNBUF,IPERT,1, 
     &            IRREPX)
      CALL SINTRN1(ICORE(I000),ICORE(I050),ICORE(I060),RHF,
     &             NSTART,NEND,POP(1,1),VRT(1,1),1,IRREPX)
C
C
C CHECK IF A SECOND PASS IS REQUIRED
C
      IF(NLEFT) THEN
       DO 1060 IRREP1=1,NIRREP
        NSTART(IRREP1)=NEND(IRREP1)+1
1060   CONTINUE
       GO TO 1025
      ENDIF
C
      IF(NPASS1.EQ.1) THEN
       WRITE(6,20111) NPASS1
      ELSE IF(NPASS1.LE.9) THEN
       WRITE(6,20121) NPASS1
      ELSE
       WRITE(6,20131) NPASS1
      ENDIF 
      WRITE(6,20102) NREAD1,NAME(1)
      WRITE(6,20103) TIME1L 
      WRITE(6,20104) TIME1S
20111 FORMAT(I2,' pass through the AO integral',
     &          ' file was needed.')
20121 FORMAT(I2,' passes through the AO integral',
     &          ' file were needed.')
20131  FORMAT(I3,' passes through the AO integral',
     &           ' file were needed.')
20102 FORMAT(I10,' AO integrals were read from file ',A4,'.')
20103 FORMAT(' Tranformation of first (perturbed) index required ',
     &       f5.1,' seconds.')
20104 FORMAT(' Tranformation of remaining (unperturbed) indices ',
     &       'required ',f5.1,' seconds.')
C
      IF(NIRREP.NE.1) THEN
C
       write(6,20100) NAME(2)
C 
       CALL IZERO(IOFFAO,8)
       CALL IZERO(ISIZE2,8)
       CALL IZERO(ISIZE3,8)
       CALL IZERO(ISIZE4,8)
       CALL IZERO(NSIZE2,8)
       CALL IZERO(ISIZT,64)
C
       DO 2001 IRREP=1,NIRREP
        NSTART(IRREP)=1
        NEND(IRREP)=POP(IRREP,1)
2001   CONTINUE
C
       NSIZE=0
       MSIZE=0
       MSIZE1=0
       MSIZE2=0
       IAO=0
       DO 2010 IRREP=1,NIRREP
C
        IOFFAO(IRREP)=IAO
        IAO=IAO+AOPOP(IRREP)
        ISIZE2(IRREP)=NNP1O2(AOPOP(IRREP))
        DO 2009 IRREP1=1,NIRREP
         ISIZT(IRREP1,IRREP)=NSIZE2(IRREP1)
         IF(IRREP.NE.IRREP1) THEN
          NSIZE2(IRREP1)=NSIZE2(IRREP1)+ISIZE2(IRREP)
          MSIZE1=MAX(MSIZE1,AOPOP(IRREP)*AOPOP(IRREP)*AOPOP(IRREP1))
          MSIZE2=MAX(MSIZE2,2*AOPOP(IRREP1)*AOPOP(IRREP))
         ENDIF
2009    CONTINUE
2010   CONTINUE
C
       DO 2015 IRREP=1,NIRREP
        IRREPR=DIRPRD(IRREP,IRREPX)
        ISIZE3(IRREP)=NSIZE2(IRREP)*AOPOP(IRREP)
        IOFFI(IRREP)=NSIZE
        NSIZE=NSIZE+ISIZE3(IRREP)*POP(IRREPR,1)
        MSIZE=MAX(MSIZE,ISIZE3(IRREP),2*AOPOP(IRREP)*
     &            AOPOP(IRREP))
2015   CONTINUE
C
       MSIZE=MAX(MSIZE,MSIZE1+MAX(MSIZE2,MAXDIS))
C
       I060=I050+NSIZE*IINTFP
       IEND=I060+MAX(NOCCO(1),MSIZE)*IINTFP
       NLEFT=.FALSE.
C
       IF(IEND.LT.MXCOR) GO TO 2030
C
C OUT-OF-CORE ALGORITHM
C
2025   CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
       CALL IZERO(NEND,NIRREP)
       NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
       MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I050+1
       MEM=MEMLEFT/IINTFP
       IF(MEM.LT.0) CALL INSMEM('TABCI2A',MEM,MXCOR)
       NUMTOT=0
       DO 2028 IRREP1=1,NIRREP
        IRREP1L=DIRPRD(IRREPX,IRREP1)
        NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
        IF(NUMLEFT.EQ.0) THEN
         NEND(IRREP1)=NSTART(IRREP1)-1
        ELSE
         NUMTREAT=MEM/ISIZE3(IRREP1L)
         IF(NUMTREAT.LT.NUMLEFT) THEN
          NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
          NUMTOT=NUMTOT+NUMTREAT
          GO TO 2029
         ELSE
          NEND(IRREP1)=POP(IRREP1,1)
          MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1L)
          NUMTOT=NUMTOT+POP(IRREP1,1)
         ENDIF
        ENDIF
2028   CONTINUE
       NLEFT=.FALSE.
2029   CONTINUE
C
       IF(NLEFT.AND.NUMTOT.EQ.0)
     &        CALL INSMEM('TABCI2B',IEND,MXCOR)
C
       NSIZE=0
       DO 2040 IRREP=1,NIRREP
        IRREPR=DIRPRD(IRREP,IRREPX)
        IOFFI(IRREP)=NSIZE
        NSIZE=NSIZE+ISIZE3(IRREP)*(NEND(IRREPR)-NSTART(IRREPR)+1)
2040   CONTINUE
C
C ALLOCATE ADDITIONAL MEMORY
C
       I060=I050+NSIZE*IINTFP
       IEND=I060+MAX(NOCCO(1),MSIZE)*IINTFP
       IF(IEND.GE.MXCOR) CALL INSMEM('TABCI2',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
2030   CONTINUE
C
       CALL LOADS2(ICORE(I010),ICORE(I050),ICORE(I060),ICORE(I030), 
     &             ICORE(I040),ICORE(I020),AOPOP,NSTART,NEND,
     &             ISIZE3,ISIZT,IOFFAO,IOFFI,NSIZE,ILNBUF,IPERT,1, 
     &             IRREPX)
       CALL SINTRN2(ICORE(I000),ICORE(I050),ICORE(I060),RHF,
     &              NSTART,NEND,POP(1,1),VRT(1,1),1,IRREPX)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
       IF(NLEFT) THEN
        DO 2060 IRREP1=1,NIRREP
         NSTART(IRREP1)=NEND(IRREP1)+1
2060    CONTINUE
        GO TO 2025
       ENDIF
C
       IF(NPASS2.EQ.1) THEN
        WRITE(6,20111) NPASS2
       ELSE IF(NPASS2.LE.9) THEN
        WRITE(6,20121) NPASS2
       ELSE
        WRITE(6,20131) NPASS2
       ENDIF 
       WRITE(6,20102) NREAD2,NAME(2)
       WRITE(6,20103) TIME2L 
       WRITE(6,20104) TIME2S
C
       write(6,20100) NAME(3)
C
       CALL IZERO(IOFFAO,8)
       CALL IZERO(ISIZE3,8)
       CALL IZERO(ISIZE22,64)
       CALL IZERO(ISIZE32,64)
       CALL IZERO(ISIZE42,64)
       CALL IZERO(IOFF2,64)
C
       DO 3001 IRREP=1,NIRREP
        NSTART(IRREP)=1
        NEND(IRREP)=POP(IRREP,1)
3001   CONTINUE
C
       NSIZE=0
       MSIZE=0
       MSIZE1=0
       IAO=0
       DO 3010 IRREP1=1,NIRREP
        IRREP1R=DIRPRD(IRREPX,IRREP1)
        IOFFAO(IRREP1)=IAO
        IAO=IAO+AOPOP(IRREP1)
        DO 3011 IRREP2=1,NIRREP
         IF(IRREP1.EQ.IRREP2) GO TO 3011
         ISIZE22(IRREP1,IRREP2)=AOPOP(IRREP1)*AOPOP(IRREP2)
         ISIZE32(IRREP1,IRREP2)=AOPOP(IRREP2)*ISIZE22(IRREP1,
     &                          IRREP2)
         ISIZE42(IRREP1,IRREP2)=ISIZE32(IRREP1,IRREP2)*
     &                          POP(IRREP1R,1)
         ISIZE3(IRREP1R)=ISIZE3(IRREP1R)+ISIZE32(IRREP1,IRREP2) 
3011    CONTINUE
3010   CONTINUE
       IOFF=0
       DO 3015 IRREP1=1,NIRREP
        DO 3016 IRREP2=1,NIRREP
         IF(IRREP1.EQ.IRREP2) GO TO 3016
         IOFF4(IRREP1,IRREP2)=IOFF
         IOFF=IOFF+ISIZE42(IRREP1,IRREP2)
         MSIZE=MAX(MSIZE,ISIZE32(IRREP1,IRREP2))
         MSIZE1=MAX(MSIZE1,2*AOPOP(IRREP1)*AOPOP(IRREP2))
3016    CONTINUE
3015   CONTINUE
       NSIZE=IOFF
C
       MSIZE=MSIZE+MAX(MSIZE1,MAXDIS)
C
       I060=I050+NSIZE*IINTFP
       IEND=I060+MAX(NOCCO(1),MSIZE)*IINTFP
       NLEFT=.FALSE.
C
       IF(IEND.LT.MXCOR) GO TO 3030
C
C OUT-OF-CORE ALGORITHM
C
3025   CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
       CALL IZERO(NEND,NIRREP)
       NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
       MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I050+1
       MEM=MEMLEFT/IINTFP
       IF(MEM.LT.0) CALL INSMEM('TABCI3A',MEM,MXCOR)
       NUMTOT=0
       DO 3028 IRREP1=1,NIRREP
        NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
        IF(NUMLEFT.EQ.0) THEN
         NEND(IRREP1)=NSTART(IRREP1)-1
        ELSE
         NUMTREAT=MEM/ISIZE3(IRREP1)
         IF(NUMTREAT.LT.NUMLEFT) THEN
          NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
          NUMTOT=NUMTOT+NUMTREAT
          GO TO 3029
         ELSE
          NEND(IRREP1)=POP(IRREP1,1)
          MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
          NUMTOT=NUMTOT+POP(IRREP1,1)
         ENDIF
        ENDIF
3028   CONTINUE
       NLEFT=.FALSE.
3029   CONTINUE
C
       IF(NLEFT.AND.NUMTOT.EQ.0)
     &        CALL INSMEM('TABCI3B',IEND,MXCOR)
C
       DO 3035 IRREP1=1,NIRREP
        IRREP1R=DIRPRD(IRREPX,IRREP1)
        DO 3036 IRREP2=1,NIRREP
         IF(IRREP1.EQ.IRREP2) GO TO 3036
         ISIZE42(IRREP1,IRREP2)=ISIZE32(IRREP1,IRREP2)*
     &                          (NEND(IRREP1R)-NSTART(IRREP1R)+1)
3036    CONTINUE
3035   CONTINUE
       IOFF=0
       DO 3040 IRREP1=1,NIRREP
        DO 3050 IRREP2=1,NIRREP
         IF(IRREP1.EQ.IRREP2) GO TO 3050
         IOFF4(IRREP1,IRREP2)=IOFF
         IOFF=IOFF+ISIZE42(IRREP1,IRREP2)
3050    CONTINUE
3040   CONTINUE
       NSIZE=IOFF
C
C ALLOCATE ADDITIONAL MEMORY
C
       I060=I050+NSIZE*IINTFP
       IEND=I060+MAX(NOCCO(1),MSIZE)*IINTFP
       IF(IEND.GE.MXCOR) CALL INSMEM('TABCI3',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
3030   CONTINUE
C
       CALL LOADS3(ICORE(I010),ICORE(I050),ICORE(I060),ICORE(I030), 
     &             ICORE(I040),ICORE(I020),AOPOP,NSTART,NEND,
     &             IOFFAO,IOFF4,ISIZE32,NSIZE,ILNBUF,IPERT,1, 
     &             IRREPX)
       CALL SINTRN3(ICORE(I000),ICORE(I050),ICORE(I060),RHF,
     &              NSTART,NEND,POP(1,1),VRT(1,1),1,IRREPX)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
       IF(NLEFT) THEN
        DO 3060 IRREP1=1,NIRREP
         NSTART(IRREP1)=NEND(IRREP1)+1
3060    CONTINUE
        GO TO 3025
       ENDIF
C
       IF(NPASS3.EQ.1) THEN
        WRITE(6,20111) NPASS3
       ELSE IF(NPASS3.LE.9) THEN
        WRITE(6,20121) NPASS3
       ELSE
        WRITE(6,20131) NPASS3
       ENDIF 
       WRITE(6,20102) NREAD3,NAME(3)
       WRITE(6,20103) TIME3L 
       WRITE(6,20104) TIME3S
C
       IF(NIRREP.NE.2) THEN
C
        write(6,20100) NAME(4)
C
        CALL IZERO(IOFFAO,8)
        CALL IZERO(ISIZE24,64)
        CALL IZERO(ISIZE34,512)
        CALL IZERO(ISIZE44,512)
        CALL IZERO(ISIZE3T,64)
c Nevin - there is no array ISIZ3TT, I don't know how this ever worked.
c        CALL IZERO(ISIZ3TT,8)
        CALL IZERO(ISIZE3,8)
        CALL IZERO(IOFF2,512)
        CALL IZERO(IOFF4,64)
C
        DO 4001 IRREP=1,NIRREP
         NSTART(IRREP)=1
         NEND(IRREP)=POP(IRREP,1)
4001    CONTINUE
C
        NSIZE=0
        MSIZE=0
        MSIZE1=0
        MSIZE2=0
        IAO=0
        DO 4010 IRREP1=1,NIRREP
         IOFFAO(IRREP1)=IAO
         IAO=IAO+AOPOP(IRREP1)
         DO 4011 IRREP2=1,NIRREP
          IRREP12=DIRPRD(IRREP1,IRREP2)
          IF(IRREP12.NE.1) THEN
           ISIZE24(IRREP1,IRREP2)=AOPOP(IRREP1)*AOPOP(IRREP2) 
           DO 4012 IRREP3=1,NIRREP
            IF(IRREP1.NE.IRREP3.AND.IRREP2.NE.IRREP3) THEN
             IRREP4=DIRPRD(IRREP3,IRREP12)
             IRREP4X=DIRPRD(IRREPX,IRREP4)
             ISIZE34(IRREP3,IRREP1,IRREP2)=AOPOP(IRREP3)
     &             *ISIZE24(IRREP1,IRREP2)
             ISIZE44(IRREP3,IRREP1,IRREP2)=
     &              ISIZE34(IRREP3,IRREP1,IRREP2)
     &             *POP(IRREP4X,1)
            ENDIF
4012       CONTINUE
          ENDIF
4011     CONTINUE
4010    CONTINUE
C
C DETERMINE REQUIRED OFFSET
C
        IOFF=0
C
C SLOWEST INDEX (OCCUPIED ORBITALS ONLY)
C
        DO 4013 IRREP4=1,NIRREP
         IRREP4X=DIRPRD(IRREP4,IRREPX)
C
C SECOND SLOWEST INDEX
C
         DO 4014 IRREP3=1,NIRREP
          IF(IRREP3.NE.IRREP4) THEN
           IRREP12=DIRPRD(IRREP3,IRREP4)
C
C THIRD SLOWEST INDEX (SHOULD ALWAYS BE GREATER THAN IRREP2)
C
           IOFF22=0
           IOFF4(IRREP4,IRREP3)=IOFF
           ITMP=0
           DO 4015 IRREP2=1,NIRREP
            IF(IRREP3.NE.IRREP2.AND.IRREP4.NE.IRREP2) THEN
C
C FASTEST INDEX
C
             IRREP1=DIRPRD(IRREP12,IRREP2)
             IF(IRREP1.LT.IRREP2) THEN
              ITMP=ITMP+AOPOP(IRREP1)*AOPOP(IRREP2)
              MSIZE1=MAX(MSIZE1,
     &                   AOPOP(IRREP1)*AOPOP(IRREP2)*AOPOP(IRREP3))
              IOFF2(IRREP3,IRREP1,IRREP2)=IOFF22
              IOFF2(IRREP3,IRREP2,IRREP1)=IOFF22
              IOFF22=IOFF22+AOPOP(IRREP1)*AOPOP(IRREP2)
              IOFF=IOFF+ISIZE44(IRREP3,IRREP1,IRREP2)
              ISIZE3(IRREP4X)=ISIZE3(IRREP4X)
     &                        +ISIZE34(IRREP3,IRREP1,IRREP2)
             ENDIF
            ENDIF
4015       CONTINUE
           MSIZE=MAX(MSIZE,ITMP*AOPOP(IRREP3))
           MSIZE2=MAX(MSIZE2,2*AOPOP(IRREP1)*AOPOP(IRREP2))
          ENDIF
4014     CONTINUE
4013    CONTINUE
C
        DO 4016 IRREP1=1,NIRREP
         DO 4017 IRREP2=1,NIRREP
          IF(IRREP2.EQ.IRREP1) GO TO 4017
          IRREP12=DIRPRD(IRREP1,IRREP2)
          DO 4018 IRREP3=1,NIRREP
           IF(IRREP3.EQ.IRREP1.OR.IRREP3.EQ.IRREP2) GO TO 4018
           IRREP4=DIRPRD(IRREP3,IRREP12)
           IF(IRREP4.LT.IRREP3) THEN
            ISIZE3T(IRREP1,IRREP2)=ISIZE3T(IRREP1,IRREP2)+
     &                      ISIZE34(IRREP2,IRREP3,IRREP4)
            ISIZE3TT(IRREP1)=ISIZE3TT(IRREP1)+
     &                      ISIZE34(IRREP2,IRREP3,IRREP4)
           ENDIF
4018      CONTINUE
4017     CONTINUE
4016    CONTINUE
C
        MSIZE=MAX(MSIZE,MSIZE1+MAX(MSIZE2,MAXDIS))
C
        NSIZE=IOFF
C
        I060=I050+NSIZE*IINTFP
        IEND=I060+MAX(NOCCO(1),MSIZE)*IINTFP
        NLEFT=.FALSE.
C
        IF(IEND.LT.MXCOR) GO TO 4030
C
C OUT-OF-CORE ALGORITHM
C
4025    CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
        CALL IZERO(NEND,NIRREP)
        NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
        MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I050+1
        MEM=MEMLEFT/IINTFP
        IF(MEM.LT.0) CALL INSMEM('TABCI4A',MEM,MXCOR)
        NUMTOT=0
        DO 4028 IRREP1=1,NIRREP
         NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
         IF(NUMLEFT.EQ.0) THEN
          NEND(IRREP1)=NSTART(IRREP1)-1
         ELSE
          NUMTREAT=MEM/ISIZE3(IRREP1)
          IF(NUMTREAT.LT.NUMLEFT) THEN
           NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
           NUMTOT=NUMTOT+NUMTREAT
           GO TO 4029
          ELSE
           NEND(IRREP1)=POP(IRREP1,1)
           MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
           NUMTOT=NUMTOT+POP(IRREP1,1)
          ENDIF
         ENDIF
4028    CONTINUE
        NLEFT=.FALSE.
4029    CONTINUE
C
        IF(NLEFT.AND.NUMTOT.EQ.0)
     &         CALL INSMEM('TABCI4B',IEND,MXCOR)
        NSIZE=0
        DO 4031 IRREP1=1,NIRREP
         DO 4032 IRREP2=1,NIRREP
          IRREP12=DIRPRD(IRREP1,IRREP2)
          IF(IRREP12.NE.1) THEN
           DO 4033 IRREP3=1,NIRREP
            IF(IRREP1.NE.IRREP3.AND.IRREP2.NE.IRREP3) THEN
             IRREP4=DIRPRD(IRREP3,IRREP12)
             IRREP4X=DIRPRD(IRREPX,IRREP4)
             ISIZE44(IRREP3,IRREP1,IRREP2)=
     &              ISIZE34(IRREP3,IRREP1,IRREP2)
     &             *(NEND(IRREP4X)-NSTART(IRREP4X)+1)
            ENDIF
4033       CONTINUE
          ENDIF
4032     CONTINUE
4031    CONTINUE
C
C DETERMINE REQUIRED OFFSET
C
        IOFF=0
C
C SLOWEST INDEX (OCCUPIED ORBITALS ONLY)
C
        DO 4043 IRREP4=1,NIRREP
         IRREP4X=DIRPRD(IRREP4,IRREPX)
C
C SECOND SLOWEST INDEX
C
         DO 4044 IRREP3=1,NIRREP
          IF(IRREP3.NE.IRREP4) THEN
           IRREP12=DIRPRD(IRREP3,IRREP4)
C
C THIRD SLOWEST INDEX (SHOULD ALWAYS BE GREATER THAN IRREP2)
C
           IOFF22=0
           IOFF4(IRREP4,IRREP3)=IOFF
           ITMP=0
           DO 4045 IRREP2=1,NIRREP
            IF(IRREP3.NE.IRREP2.AND.IRREP4.NE.IRREP2) THEN
C
C FASTEST INDEX
C
             IRREP1=DIRPRD(IRREP12,IRREP2)
             IF(IRREP1.LT.IRREP2) THEN
              ITMP=ITMP+AOPOP(IRREP1)*AOPOP(IRREP2)
              IOFF2(IRREP3,IRREP1,IRREP2)=IOFF22
              IOFF2(IRREP3,IRREP2,IRREP1)=IOFF22
              IOFF22=IOFF22+AOPOP(IRREP1)*AOPOP(IRREP2)
              IOFF=IOFF+ISIZE44(IRREP3,IRREP1,IRREP2)
             ENDIF
            ENDIF
4045       CONTINUE
          ENDIF
4044     CONTINUE
4043    CONTINUE
C
        NSIZE=IOFF
C
C ALLOCATE ADDITIONAL MEMORY
C
        I060=I050+NSIZE*IINTFP
        IEND=I060+MAX(NOCCO(1),MSIZE)*IINTFP
        IF(IEND.GE.MXCOR) CALL INSMEM('TABCI4',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
4030    CONTINUE
C
        CALL LOADS4(ICORE(I010),ICORE(I050),ICORE(I060),ICORE(I030), 
     &              ICORE(I040),ICORE(I020),AOPOP,NSTART,NEND,
     &              IOFFAO,IOFF4,ISIZE3T,IOFF2,NSIZE,
     &              ILNBUF,IPERT,1,IRREPX)
C
        CALL SINTRN4(ICORE(I000),ICORE(I050),ICORE(I060),RHF,
     &               NSTART,NEND,POP(1,1),VRT(1,1),1,IRREPX)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
        IF(NLEFT) THEN
         DO 4060 IRREP1=1,NIRREP
          NSTART(IRREP1)=NEND(IRREP1)+1
4060     CONTINUE
         GO TO 4025
        ENDIF
C
        IF(NPASS4.EQ.1) THEN
         WRITE(6,20111) NPASS4
        ELSE IF(NPASS4.LE.9) THEN
         WRITE(6,20121) NPASS4
        ELSE
         WRITE(6,20131) NPASS4
        ENDIF 
        WRITE(6,20102) NREAD4,NAME(4)
        WRITE(6,20103) TIME4L 
        WRITE(6,20104) TIME4S
C
       ENDIF
C
      ENDIF
C
      CALL TIMER(1) 
C
      write(6,20200) TIMENEW
20200 FORMAT(' Transformation completed in ',f5.1,' seconds.')
C
      RETURN
      END
