      SUBROUTINE DT2IJAB(ICORE,MAXCOR,IUHF,ANTI,GRAD1)
C
C  THIS PROGRAM COMPUTED THE DERIVATIVES OF THE FIRST-ORDER T2-
C  AMPLITUDES 
C
C  d T(IJ,AB)    ab -1  d <AB||IJ>                  d fmi             d fmj
C  ---------- = D     { ---------   - SUM [T(MJ,AB) -----  - T(IM,AB) -----]
C    d chi       ij       d chi        m            d chi             d chi
C
C           d fae             d fbe
C   + SUM [ ----- T(IJ,EB) + ------ T(IJ,AE)]}
C      e    d chi             d chi 
C
C  SEE J.GAUSS UNPUBLISHED NOTES.  
C
C  FOR ROHF, THERE ARE SOME ADDITIONAL TERMS WHICH REQUIRE EITHER
C  THE USE OF SEMICANONICAL ORBITALS IN ORDER TO ELIMINATE THEM
C  OR AN ITERATIVE DETERMINATION OF THE PERTURBED AMPLITUDES.
CEND
C
C  CODED JAN/91/JG AND MAY/91 JG
C
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,POP,VRT
      INTEGER DISSYD,DISSYD2,DISSYT1,DISSYT2
      LOGICAL ANTI
C
      DIMENSION IFOO(2),IFVV(2)
      DIMENSION ICORE(MAXCOR)
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),NJUNK(18)
      COMMON/DSYM/IRREPX,IPERT,NDT(2),NDF1(2),NDF2(2),
     &            IOFFS1(8,2),IOFFS2(8,2),IOFFU(8,2)
C
      DATA ONE /1.D0/
C
C  ALLOCATE MEMORY FOR THE DERIVATIVES OF THE FOCK MATRICES
C
      IFOO(1)=1
      IFOO(2)=IFOO(1)+IUHF*IINTFP*IRPDPD(IRREPX,21)
      IFVV(1)=IFOO(2)+IINTFP*IRPDPD(IRREPX,22)
      IFVV(2)=IFVV(1)+IUHF*IINTFP*IRPDPD(IRREPX,19)
      ISTART=IFVV(2)+IINTFP*IRPDPD(IRREPX,20)
C
C  READ THE DERIVATIVES OF THE FOCK MATRICES FROM DISK
C
      CALL GETLST(ICORE(IFOO(1)),IPERT,1,1,IRREPX,176)
      CALL GETLST(ICORE(IFVV(1)),IPERT,1,1,IRREPX,178)
      IF(IUHF.EQ.1) THEN
       CALL GETLST(ICORE(IFOO(2)),IPERT,1,1,IRREPX,177)
       CALL GETLST(ICORE(IFVV(2)),IPERT,1,1,IRREPX,179)
      ENDIF
C
C  LOOP OVER ALL IRREPS
C
      DO 1000 IRREPR=1,NIRREP
C
C  IRREPR DETERMINES THE IRREP OF DT2 ON THE RIGHT SIDE
C  IRREPL IS GIVEN AS THE DIRECT PRODUCT OF IRREPR WITH
C  IRREPX
C
       IRREPL=DIRPRD(IRREPR,IRREPX)
C
C   T(EB,IJ) * FD(AE) + T(AE,IJ) FD(BE)
C
C READ FIRST THE T2(AB,IM)
C
       LISTT=46
       NUMSYD=IRPDPD(IRREPR,14)
       DISSYD=IRPDPD(IRREPL,15)
       NUMSYT1=IRPDPD(IRREPL,14)
       DISSYT1=IRPDPD(IRREPL,15)
       NUMSYT2=IRPDPD(IRREPR,14)
       DISSYT2=IRPDPD(IRREPR,15)
       ID=ISTART
       IT=ID+IINTFP*NUMSYD*DISSYD
       ITMP=IT+IINTFP*NUMSYT2*DISSYT2
       IEND=ITMP+3*IINTFP*MAX(NUMSYD,DISSYD,NUMSYT2,DISSYT2)
       IF(IEND.GT.MAXCOR) CALL INSMEM('DT2IJAB1',IEND,MXCOR) 
C
C  ZERO OUT THE TARGET ARRAY
C
       CALL IZERO(ICORE(ID),IINTFP*NUMSYD*DISSYD)
C
C  FIRST TERM :   T(Ij,Ae) f(be)(chi)
C
C GET AND TRANPOSE THE T-ARRAY
C
       CALL GETTRN(ICORE(IT),ICORE(ITMP),DISSYT2,NUMSYT2,1,IRREPR,LISTT)
C
       NUMTMP=NUMSYT2
       NUMSYT2=DISSYT2
       DISSYT2=NUMTMP
       NUMSYD2=DISSYD
       DISSYD2=NUMSYD
C
       CALL DFINDT(ICORE(ID),ICORE(IT),ICORE(IFVV(2)),
     &             DISSYD2,NUMSYD2,DISSYT2,NUMSYT2,VRT(1,1), 
     &             VRT(1,2),VRT(1,2),IRREPR,IRREPL,IRREPX,
     &             IOFFS2(1,2),1)
C
C  FOR UHF, WE HAVE TO DO AS WELL THE SECOND TERM, FOR RHF
C  IT IS GENERATED BY TRANSPOSITION OF THE FIRST
C
       IF(IUHF.EQ.1) THEN
C 
C  TRANSPOSE THE INTEGRAL ARRAY AND THE TARGET ARRAY
C      Ij;Ab ---> Ij;bA
C
        CALL SYMTR1(IRREPR,VRT(1,1),VRT(1,2),DISSYT2,ICORE(IT),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYT2),
     &              ICORE(ITMP+2*DISSYT2))
        CALL SYMTR1(IRREPL,VRT(1,1),VRT(1,2),DISSYD2,ICORE(ID),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYD2),
     &              ICORE(ITMP+2*DISSYD2))
C
        CALL DFINDT(ICORE(ID),ICORE(IT),ICORE(IFVV(1)),
     &              DISSYD2,NUMSYD2,DISSYT2,NUMSYT2,VRT(1,2),
     &              VRT(1,1),VRT(1,1),IRREPR,IRREPL,IRREPX,
     &              IOFFS2(1,1),1)
C
C  TRANSPOSE THE TARGET ARRAY BACK TO THE ORDER ---> Ij,;Ab
C
        CALL SYMTR1(IRREPL,VRT(1,2),VRT(1,1),DISSYD2,ICORE(ID),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYD2),
     &              ICORE(ITMP+2*DISSYD2))
C
       ENDIF
C
C TRANSPOSE THE TARGET ARRAY
C
       ID2=IT
       IEND=ID2+IINTFP*NUMSYD*DISSYD
       IF(IEND.GT.MAXCOR) CALL INSMEM('DT2IJAB4',IEND,MXCOR)
C
       CALL TRANSP(ICORE(ID),ICORE(ID2),NUMSYD2,DISSYD2)
C
c YAU : old
c      CALL ICOPY(IINTFP*NUMSYD*DISSYD,ICORE(ID2),1,ICORE(ID),1)
c YAU : new
       CALL DCOPY(NUMSYD*DISSYD,ICORE(ID2),1,ICORE(ID),1)
c YAU : end
C
       IT=ID+IINTFP*NUMSYD*DISSYD
       IEND=IT+IINTFP*NUMSYT1*DISSYT1
       IF(IEND.GT.MAXCOR) CALL INSMEM('DT2IJAB5',IEND,MXCOR)
C
       CALL GETLST(ICORE(IT),1,NUMSYT1,1,IRREPL,LISTT)
C
       IF(.NOT.ANTI) CALL VMINUS(ICORE(ID),DISSYD*NUMSYD)
C
       CALL DFINDT(ICORE(ID),ICORE(IT),ICORE(IFOO(2)),
     &             DISSYD,NUMSYD,DISSYT1,NUMSYT1,POP(1,1), 
     &             POP(1,2),POP(1,2),IRREPL,IRREPR,IRREPX,
     &             IOFFS1(1,2),1)
C
C  FOR UHF, WE HAVE TO DO AS WELL THE SECOND TERM, FOR RHF
C  IT IS GENERATED BY TRANSPOSITION OF THE FIRST
C
       IF(IUHF.EQ.1) THEN
C 
        ITMP=IEND
        IEND=ITMP+3*IINTFP*MAX(NUMSYD,DISSYD,NUMSYT1,DISSYT1)
        IF(IEND.GT.MAXCOR) CALL INSMEM('DT2IJAB6',IEND,MXCOR)
C
C  TRANSPOSE THE INTEGRAL ARRAY AND THE TARGET ARRAY
C      Ab;Ij ---> Ab;Ji
C
        CALL SYMTR1(IRREPL,POP(1,1),POP(1,2),DISSYT1,ICORE(IT),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYT1),
     &              ICORE(ITMP+2*DISSYT1))
        CALL SYMTR1(IRREPR,POP(1,1),POP(1,2),DISSYD,ICORE(ID),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYD),
     &              ICORE(ITMP+2*DISSYD))
C
        CALL DFINDT(ICORE(ID),ICORE(IT),ICORE(IFOO(1)),
     &              DISSYD,NUMSYD,DISSYT1,NUMSYT1,POP(1,2),
     &              POP(1,1),POP(1,1),IRREPL,IRREPR,IRREPX,
     &              IOFFS1(1,1),1)
C
C  TRANSPOSE THE TARGET ARRAY BACK TO THE FINAL ORDER ---> Ab;Ij
C
        CALL SYMTR1(IRREPR,POP(1,2),POP(1,1),DISSYD,ICORE(ID),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYD),
     &              ICORE(ITMP+2*DISSYD))
C
       ENDIF
C
       CALL VMINUS(ICORE(ID),DISSYD*NUMSYD)
C
C  ALL TERMS DONE, FOR RHF DO THE TRANSPOSITIONS
C
       IF(IUHF.EQ.0) THEN
C
        ITMP=IT
        IEND=ITMP+3*IINTFP*MAX(NUMSYD,DISSYD)
        IF(IEND.GT.MAXCOR) CALL INSMEM('DT2IJAB7',IEND,MXCOR)
C
        CALL DSYMRHF(IRREPL,IRREPR,VRT(1,1),POP(1,1),DISSYD,
     &               ICORE(ID),ICORE(ITMP),ICORE(ITMP+IINTFP*
     &               DISSYD),ICORE(ITMP+2*IINTFP*DISSYD))
C
       ENDIF
C
C ADD THE INTEGRAL DERIVATIVES
C
C   <AB||IJ> (chi) 
C
C  ALLOCATE DISK SPACE
C
       IW=ID+DISSYD*NUMSYD*IINTFP
       IEND=IW+IINTFP*DISSYD*NUMSYD
C
       IF(IEND.GT.MAXCOR) CALL  INSMEM('DT2IJAB8',IEND,MXCOR) 
C
C  READ IN INTEGRAL DERIVATIVES 
C
       CALL GETLST(ICORE(IW),1,NUMSYD,1,IRREPR,316)
C
       CALL SAXPY(NUMSYD*DISSYD,ONE,ICORE(IW),1,ICORE(ID),1)
C
C  NOW MULTIPLY WITH THE INVERSE DENOMINATOR ARRAY
C
       LISTDD=450
       CALL GETLST(ICORE(IW),1,NUMSYD,1,IRREPR,LISTDD)
C
       CALL VECPRD(ICORE(ID),ICORE(IW),ICORE(ID),NUMSYD*DISSYD)
C
       CALL PUTLST(ICORE(ID),1,NUMSYD,1,IRREPR,446)
       call  checksum('dt2ija  ',icore(id),numsyd*dissyd)
C
1000  CONTINUE
C
      RETURN
      END
