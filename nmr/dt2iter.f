      SUBROUTINE DT2ITER(ICORE,MAXCOR,ANTI,GRAD1)
C
C SOLVES ITERATIVELY FOR THE PERTURBED T2 AMPLITUDES IN THE CASE OF
C ROHF-MBPT[2] AND STANDARD ORBITALS
C
C D2 DT2(ab,ij)= ...+P(ab) SUM DT2(ae,ij)*F(be)-P(ij) SUM DT2(ab,mj)*F(mj)
C                              e                         m
C
CEND
C
C HACKED UP FROM JOHN'S ROHF-MBPT(2) ROUTINE, MAY/91 JG
C
      IMPLICIT INTEGER (A-Z)
      CHARACTER*2 SPCASE(3)
      DOUBLE PRECISION ONE,ONEM,ZILCH,X,HALF,FNDLRGAB,Z,SDOT
      DOUBLE PRECISION GRAD1
      LOGICAL ANTI
C
      DIMENSION ICORE(MAXCOR)
C
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYM/ POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/DSYM/IRREPX,IPERT,NDT(2),NDF1(2),NDF2(2),
     &            IOFFIJ(8,2),IOFFAB(8,2),IOFFAI(8,2)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON /SYMINF/ NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
C
      DATA SPCASE /'AA','BB','AB'/
      DATA ONE  /1.0/   
      DATA ONEM /-1.0/
      DATA HALF /0.5/
      DATA ZILCH /0.0/
C
      GRAD1=ZILCH
C
C SPIN CASES AA AND BB
C
      DO 5 ISPIN=1,2
       WRITE(6,1000)SPCASE(ISPIN)
1000   FORMAT(T3,'@DT2ITER-I, Beginning iterative solution for ',A2,
     &           ' perturbed T2 amplitudes.')
       Z=0.0
       DO 10 IRREPR=1,NIRREP
        IRREPL=DIRPRD(IRREPX,IRREPR)
        ITER=0
        NT2DSZ=IRPDPD(IRREPL,ISYTYP(1,13+ISPIN))
        NT2DIS=IRPDPD(IRREPR,ISYTYP(2,13+ISPIN))
        IF(MIN(NT2DIS,NT2DSZ).EQ.0)GOTO 10
        NSPACE=MAX(IRPDPD(IRREPL,18+ISPIN)*NT2DIS,
     &             IRPDPD(IRREPR,20+ISPIN)*NT2DSZ)
        DSZFUL=MAX(IRPDPD(IRREPL,18+ISPIN),IRPDPD(IRREPR,20+ISPIN)) 
        I000=1
        I010=I000+NSPACE*IINTFP
        I020=I010+NSPACE*IINTFP
        I030=I020+NFEA(ISPIN)*IINTFP
        I040=I030+NFMI(ISPIN)*IINTFP
        I050=I040+NT2DSZ*NT2DIS*IINTFP
        CALL IZERO(ICORE,I050)
C
C READ IN VV AND OO FOCK MATRICES
C
        CALL GETLST(ICORE(I020),1,1,1,2+ISPIN,92)
        CALL GETLST(ICORE(I030),1,1,1,2+ISPIN,91)
C
C READ IN INITIAL DT2 AMPLITUDES (EXCLUDING F CONTRIBUTION)
C
        CALL GETLST(ICORE(I010),1,NT2DIS,1,IRREPR,443+ISPIN)
C
C NOW TRANSPOSE AND EXPAND TO FORM T2(I<J,AE) BEFORE CALCULATING
C  INCREMENT.
C
1       CALL TRANSP(ICORE(I010),ICORE(I000),NT2DIS,NT2DSZ)
        CALL SYMEXP(IRREPL,VRT(1,ISPIN),NT2DIS,ICORE(I000))
C
C PERFORM MULTIPLICATION
C                                 
C                    Z(I<J,AB) = DT2(I<JA,E) * F(E,B)
C
        IOFFT  =I000
        IOFFTAR=I010
        IOFFF  =I020
        DO 20 IRREPE=1,NIRREP
         IRREPA=DIRPRD(IRREPE,IRREPL)
         NUMA=VRT(IRREPA,ISPIN)
         NUME=VRT(IRREPE,ISPIN)
         NUMB=NUME
         IF(MAX(NT2DIS*NUMA,NUMB,NUME).NE.0)THEN
          CALL XGEMM('N','N',NT2DIS*NUMA,NUMB,NUME,ONE,ICORE(IOFFT),
     &               NT2DIS*NUMA,ICORE(IOFFF),NUME,ZILCH,
     &              ICORE(IOFFTAR),NT2DIS*NUMA)
         ENDIF
         IOFFF=IOFFF+NUME*NUMB*IINTFP
         IOFFT=IOFFT+NT2DIS*NUMA*NUME*IINTFP
         IOFFTAR=IOFFTAR+NT2DIS*NUMA*NUME*IINTFP
20      CONTINUE
C
C NOW ANTISYMMETRIZE - Z(I<J,AB) = Z(I<J,AB) - Z(I<J,BA) AND THEN
C  TRANSPOSE TO Z(A<B,I<J). DO THIS FOR BOTH THE DT2 VECTOR AND
C  THE INCREMENT (Z)
C
        CALL ASSYM2(IRREPL,VRT(1,ISPIN),NT2DIS,ICORE(I010))
        CALL SSCAL(NT2DIS*NT2DSZ,HALF,ICORE(I010),1)
        CALL TRANSP(ICORE(I010),ICORE(I040),NT2DSZ,NT2DIS)
c YAU : old
c       CALL ICOPY(NT2DIS*NT2DSZ*IINTFP,ICORE(I040),1,ICORE(I010),1)
c YAU : new
        CALL DCOPY(NT2DIS*NT2DSZ,ICORE(I040),1,ICORE(I010),1)
c YAU : end
        CALL ASSYM2(IRREPL,VRT(1,ISPIN),NT2DIS,ICORE(I000))
        CALL SSCAL(NT2DIS*NT2DSZ,HALF,ICORE(I000),1)
        CALL TRANSP(ICORE(I000),ICORE(I040),NT2DSZ,NT2DIS)
c YAU : old
c       CALL ICOPY(NT2DIS*NT2DSZ*IINTFP,ICORE(I040),1,ICORE(I000),1)
c YAU : new
        CALL DCOPY(NT2DIS*NT2DSZ,ICORE(I040),1,ICORE(I000),1)
c YAU : end
C
C NOW DO THE F(MI) CONTRIBUTION
C
C
C FIRST EXPAND DT2 AND Z VECTORS TO Z(A<B,IJ), DT(A<B,IJ).
C
        CALL SYMEXP(IRREPR,POP(1,ISPIN),NT2DSZ,ICORE(I000))
        CALL SYMEXP(IRREPR,POP(1,ISPIN),NT2DSZ,ICORE(I010))
C
C PERFORM MULTIPLICATION
C                                 
C                    Z(A<B,IJ) = Z(A<B,IJ) + DT2(A<BI,M) * F(MJ)
C
        IOFFT  =I000
        IOFFTAR=I010
        IOFFF  =I030
        DO 120 IRREPM=1,NIRREP
         IRREPI=DIRPRD(IRREPM,IRREPR)
         NUMM=POP(IRREPM,ISPIN)
         NUMI=POP(IRREPI,ISPIN)
         NUMJ=NUMM
         IF(MAX(NT2DSZ*NUMI,NUMM,NUMJ).NE.0)THEN
          CALL XGEMM('N','N',NT2DSZ*NUMI,NUMJ,NUMM,ONEM,ICORE(IOFFT),
     &               NT2DSZ*NUMI,ICORE(IOFFF),NUMM,ONE,
     &               ICORE(IOFFTAR),NT2DSZ*NUMI)
         ENDIF
         IOFFF=IOFFF+NUMM*NUMJ*IINTFP
         IOFFT=IOFFT+NT2DSZ*NUMI*NUMM*IINTFP
         IOFFTAR=IOFFTAR+NT2DSZ*NUMI*NUMM*IINTFP
120     CONTINUE
C
C NOW ANTISYMMETRIZE - Z(A<B,I<J) = Z(A<B,IJ) - Z(A<B,JI), ADD IN
C  LEADING TERM AND DENOMINATOR WEIGHT
C
        CALL ASSYM2(IRREPR,POP(1,ISPIN),NT2DSZ,ICORE(I000))
        CALL SSCAL(NT2DIS*NT2DSZ,HALF,ICORE(I000),1)
        CALL ASSYM2(IRREPR,POP(1,ISPIN),NT2DSZ,ICORE(I010))
        CALL GETLST(ICORE(I040),1,NT2DIS,1,IRREPR,47+ISPIN)
        CALL VECPRD(ICORE(I010),ICORE(I040),ICORE(I010),NT2DIS*NT2DSZ)
        CALL GETLST(ICORE(I040),1,NT2DIS,1,IRREPR,443+ISPIN)
        CALL SAXPY(NT2DSZ*NT2DIS,ONE,ICORE(I040),1,ICORE(I010),1)
C
C COMPARE WITH PREVIOUS ITERATE
C
        CALL SAXPY(NT2DSZ*NT2DIS,ONEM,ICORE(I010),1,ICORE(I000),1)
        X=FNDLRGAB(ICORE(I000),NT2DSZ*NT2DIS)
        IF(ABS(X).GT.1.E-08)THEN
         ITER=ITER+1
c YAU : old
c        CALL ICOPY(NT2DIS*NT2DSZ*IINTFP,ICORE(I010),1,ICORE(I000),1)
c YAU : new
         CALL DCOPY(NT2DIS*NT2DSZ,ICORE(I010),1,ICORE(I000),1)
c YAU : end
         GOTO 1
        ELSE
         ITER=ITER+1
         WRITE(6,1001)IRREPR,ITER
1001     FORMAT(T3,'Irrep ',I2,' perturbed amplitudes converged in ',
     &          I4,' iterations.')
         CALL PUTLST(ICORE(I010),1,NT2DIS,1,IRREPR,443+ISPIN)
         IF(IRREPX.EQ.1) THEN
         CALL GETLST(ICORE(I000),1,NT2DIS,1,IRREPR,13+ISPIN)
         Z=SDOT(NT2DIS*NT2DSZ,ICORE(I000),1,ICORE(I010),1)
         GRAD1=GRAD1+Z
         write(*,*) 'gradient contribution T2: ',Z
         ENDIF
        ENDIF
10     CONTINUE
5     CONTINUE
C
C
C SPIN CASE AB
C
C     Z(Ab,Ij) = .... + DT(Ae,Ij)*F(be) - DT(Eb,Ij)*F(EA)
C
C                         - DT(Ab,Im)*F(mj) + DT(Ab,Mj)*F(MI)
C
      ISPIN=3
      WRITE(6,1000)SPCASE(ISPIN)
      DO 110 IRREPR=1,NIRREP
       IRREPL=DIRPRD(IRREPX,IRREPR)
       ITER=0
       NT2DSZ=IRPDPD(IRREPL,ISYTYP(1,46))
       NT2DIS=IRPDPD(IRREPR,ISYTYP(2,46))
       IF(MIN(NT2DSZ,NT2DIS).EQ.0)GOTO 110
       I000=1
       I010=I000+NT2DSZ*NT2DIS*IINTFP
       I020=I010+NT2DSZ*NT2DIS*IINTFP
       I030=I020+NT2DSZ*NT2DIS*IINTFP
C
C READ IN INITIAL GUESS T2 AMPLITUDES (NO F CONTRIBUTIONS) AND
C  TRANSPOSE FOR FIRST CONTRACTION
C
       CALL GETLST(ICORE(I000),1,NT2DIS,1,IRREPR,446)
C
C DO FEA CONTRACTION FIRST
C
101    CONTINUE
       CALL TRANSP(ICORE(I000),ICORE(I010),NT2DIS,NT2DSZ)
c YAU : old
c      CALL ICOPY(IINTFP*NT2DIS*NT2DSZ,ICORE(I010),1,ICORE(I000),1)
c YAU : new
       CALL DCOPY(NT2DIS*NT2DSZ,ICORE(I010),1,ICORE(I000),1)
c YAU : end
       CALL IZERO(ICORE(I010),NT2DIS*NT2DSZ*IINTFP)
       DO 115 ISPIN=2,1,-1
C
C READ IN VV AND OO FOCK MATRICES
C
        I040=I030+NFEA(ISPIN)*IINTFP
        I050=I040+NFMI(ISPIN)*IINTFP
        CALL GETLST(ICORE(I030),1,1,1,2+ISPIN,92)
        CALL GETLST(ICORE(I040),1,1,1,2+ISPIN,91)
C
C TRANSPOSE KET INDICES IF ISPIN=1
C
C    DT(Ij,Ab) => [for ISPIN=1] DT(Ij,bA)
C
        IF(ISPIN.EQ.1)THEN
         I060=I050+NT2DIS*IINTFP
         I070=I060+NT2DIS*IINTFP
         I080=I070+NT2DIS*IINTFP
         CALL SYMTR1(IRREPL,VRT(1,1),VRT(1,2),NT2DIS,ICORE(I010),
     &               ICORE(I050),ICORE(I060),ICORE(I070))
         CALL SYMTR1(IRREPL,VRT(1,1),VRT(1,2),NT2DIS,ICORE(I000),
     &               ICORE(I050),ICORE(I060),ICORE(I070))
        ENDIF
C
C PERFORM MULTIPLICATION
C                                 
C                    Z(Ij,bA) = DT2(Ijb,E) * F(EA) [ISPIN=1]
C
C                    Z(Ij,Ba) = DT2(Ij,Be) * F(ea) [ISPIN=2]
C
        IOFFT  =I000
        IOFFTAR=I010
        IOFFF  =I030
        DO 220 IRREPE=1,NIRREP
         IRREPB=DIRPRD(IRREPE,IRREPL)
         NUMB=VRT(IRREPB,3-ISPIN)
         NUME=VRT(IRREPE,ISPIN)
         NUMA=NUME
         IF(MAX(NT2DIS*NUMB,NUME,NUMA).NE.0)THEN
          CALL XGEMM('N','N',NT2DIS*NUMB,NUMA,NUME,ONE,ICORE(IOFFT),
     &               NT2DIS*NUMB,ICORE(IOFFF),NUME,ONE,
     &               ICORE(IOFFTAR),NT2DIS*NUMB)
         ENDIF
         IOFFF=IOFFF+NUME*NUMA*IINTFP
         IOFFT=IOFFT+NT2DIS*NUMB*NUME*IINTFP
         IOFFTAR=IOFFTAR+NT2DIS*NUMB*NUME*IINTFP
220     CONTINUE
115    CONTINUE
C
C ISPIN=1 RAN LAST SO WE HAVE TO TRANSPOSE KET INDICES BACK TO
C    DT(Ij,Ab) AND Z(Ij,Ab).  THEN TRANSPOSE TO DT(Ab,Ij) AND
C    Z(Ab,Ij) FOR FMI PART.
C
       I060=I050+NT2DIS*IINTFP
       I070=I060+NT2DIS*IINTFP
       I080=I070+NT2DIS*IINTFP
       CALL SYMTR1(IRREPL,VRT(1,2),VRT(1,1),NT2DIS,ICORE(I000),
     &             ICORE(I050),ICORE(I060),ICORE(I070))
       CALL SYMTR1(IRREPL,VRT(1,2),VRT(1,1),NT2DIS,ICORE(I010),
     &              ICORE(I050),ICORE(I060),ICORE(I070))
       CALL TRANSP(ICORE(I000),ICORE(I020),NT2DSZ,NT2DIS)
c YAU : old
c      CALL ICOPY(NT2DIS*NT2DSZ*IINTFP,ICORE(I020),1,ICORE(I000),1)
c YAU : new
       CALL DCOPY(NT2DIS*NT2DSZ,ICORE(I020),1,ICORE(I000),1)
c YAU : end
       CALL TRANSP(ICORE(I010),ICORE(I020),NT2DSZ,NT2DIS)
c YAU : old
c      CALL ICOPY(NT2DIS*NT2DSZ*IINTFP,ICORE(I020),1,ICORE(I010),1)
c YAU : new
       CALL DCOPY(NT2DIS*NT2DSZ,ICORE(I020),1,ICORE(I010),1)
c YAU : end
C
C NOW DO SECOND CONTRACTION - FMI PART
C
C         Z(Ab,Ij) = Z(Ab,Ij) + DT(Ab,Mj) * F(MI)  [ISPIN=1]
C
C         Z(Ab,Ij) = Z(Ab,Ij) + DT(Ab,Im) * F(mj)  [ISPIN=2]
C
C
C
C FOR ISPIN=1, WE HAVE TO DO A SYMTR1 ON THE DT AMPLITUDES AND
C  INCREMENTS, GIVING DT(Ab,jI) AND Z(Ab,jI).
C
       DO 116 ISPIN=2,1,-1
C
C READ IN VV AND OO FOCK MATRICES
C
        I040=I030+NFEA(ISPIN)*IINTFP
        I050=I040+NFMI(ISPIN)*IINTFP
        CALL GETLST(ICORE(I030),1,1,1,2+ISPIN,92)
        CALL GETLST(ICORE(I040),1,1,1,2+ISPIN,91)
        IF(ISPIN.EQ.1)THEN
         I060=I050+NT2DSZ*IINTFP
         I070=I060+NT2DSZ*IINTFP
         I080=I070+NT2DSZ*IINTFP
         CALL SYMTR1(IRREPR,POP(1,1),POP(1,2),NT2DSZ,ICORE(I000),
     &               ICORE(I050),ICORE(I060),ICORE(I070))
         CALL SYMTR1(IRREPR,POP(1,1),POP(1,2),NT2DSZ,ICORE(I010),
     &               ICORE(I050),ICORE(I060),ICORE(I070))
        ENDIF
C
C NOW PERFORM THE MATRIX MULTIPLICATION
C
C         Z(Ab,jI) = Z(Ab,jI) + DT(Ab,jM) * F(MI)  [ISPIN=1]
C
C         Z(Ab,Ij) = Z(Ab,Ij) + DT(Ab,Im) * F(mj)  [ISPIN=2]
C
        IOFFT=I000
        IOFFF=I040
        IOFFTAR=I010
        DO 320 IRREPM=1,NIRREP
         IRREPJ=DIRPRD(IRREPM,IRREPR)
         IRREPI=IRREPM
         NUMM=POP(IRREPM,ISPIN)
         NUMI=POP(IRREPI,ISPIN)
         NUMJ=POP(IRREPJ,3-ISPIN)
         IF(MAX(NT2DIS*NUMJ,NUMM,NUMI).NE.0)THEN
          CALL XGEMM('N','N',NT2DSZ*NUMJ,NUMI,NUMM,ONEM,ICORE(IOFFT),
     &               NT2DSZ*NUMJ,ICORE(IOFFF),NUMM,ONE,ICORE(IOFFTAR),
     &               NT2DSZ*NUMJ)
         ENDIF
         IOFFT=IOFFT+NT2DSZ*NUMJ*NUMM*IINTFP
         IOFFF=IOFFF+NUMM*NUMI*IINTFP
         IOFFTAR=IOFFTAR+NT2DSZ*NUMJ*NUMM*IINTFP
320     CONTINUE
C
C NOW TRANSPOSE KET INDICES OF TARGET AND T2 VECTOR IF ISPIN IS 1
C
C        Z(Ab,jI) -> Z(Ab,Ij)
C
        IF(ISPIN.EQ.1)THEN
         I060=I050+NT2DSZ*IINTFP
         I070=I060+NT2DSZ*IINTFP
         I080=I070+NT2DSZ*IINTFP
         CALL SYMTR1(IRREPR,POP(1,2),POP(1,1),NT2DSZ,ICORE(I000),
     &               ICORE(I050),ICORE(I060),ICORE(I070))
         CALL SYMTR1(IRREPR,POP(1,2),POP(1,1),NT2DSZ,ICORE(I010),
     &               ICORE(I050),ICORE(I060),ICORE(I070))
        ENDIF
116    CONTINUE
C
C NOW ADD IN LEADING TERM AND DENOMINATOR WEIGHT
C
       CALL GETLST(ICORE(I020),1,NT2DIS,1,IRREPR,450)
       CALL VECPRD(ICORE(I010),ICORE(I020),ICORE(I010),NT2DIS*NT2DSZ)
       CALL GETLST(ICORE(I020),1,NT2DIS,1,IRREPR,446)
       CALL SAXPY(NT2DSZ*NT2DIS,ONE,ICORE(I020),1,ICORE(I010),1)
C
C COMPARE WITH PREVIOUS ITERATE
C
       CALL SAXPY(NT2DSZ*NT2DIS,ONEM,ICORE(I010),1,ICORE(I000),1)
       X=FNDLRGAB(ICORE(I000),NT2DSZ*NT2DIS)
       IF(ABS(X).Gt.1.E-12)THEN
        ITER=ITER+1
c YAU : old
c       CALL ICOPY(NT2DIS*NT2DSZ*IINTFP,ICORE(I010),1,ICORE(I000),1)
c YAU : new
        CALL DCOPY(NT2DIS*NT2DSZ,ICORE(I010),1,ICORE(I000),1)
c YAU : end
        GOTO 101
       ELSE
        ITER=ITER+1
        WRITE(6,1001)IRREPR,ITER
        CALL PUTLST(ICORE(I010),1,NT2DIS,1,IRREPR,446)
        IF(IRREPX.EQ.1) THEN
        CALL GETLST(ICORE(I000),1,NT2DIS,1,IRREPR,16)
        Z=SDOT(NT2DIS*NT2DSZ,ICORE(I000),1,ICORE(I010),1)
        GRAD1=GRAD1+Z
        WRITE(*,*) 'gradient contribution T2 ab: ',Z
        ENDIF
       ENDIF
110   CONTINUE
      RETURN
      END
