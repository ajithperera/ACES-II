      SUBROUTINE D1IJKL(UAI,SIJ,ICORE,MXCOR,IRREPX,
     &                  IPERT,ISPIN,STERM,ANTI,GRAD1)
C
C  THIS ROUTINE CALCULATES THE DERIVATIVE INTEGRALS d <IJ||KL> / d chi
C
C   THERE ARE TWO DIFFERENT TERMS
C
CEND
C
C CODED AUG/91  JG
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,DISSYW,DISSYD,POP,VRT
      LOGICAL FIELD,GEOM,ROHF,QRHF,SEMI,STERM,ANTI
      DIMENSION ICORE(MXCOR) 
      DIMENSION UAI(1),SIJ(1)
C
      COMMON/OFFSETS/IOFFU(8,2),IOFFS1(8,2),IOFFS2(8,2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREPAA(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),NJUNK(18)
      COMMON/DTRAN/FIELD,GEOM,ROHF,QRHF,SEMI
C
      DATA AZERO,ONE /0.D0,1.D0/
C
C  INCORE ALGORITHM
C
C  DO HERE ALPHA,BETA SPIN CASE
C
C  LOOP OVER ALL IRREPS OF THE DERIVATIVE INTEGRALS
C
      DO 1000 IRREPR=1,NIRREP
C
C  THE IRREP ON THE LEFT SIDE IS THEN GIVEN AS THE DIRECT PRODUCT
C   OF IRREPP AND IRREPR
C
       IRREPL=DIRPRD(IRREPR,IRREPX)
C
C DETERMINE LENGTH OF TARGET ARRAY
C
       NUMSYD=IRPDPD(IRREPR,ISYTYP(2,10+ISPIN))
       DISSYD=IRPDPD(IRREPL,ISYTYP(1,10+ISPIN))
C
C DETERMINE FULL SIZE OF OCC-OCC BLOCK
C
       NOSQR=0
       NOSQL=0
       DO 1 IRREP=1,NIRREP
        NOSQR=NOSQR+POP(IRREP,ISPIN)*POP(DIRPRD(IRREP,IRREPR),ISPIN)
        NOSQL=NOSQL+POP(IRREP,ISPIN)*POP(DIRPRD(IRREP,IRREPL),ISPIN)
1      CONTINUE
C
C ALLOCATE CORE FOR TARGET ARRAY
C
       ID=1
       IREST=ID+IINTFP*DISSYD*NOSQR
C
C  ZERO TARGET LIST
C
        CALL ZERO(ICORE(ID),DISSYD*NOSQR)
C
C CONSIDER FIRST ALL TERMS WHICH INCLUDE U(AI)
C
C    <IJ||KE> U(EL) + <IJ||EL> U(EK)
C
C  THE IRREP ON THE LEFT SIDE IS UNCHANGED, SO IRREPL DETERMINES
C  THE LISTS OF ORIGINAL ZEROTH ORDER INTEGRALS
C
       LISTW=6+ISPIN
       NUMSYW=IRPDPD(IRREPL,ISYTYP(2,LISTW))
       DISSYW=IRPDPD(IRREPL,ISYTYP(1,LISTW))
C
C  ALLOCATE CORE MEMORY
C
       IW=IREST
       IEND=IW+IINTFP*NUMSYW*DISSYW
C
       IF(IEND.GE.MXCOR) CALL INSMEM('D1IJKL1',IEND,MXCOR)
C
C  READ IN THE <IJ||KE> 
C
        CALL GETLST(ICORE(IW),1,NUMSYW,1,IRREPL,LISTW)
C
C  (IJ;KL)(L,R) <---- (IJ;KE)(L,L) (EL) (X)
C
        CALL DFINDT(ICORE(ID),ICORE(IW),UAI,DISSYD,NOSQR,
     &              DISSYW,NUMSYW,POP(1,ISPIN),VRT(1,ISPIN),
     &              POP(1,ISPIN),IRREPL,IRREPR,IRREPX,
     &              IOFFU(1,ISPIN),1)
C
        IF(STERM) THEN
C
C CONSIDER  TERMS WHICH INCLUDE S(AE)
C
C    <IJ||KM> (-1/2 S(ML)) + <IJ||ML> (-1/2 S(MK))
C
C  THE IRREP ON THE LEFT SIDE IS UNCHANGED, SO IRREPL DETERMINES
C  THE LISTS OF ORIGINAL ZEROTH ORDER INTEGRALS
C
         LISTW=10+ISPIN
         NUMSYW=IRPDPD(IRREPL,ISYTYP(2,LISTW))
         DISSYW=IRPDPD(IRREPL,ISYTYP(1,LISTW))
C
C  ALLOCATE CORE MEMORY
C
         IW=IREST
         IEND=IW+IINTFP*DISSYW*NOSQL
C
         IF(IEND.GE.MXCOR) CALL INSMEM('D1IJKL2',IEND,MXCOR)
C
C  READ IN THE <IJ||KL> INTEGRALS
C
         CALL GETLST(ICORE(IW),1,NUMSYW,1,IRREPL,LISTW)
C
C EXPAND THE RIGHT HAND SIDE:   I<J;K<L --> I<J;KL
C
         CALL SYMEXP(IRREPL,POP(1,ISPIN),DISSYW,ICORE(IW))
C
C   (IJ,KL) (L,R) <----- (IJ,KM) (L,L) (M,Ll) (X)
C
C Missing comma was added on 03/08/97 AP.
C
          CALL DFINDT(ICORE(ID),ICORE(IW),SIJ,DISSYD,NOSQR,
     &                DISSYW,NOSQL,POP(1,ISPIN),POP(1,ISPIN),
     &                POP(1,ISPIN),IRREPL,IRREPR,IRREPX,
     &                IOFFS1(1,ISPIN),1)
        ENDIF 
C
C ANTISYMMETRIZE THE INTEGRAL DERIVATIVES 
C
       ID2=IREST  
       IEND=ID2+IINTFP*DISSYD*NUMSYD
C
       IF(IEND.GT.MXCOR) CALL INSMEM('D1IJKL3',IEND,MXCOR)
C
       CALL ASSYM(IRREPR,POP(1,ISPIN),DISSYD,DISSYD,ICORE(ID2),
     &            ICORE(ID))
C
C  SYMMETRIZE THE INTEGRAL DERIVATIVES
C
c       CALL DSYMMET1(IRREPX,ICORE(ID2),IRPDPD(1,ISYTYP(1,10+ISPIN)))
C       
c        if(sterm)then
c        call getlst(icore(iend),(ipert-1)*numsyd+1,numsyd,
c     &                2,1,310+ispin)
c        open(unit=16,form='formatted')
c        read(16,'((3f20.10))')(icore(iend-1+j),j=1,numsyd*dissyd)
c        call saxpy(numsyd*dissyd,one,icore(iend),1,icore(id2),1)
c        call scopy(numsyd*dissyd,icore(iend),1,icore(id),1)
c        close(unit=16,status='keep')
c        endif
c        CALL PUTLST(ICORE(ID),(IPERT-1)*NUMSYD+1,NUMSYD,1,
c     &             IRREPR,310+ispin)
1000  CONTINUE
C
C ALL DONE SO FAR
C
      RETURN
      END
