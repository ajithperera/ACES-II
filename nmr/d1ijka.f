

      SUBROUTINE D1IJKA(UAI,SIJ,UIA,SAB,ICORE,MXCOR,
     &                  IRREPX,IPERT,ISPIN,STERM,ANTI)
C
C  THIS ROUTINE CALCULATES THE DERIVATIVE INTEGRALS d <IJ//KB> / d chi
C
C   THERE ARE EIGHT DIFFERENT TERMS
C
CEND
C
C CODED JAN/91  JG
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,DISSYW,DISSYD,POP,VRT
      LOGICAL FIELD,GEOM,ROHF,QRHF,SEMI,STERM,ANTI
      DIMENSION ICORE(MXCOR) 
      DIMENSION UAI(1),UIA(1),SIJ(1),SAB(1)
C
      COMMON/OFFSETS/IOFFU(8,2),IOFFS1(8,2),IOFFS2(8,2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREPAA(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),NJUNK(18)
      COMMON/DTRAN/FIELD,GEOM,ROHF,QRHF,SEMI
C
      DATA AZERO,ONE /0.D0,1.D0/
C
C  INCORE ALGORITHM
C
C  DO HERE ALPHA,ALPHA (BETA,BETA) SPIN CASE
C
C  LOOP OVER ALL IRREPS OF THE DERIVATIVE INTEGRALS
C
      DO 1000 IRREPR=1,NIRREP
C
C  THE IRREP ON THE LEFT SIDE IS THEN GIVEN AS THE DIRECT PRODUCT
C   OF IRREPP AND IRREPR
C
       IRREPL=DIRPRD(IRREPR,IRREPX)
C
       NUMSYD=IRPDPD(IRREPR,ISYTYP(2,6+ISPIN))
       DISSYD=IRPDPD(IRREPL,ISYTYP(1,6+ISPIN))
C
C DETERMINE FULL SIZE OF LEFT SIDE
C
       NOSQL=0
       NVSQL=0
       NOSQR=0
       DO 1 IRREP=1,NIRREP
        NOSQL=NOSQL+POP(IRREP,ISPIN)*POP(DIRPRD(IRREPL,IRREP),ISPIN)
        NVSQL=NVSQL+VRT(IRREP,ISPIN)*VRT(DIRPRD(IRREPL,IRREP),ISPIN)
        NOSQR=NOSQR+POP(IRREP,ISPIN)*POP(DIRPRD(IRREPR,IRREP),ISPIN)
1      CONTINUE
C
C  ALLOCATE CORE MEMORY
C
       ID=1
       IW=ID+IINTFP*NUMSYD*NOSQL
C
C  ZERO TARGET LIST
C
        CALL ZERO(ICORE(ID),NUMSYD*NOSQL)
C
C CONSIDER FIRST ALL TERMS WHICH INCLUDE U(AI)
C
C    <KA//IE> U(EJ) + <KA//EJ> U(EI)
C
C  THE IRREP ON THE RIGHT SIDE IS UNCHANGED, SO IRREPR DETERMINES
C  THE LISTS OF ORIGINAL ZEROTH ORDER INTEGRALS
C
       LISTW=22+ISPIN
       NUMSYW=IRPDPD(IRREPR,ISYTYP(2,LISTW))
       DISSYW=IRPDPD(IRREPR,ISYTYP(1,LISTW))
C
C ALLOCATE MEMORY
C
       ITMP=IW+IINTFP*NUMSYW*DISSYW
       IEND=ITMP+3*IINTFP*MAX(NUMSYW,DISSYW,NUMSYD,NOSQL)
C
       IF(IEND.GE.MXCOR) CALL INSMEM('D1IJKA',IEND,MXCOR)
C
C  READ IN THE <KA//IE> (ORDER  A,K; E,I)
C
        CALL GETLST(ICORE(IW),1,NUMSYW,1,IRREPR,LISTW) 
C 
C  TRANSPOSE THE LAST TWO INDICES : A,K;E,I -->  A,K; I,E
C
        CALL SYMTR1(IRREPR,VRT(1,ISPIN),POP(1,ISPIN),
     &              DISSYW,ICORE(IW),ICORE(ITMP),
     &              ICORE(ITMP+IINTFP*DISSYW),
     &              ICORE(ITMP+2*IINTFP*DISSYW))
C
C  (AK;IJ)(R,L) <---- (AK,IE)(R,R) (E,J) (X)
C
        CALL DFINDT(ICORE(ID),ICORE(IW),UAI,NUMSYD,NOSQL,
     &              DISSYW,NUMSYW,POP(1,ISPIN),VRT(1,ISPIN),
     &              POP(1,ISPIN),IRREPR,IRREPL,IRREPX,
     &              IOFFU(1,ISPIN),1)
C
C
        IF(STERM) THEN
C
C CONSIDER ALL TERMS WHICH INCLUDE S(M,I)
C
C    <AK||IM> S(M,J) + <AK||MJ> S(M,I)
C
C  THE IRREP ON THE RIGHT SIDE IS UNCHANGED, SO IRREPR DETERMINES
C  THE LISTS OF ORIGINAL ZEROTH ORDER INTEGRALS
C
         LISTW=6+ISPIN
         NUMSYW=IRPDPD(IRREPR,ISYTYP(2,LISTW))
         DISSYW=IRPDPD(IRREPR,ISYTYP(1,LISTW))
C
C  ALLOCATE CORE MEMORY
C
         IW2=IW+IINTFP*NUMSYW*DISSYW
         IEND=IW2+IINTFP*NUMSYW*DISSYW
C
         IF(MXCOR.LE.IEND) CALL INSMEM('D1IJKA',IEND,MXCOR)
C
C  READ IN THE <AK||IJ> INTEGRALS AS I,J;K,A
C
         CALL GETLST(ICORE(IW2),1,NUMSYW,1,IRREPR,LISTW)
C
C  TRANSPOSE <IJ||KA> TO  <KA||IJ>
C
         CALL TRANSP(ICORE(IW2),ICORE(IW),NUMSYW,DISSYW)
C
         NUMTMP=NUMSYW
         NUMSYW=DISSYW
         DISSYW=NUMTMP 
C
C TRANSPOSE <KA||IJ> TO <AK||IJ>
C
         CALL SYMEXP(IRREPR,POP(1,ISPIN),DISSYW,ICORE(IW))
C
         CALL SYMTR3(IRREPR,POP(1,ISPIN),VRT(1,ISPIN),DISSYW,
     &               NUMSYW,ICORE(IW),ICORE(IW2),ICORE(IW2+IINTFP*
     &               NUMSYW),ICORE(IW2+2*IINTFP*NUMSYW))
C
C  (AK;IJ) (R,L) <----- (AK,IM) (R,R) (M,J) (X)
C
         CALL DFINDT(ICORE(ID),ICORE(IW),SIJ,NUMSYD,NOSQL,
     &               DISSYW,NOSQR,POP(1,ISPIN),POP(1,ISPIN),
     &               POP(1,ISPIN),IRREPR,IRREPL,IRREPX,
     &               IOFFS1(1,ISPIN),1)
C
        ENDIF
C
C  TRANSPOSE TARGET LIST
C
        ID2=IW
        IEND=ID2+IINTFP*NUMSYD*DISSYD
        IF(IEND.GE.MXCOR) CALL INSMEM('D1IJKA',IEND,MXCOR)
C
        CALL ASSYM(IRREPL,POP(1,ISPIN),NUMSYD,NUMSYD,ICORE(ID2),
     &             ICORE(ID))
C
        CALL TRANSP(ICORE(ID2),ICORE(ID),DISSYD,NUMSYD)
C
C NEW ADDRESS FOR INTEGRALS
C
        IW=ID+IINTFP*DISSYD*NUMSYD
C
C FOR GEOMETRICAL PERTURBATIONS, DEAL FIRST WITH THE S-TERMS
C
        IF(STERM) THEN
C
         NUMSYW=IRPDPD(IRREPL,ISYTYP(2,LISTW))
         DISSYW=IRPDPD(IRREPL,ISYTYP(1,LISTW))
C
         ITMP=IW+IINTFP*DISSYW*NUMSYW
         IEND=ITMP+3*IINTFP*MAX(NUMSYW,NUMSYD,DISSYW,DISSYD)
         IF(IEND.GE.MXCOR) CALL INSMEM('D1IJKA',IEND,MXCOR)
C
         CALL SYMTR1(IRREPR,VRT(1,ISPIN),POP(1,ISPIN),DISSYD,
     &               ICORE(ID),ICORE(ITMP),ICORE(ITMP+IINTFP*
     &               DISSYD),ICORE(ITMP+2*IINTFP*DISSYD))
         CALL GETLST(ICORE(IW),1,NUMSYW,1,IRREPL,LISTW)
         CALL SYMEXP(IRREPL,POP(1,ISPIN),DISSYW,ICORE(IW))
C
C   (IJ,KA) (L,R) <----- (IJ,KE) (L,L) S(E,A) (X)
C
         CALL DFINDT(ICORE(ID),ICORE(IW),SAB,DISSYD,NUMSYD,DISSYW,
     &               NUMSYW,POP(1,ISPIN),VRT(1,ISPIN),VRT(1,ISPIN),
     &               IRREPL,IRREPR,IRREPX,IOFFS2(1,ISPIN),1)
C
C TRANSPOSE INTEGRAL AND TARGET LIST FROM I,J;K,A TO I,J;A,K
C
         CALL SYMTR1(IRREPL,POP(1,ISPIN),VRT(1,ISPIN),DISSYW,
     &               ICORE(IW),ICORE(ITMP),ICORE(ITMP+IINTFP*
     &               DISSYW),ICORE(ITMP+2*IINTFP*DISSYW))
         CALL SYMTR1(IRREPR,POP(1,ISPIN),VRT(1,ISPIN),DISSYD,
     &               ICORE(ID),ICORE(ITMP),ICORE(ITMP+IINTFP*
     &               DISSYD),ICORE(ITMP+2*IINTFP*DISSYD))
C
C (IJ,AK) (L,R) <----- (IJ,AM) (L,L) S(M,K) (X)
C
         CALL DFINDT(ICORE(ID),ICORE(IW),SIJ,DISSYD,NUMSYD,DISSYW,
     &               NUMSYW,VRT(1,ISPIN),POP(1,ISPIN),POP(1,ISPIN),
     &               IRREPL,IRREPR,IRREPX,IOFFS1(1,ISPIN),1)
C
       ENDIF
C
C NOW DEAL WITH THE RIGHT HAND SIDE
C
C  TERM   <IJ||AE> U(EA)
C
       LISTW=13+ISPIN
       DISSYW=IRPDPD(IRREPL,ISYTYP(1,LISTW))
       NUMSYW=IRPDPD(IRREPL,ISYTYP(2,LISTW))
C
C ALLOCATE MEMORY
C
       IW2=IW+IINTFP*NUMSYW*DISSYW
       IEND=IW2+IINTFP*NUMSYW*DISSYW
       IF(IEND.GT.MXCOR) CALL INSMEM('D1IJKA',IEND,MXCOR)
C
C READ IN <IJ||AB> INTEGRALS, ORDER IS A,B;I,J
C
       CALL GETLST(ICORE(IW2),1,NUMSYW,1,IRREPL,LISTW)
C 
C TRANSPOSE : AB;IJ --> IJ;AB
C
       CALL TRANSP(ICORE(IW2),ICORE(IW),NUMSYW,DISSYW)
       CALL VMINUS(ICORE(IW),NUMSYW*DISSYW)
C
       NUMTMP=NUMSYW
       NUMSYW=DISSYW
       DISSYW=NUMTMP
C
C EXPAND THE LAST TWO INDICES
C
       CALL SYMEXP(IRREPL,VRT(1,ISPIN),DISSYW,ICORE(IW))
C
C  (IJ,AK) (L,R) <----- (IJ,AE) (L,L) (E,K) (X)
C
       CALL DFINDT(ICORE(ID),ICORE(IW),UAI,DISSYD,NUMYSD,
     &             DISSYW,NVSQL,VRT(1,ISPIN),VRT(1,ISPIN),
     &             POP(1,ISPIN),IRREPL,IRREPR,IRREPX,
     &             IOFFU(1,ISPIN),1)
C
C TRANSPOOSE THE LAST TWO INDICES IN THE TARGET ARRAY
C
       CALL SYMTR1(IRREPR,VRT(1,ISPIN),POP(1,ISPIN),DISSYD,
     &             ICORE(ID),ICORE(IW),ICORE(IW+IINTFP*DISSYD),
     &             ICORE(IW+2*IINTFP*DISSYD))
C
       LISTW=10+ISPIN
C
       NUMSYW=IRPDPD(IRREPL,ISYTYP(2,LISTW))
       DISSYW=IRPDPD(IRREPL,ISYTYP(1,LISTW))
C
       IEND=IW+IINTFP*DISSYW*NOSQL
       IF(IEND.GE.MXCOR) CALL INSMEM('D1IJKA',IEND,MXCOR)
C
       CALL GETLST(ICORE(IW),1,NUMSYW,1,IRREPL,LISTW)
C
       CALL SYMEXP(IRREPL,POP(1,ISPIN),DISSYW,ICORE(IW))
C
C  (IJ,KA) (L,R) <----- (IJ,KM) (L,L)( (M,A) (X)
C
       CALL DFINDT(ICORE(ID),ICORE(IW),UIA,DISSYD,NUMSYD,
     &             DISSYW,NOSQL,POP(1,ISPIN),POP(1,ISPIN),
     &             VRT(1,ISPIN),IRREPL,IRREPR,IRREPX,
     &             IOFFU(1,ISPIN),2)
C
      CALL PUTLST(ICORE(ID),1,NUMSYD,1,IRREPR,306+ISPIN)
      call checksum('d1ijka',icore(id),numsyd*dissyd)
1000  CONTINUE
C
C ALL DONE SO FAR
C
      RETURN
      END
