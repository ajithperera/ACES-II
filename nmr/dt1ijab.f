      SUBROUTINE DT1IJAB(ICORE,MAXCOR,ISPIN,ANTI,GRAD1)
C
C  THIS PROGRAM COMPUTED THE DERIVATIVES OF THE FIRST-ORDER T2-
C  AMPLITUDES 
C
C  d T(IJ,AB)   d <AB||IJ>  ab -1        d fmi            d fmj
C  ---------- = ---------  D      - SUM [----- T(MJ,AB) + ----- T(IM,AB)]
C    d chi        d chi     ij       m   d chi            d chi
C
C           d fae             d fbe
C   + SUM [ ----- T(IJ,EB) + ------ T(IJ,AE)]
C      e    d chi             d chi 
C
C  SEE J.GAUSS UNPUBLISHED NOTES.
C
CEND
C
C  CODED JAN/91/JG
C
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,POP,VRT
      INTEGER DISSYD,DISSYT1,DISSYT2,DISSYD2
      LOGICAL ANTI
C
      DIMENSION ICORE(MAXCOR)
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),NJUNK(18)
      COMMON/DSYM/IRREPX,IPERT,NDT(2),NDF1(2),NDF2(2),
     &            IOFFS1(8,2),IOFFS2(8,2),IOFFU(8,2)
C
      DATA HALF,ONE /0.5D0,1.0D0/
C
C  ALLOCATE MEMORY FOR THE DERIVATIVES OF THE FOCK MATRICES
C
      IFOO=1
      IFVV=IFOO+IINTFP*IRPDPD(IRREPX,20+ISPIN)
      ISTART=IFVV+IINTFP*IRPDPD(IRREPX,18+ISPIN)
C
C  READ THE DERIVATIVES OF THE FOCK MATRICES FROM DISK
C
      CALL GETLST(ICORE(IFOO),IPERT,1,1,IRREPX,175+ISPIN)
      CALL GETLST(ICORE(IFVV),IPERT,1,1,IRREPX,177+ISPIN)
C
C  LOOP OVER ALL IRREPS
C
      DO 1000 IRREPR=1,NIRREP
C
C  IRREPR DETERMINES THE IRREP OF DT2 ON THE RIGHT SIDE
C  IRREPL IS GIVEN AS THE DIRECT PRODUCT OF IRREPR WITH
C  IRREPX
C
       IRREPL=DIRPRD(IRREPR,IRREPX)
C
C   T(AB,MJ) * FD(IM) + T(AB,IM) FD(JM)
C
C READ FIRST THE T2(AB,IM)
C
       LISTT=43+ISPIN
       NUMSYD=IRPDPD(IRREPR,2+ISPIN)
       DISSYD=IRPDPD(IRREPL,ISPIN)
       NUMSYT1=IRPDPD(IRREPL,2+ISPIN)
       DISSYT1=IRPDPD(IRREPL,ISPIN)
       NUMSYT2=IRPDPD(IRREPR,2+ISPIN)
       DISSYT2=IRPDPD(IRREPR,ISPIN)
       NFOOR=IRPDPD(IRREPR,20+ISPIN)
       NFVVR=IRPDPD(IRREPR,18+ISPIN)
       NFOOL=IRPDPD(IRREPL,20+ISPIN)
       NFVVL=IRPDPD(IRREPL,18+ISPIN)
       ID=ISTART
       IT=ID+IINTFP*NUMSYD*NFVVL
       IEND=IT+IINTFP*NUMSYT2*NFVVR
       IF(IEND.GT.MAXCOR) CALL INSMEM('DT1IJAB1',IEND,MXCOR)
C
C  ZERO OUT THE TARGET ARRAY
C
       CALL IZERO(ICORE(ID),IINTFP*NUMSYD*NFVVL)
C
C  FIRST TERM :   <Ij||Ae> f(eb)(chi)
C
       IT2=IT+IINTFP*NUMSYT2*DISSYT2
       IEND=IT2+IINTFP*NUMSYT2*DISSYT2
       IF(IEND.GT.MAXCOR) CALL INSMEM('DT1IJAB2',IEND,MXCOR)
C
       CALL GETLST(ICORE(IT2),1,NUMSYT2,1,IRREPR,LISTT)
C
C  TRANSPOSE THE TARGET ARRAY
C
       CALL TRANSP(ICORE(IT2),ICORE(IT),NUMSYT2,DISSYT2)
C
       NUMTMP=NUMSYT2
       NUMSYT2=DISSYT2
       DISSYT2=NUMTMP
       NUMSYD2=DISSYD
       DISSYD2=NUMSYD
C
C  EXPAND THE RIGHT HAND SIDE
C
       CALL SYMEXP(IRREPR,VRT(1,ISPIN),DISSYT2,ICORE(IT))
       CALL DFINDT(ICORE(ID),ICORE(IT),ICORE(IFVV),
     &             DISSYD2,NFVVL,DISSYT2,NFVVR,VRT(1,ISPIN), 
     &             VRT(1,ISPIN),VRT(1,ISPIN),IRREPR,IRREPL,IRREPX,
     &             IOFFS2(1,ISPIN),1)
C
C  ANTISYMMETRIZE THE RIGHT HAND SIDE
C
       ID2=ID+IINTFP*NUMSYD*NFVVL
       IEND=ID2+IINTFP*NUMSYD*DISSYD
       IF(IEND.GT.MAXCOR) CALL INSMEM('DT1IJAB3',IEND,MXCOR)
C
       CALL ASSYM(IRREPL,VRT(1,ISPIN),DISSYT2,DISSYT2,ICORE(ID2),
     &            ICORE(ID))
C
C TRANSPOSE THE TARGET ARRAY
C
       CALL TRANSP(ICORE(ID2),ICORE(ID),NUMSYD2,DISSYD2)
C
       CALL SSCAL(NUMSYD*DISSYD,HALF,ICORE(ID),1)
C
       IT=ID+IINTFP*DISSYD*NFOOR
       IEND=IT+IINTFP*NFOOL*DISSYT1
       IF(IEND.GT.MAXCOR) CALL INSMEM('DT1IJAB4',IEND,MXCOR)
C
C  EXPAND THE RIGHT HAND SIDE OF THE TARGET ARRAY
C
       CALL SYMEXP(IRREPR,POP(1,ISPIN),DISSYD,ICORE(ID))
C
       CALL GETLST(ICORE(IT),1,NUMSYT1,1,IRREPL,LISTT)
       CALL SYMEXP(IRREPL,POP(1,ISPIN),DISSYT1,ICORE(IT))
C
       IF(.NOT.ANTI) CALL VMINUS(ICORE(ID),DISSYD*NFOOR)
C
       CALL DFINDT(ICORE(ID),ICORE(IT),ICORE(IFOO),
     &            DISSYD,NFOOR,DISSYT1,NFOOL,POP(1,ISPIN), 
     &            POP(1,ISPIN),POP(1,ISPIN),IRREPL,IRREPR,IRREPX,
     &            IOFFS1(1,ISPIN),1)
C
       CALL VMINUS(ICORE(ID),DISSYD*NFOOR)
C
       ID2=ID+IINTFP*DISSYD*NFOOR
       IEND=ID2+IINTFP*DISSYD*NUMSYD
       IF(IEND.GT.MAXCOR) CALL INSMEM('DT1IJAB5',IEND,MXCOR)
C
       CALL ASSYM(IRREPR,POP(1,ISPIN),DISSYD,DISSYD,ICORE(ID2),
     &            ICORE(ID))
c YAU : old
c      CALL ICOPY(IINTFP*NUMSYD*DISSYD,ICORE(ID2),1,ICORE(ID),1)
c YAU : new
       CALL DCOPY(NUMSYD*DISSYD,ICORE(ID2),1,ICORE(ID),1)
c YAU : end
      call checksum('dt1ija',icore(id),numsyd*dissyd)
C
C  ALLOCATE DISK SPACE
C
       IW=ID+DISSYD*NUMSYD*IINTFP
       IEND=IW+IINTFP*DISSYD*NUMSYD
C
       IF(IEND.GT.MAXCOR) CALL INSMEM ('DT1IJAB6',IEND,MXCOR)
C
C  READ IN INTEGRAL DERIVATIVES 
C
       LISTDW=313+ISPIN
c       CALL GETLST(ICORE(IW),(IPERT-1)*NUMSYD+1,NUMSYD,1,
c     &             IRREPR,LISTDW)
       CALL GETLST(ICORE(IW),1,NUMSYD,1,
     &             IRREPR,LISTDW)
       CALL SAXPY(NUMSYD*DISSYD,ONE,ICORE(IW),1,ICORE(ID),1)
C
       LISTDD=447+ISPIN
       CALL GETLST(ICORE(IW),1,NUMSYD,1,IRREPR,LISTDD)
C
       CALL VECPRD(ICORE(ID),ICORE(IW),ICORE(ID),NUMSYD*DISSYD)
C
       LISTDT=443+ISPIN
       CALL PUTLST(ICORE(ID),1,NUMSYD,1,IRREPR,LISTDT)
C
      call checksum('dt1ija',icore(id),numsyd*dissyd)
       IF(IRREPR.EQ.IRREPL) THEN
        CALL GETLST(ICORE(IW),1,NUMSYD,1,IRREPR,13+ISPIN)
        GRAD1=GRAD1+SDOT(NUMSYD*DISSYD,ICORE(ID),1,ICORE(IW),1)
        write(*,*) grad1,' after', irrepr, ' for ', ipert
       ENDIF
1000  CONTINUE
C
      RETURN
      END
