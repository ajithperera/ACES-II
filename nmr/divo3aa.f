

      SUBROUTINE DIVO3AA(G,W,MAXSIZE,DIVO,FACT,ISPIN,POP,
     &                   VRT,DISSYG,NUMSYG,DISSYW,NUMSYW,
     &                   LISTG,LISTW,IRREPL,IRREPR,TMP)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYG,DISSYW,DISMAX,DISLEFT,DISREAD,DIRPRD,POP,VRT
      DIMENSION G(DISSYG,1),W(DISSYW,1),DIVO(1),POP(8),VRT(8),TMP(1),
     &          IPT(8)
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
C
      DATA ONEM,ONE,HALF /-1.0D0,1.D0,0.5D0/
C
C  PICK UP THE G-AMPLITUDES AND THE INTEGRALS
C
      CALL GETLST(G,1,NUMSYG,1,IRREPR,LISTG)
C
C  EXPAND THE OCCUPIED-OCCUPIED BLOCK OF THE AMPLITUDES
C
      CALL SYMEXP(IRREPR,POP,DISSYG,G)
C
C  DECIDE WHICH ALGORITHM BY CHECKING MAXSIZE
C
      IF(MAXSIZE.GT.NUMSYW*DISSYW) THEN
       CALL GETLST(W,1,NUMSYW,2,IRREPL,LISTW)
       CALL SYMTR1(IRREPL,VRT,POP,DISSYW,W,TMP,TMP(1+DISSYW),
     &             TMP(1+2*DISSYW))
C
C  PERFORM MULTIPLICATION
C
C  JOFFG OFFSET IN G
C  JOFFW OFFSET IN W
C  IOFF OFFSET IN DIVO
C
       JOFFG=1
       IOFF=1
       DO 90 IRREPJR=1,NIRREP
C          
C  GET OCCUPATION NUMBER FOR JRREP     
C
        NOCCJR=POP(IRREPJR)
C
C        DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH JRREP GIVES IRREP
C
        IRREPI=DIRPRD(IRREPR,IRREPJR)
C
C  GET OCCUPATION NUMBER FOR IRREPI
C
        NOCCI=POP(IRREPI)
C
        IRREPJL=DIRPRD(IRREPL,IRREPI)
C
        NVRTJL=VRT(IRREPJL)
C
        JOFFW=1
        DO 89 IRREP=1,IRREPJL-1
         JOFFW=JOFFW+VRT(IRREP)*POP(DIRPRD(IRREPL,IRREP))
89      CONTINUE
C
C  IF NOCCI, NOCCJR, OR NVRTJL EQUAL ZERO, NOTHING TO COMPUTE
C
        IF(MIN(NOCCJR,NOCCI,NVRTJL).NE.0) THEN
C
         CALL XGEMM('T','N',NVRTJL,NOCCJR,DISSYG*NOCCI,FACT,
     &               W(1,JOFFW),NOCCI*DISSYW,G(1,JOFFG),      
     &               NOCCI*DISSYG,ONE,DIVO(IOFF),NVRTJL)
C
        ENDIF
C
C UPDATE THE OFFSETS
C
        JOFFG=JOFFG+NOCCJR*NOCCI
        IOFF=IOFF+NOCCJR*NVRTJL
90     CONTINUE
C
      ELSE
C
C OUT OF CORE ALGORITHM 
C
C  DETERMINE FIRST OFFSETS WITHIN THE DIVO INTERMEDIATE
C
       IRREPX=DIRPRD(IRREPR,IRREPL)
       IPT(1)=1
       DO 150 IRREPJR=1,NIRREP-1
        IRREPJL=DIRPRD(IRREPX,IRREPJR)
        IPT(IRREPJR+1)=IPT(IRREPJR)+POP(IRREPJR)*VRT(IRREPJL)
150    CONTINUE
C
C  DETERMINE MAXIMUM NUMBER OF DISTRIBUTIONS WHICH FIT INTO CORE
C
       MAXDIS=MAXSIZE/DISSYW
C
C  SET OFFSETS FOR INTEGRAL LIST AND G AMPLITUDES
C
       IOFFSET=1
       JOFFG=1
C
C  LOOP OVER THE IRREPS OF THE LAST INDEX
C
       DO 200 IRREPJ=1,NIRREP
C
        NOCCJ=POP(IRREPJ)
        IRREPIR=DIRPRD(IRREPR,IRREPJ)
        IRREPIL=DIRPRD(IRREPL,IRREPJ)
        NOCCI=POP(IRREPIR)
        NVRTI=VRT(IRREPIL)
        IF(MIN(NOCCI,NVRTI,NOCCJ).NE.0) THEN
C
C DETERMINE NUMBER OF (E<F,A) BLOCKS WHICH CAN BE HELD IN CORE
C
         DISMAX=MAXDIS/NVRTI 
         IF(DISMAX.LE.0) STOP 'XIA3AA'
C
C NUMBER OF (E<F,A) BLOCKS TO READ
C
         DISLEFT=NOCCJ
C
10       CONTINUE
C
C NUMBER OF (E<F,A) BLOCKS WHICH ARE READ IN THIS PATH
C
          DISREAD=MIN(DISLEFT,DISMAX)
          DISLEFT=DISLEFT-DISREAD
C
C GET THE DISTRIBUTIONS FROM DISK
C
          CALL GETLST(W,IOFFSET,DISREAD*NVRTI,2,IRREPL,LISTW)
C
C  UPDATE IOFFSET
C
          IOFFSET=IOFFSET+DISREAD*NVRTI
C
C  LOOP OVER ALL DISTRIBUTIONS AND PERFORM MULTIPLICATION
C
          JOFFW=1
          IOFF=IPT(IRREPIR)
C
          DO 250 NUM=1,DISREAD
C
           CALL XGEMM('T','N',NVRTI,NOCCI,DISSYW,-FACT,
     &                W(1,JOFFW),DISSYT,G(1,JOFFG),DISSYW,
     &                ONE,DIVO(IOFF),NVRTI)
C
C  UPDATE OFFSETS
C
           JOFFW=JOFFW+NVRTI
           JOFFG=JOFFG+NOCCI  
C
250       CONTINUE
C
C IF NOT ALL (E<F,A) BLOCKS HAVE BEEN PROCESSED, GO BACK TO 10
C
         IF(DISLEFT.NE.0) GO TO 10
C
        ELSE
C
C  UPDATE OFFSETS IN THE CASE NOTHING HAS BEEN DONE
C
         IOFFSET=IOFFSET+NOCCJ*NVRTI
         JOFFG=JOFFG+NOCCJ*NOCCI
        ENDIF
200    CONTINUE
C
      ENDIF
C
      RETURN
      END
