      SUBROUTINE D1IAJB(UAI,SIJ,UIA,SAB,ICORE,MXCOR,IRREPX, 
     &                  IPERT,ISPIN,STERM)
C
C  THIS ROUTINE CALCULATES THE DERIVATIVE INTEGRALS d <IA//JB> / d chi
C
C   THERE ARE EIGHT DIFFERENT TERMS
C
C   DUE TO PERMUTATIONAL SYMMETRY THEY REDUCE TO FOUR
C      (<IA||JB> <--> <JB||IA>
C
C   NOTE THAT LIST 323 and 324 HAVE TO BE RESORTED !
C
CEND
C
C CODED SEP/91 JG UNIVERSITY OF KARLSRUHE
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,DISSYW,DISSYD,POP,VRT
      LOGICAL FIELD,GEOM,ROHF,QRHF,SEMI,STERM
      DIMENSION ICORE(MXCOR) 
      DIMENSION UAI(1),UIA(1)
      DIMENSION SIJ(1),SAB(1)
C
      COMMON/OFFSETS/IOFFU(8,2),IOFFS1(8,2),IOFFS2(8,2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREPAA(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),NJUNK(18)
      COMMON/DTRAN/FIELD,GEOM,ROHF,QRHF,SEMI
C
      DATA AZERO,ONE /0.D0,1.D0/
C
C  INCORE ALGORITHM
C
C  LOOP OVER ALL IRREPS OF THE DERIVATIVE INTEGRALS
C
      DO 1000 IRREPR=1,NIRREP
C
C  THE IRREP ON THE LEFT SIDE IS THEN GIVEN AS THE DIRECT PRODUCT
C   OF IRREPP AND IRREPR
C
       IRREPL=DIRPRD(IRREPR,IRREPX)
C
C DETERMINE LENGTH OF TARGET ARRAY
C
       LISTD=322+ISPIN
       NUMSYD=IRPDPD(IRREPR,ISYTYP(2,LISTD))
       DISSYD=IRPDPD(IRREPL,ISYTYP(1,LISTD))
C
C ALLOCATE CORE FOR TARGET ARRAY
C
       ID=1
       IREST=ID+IINTFP*NUMSYD*DISSYD
C
C  ZERO TARGET LIST
C
        CALL ZERO(ICORE(ID),NUMSYD*DISSYD)
C
C FIRST TERM: 
C
C CONSIDER FIRST ALL TERMS WHICH INCLUDE U(IA)
C
C    <MI||BJ> U(MA) 
C
C  THE IRREP ON THE RIGHT SIDE IS UNCHANGED, SO IRREPR DETERMINES
C  THE LISTS OF ORIGINAL ZEROTH ORDER INTEGRALS
C
       LISTW=6+ISPIN
       NUMSYW=IRPDPD(IRREPR,ISYTYP(2,LISTW))
       DISSYW=IRPDPD(IRREPR,ISYTYP(1,LISTW))
C
C  ALLOCATE CORE MEMORY
C
       IW=IREST
       IW2=IW+IINTFP*NUMSYW*DISSYW
       ITMP=IW2
       IEND=IW2+IINTFP*NUMSYW*DISSYW
C
       IF(IEND.GE.MXCOR) CALL INSMEM('D1IAJB1',IEND,MXCOR)
C
C  READ IN THE <IM||JB> AS  IM,JB 
C
        CALL GETLST(ICORE(IW2),1,NUMSYW,1,IRREPR,LISTW)
C
C TRANSPOSE IM,JB TO JB, IM 
C
        CALL TRANSP(ICORE(IW2),ICORE(IW),NUMSYW,DISSYW)
C
C  (JB,IA) (R,L) <------ (JB,IM) (R,R) (A,M) (X) (UHF)
C
        CALL DFINDT(ICORE(ID),ICORE(IW),UIA,NUMSYD,DISSYD,
     &              NUMSYW,DISSYW,POP(1,ISPIN),POP(1,ISPIN),
     &              VRT(1,ISPIN),IRREPR,IRREPL,IRREPX,
     &              IOFFU(1,ISPIN),2)
C
C  TRANSPOSE THE TARGET LIST   
C
C   JB,IA TO JB,AI
C
        CALL SYMTR1(IRREPL,POP(1,ISPIN),VRT(1,ISPIN),NUMSYD,
     &              ICORE(ID),ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYD),
     &              ICORE(ITMP+2*IINTFP*NUMSYD))
C
C  TRANSPOSE ALSO JB,AI TO BJ,AI
C
         CALL SYMTR3(IRREPR,POP(1,ISPIN),VRT(1,ISPIN),NUMSYD,DISSYD,
     &               ICORE(ID),ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYD),
     &               ICORE(ITMP+2*IINTFP*DISSYD))
C
C SECOND TERM:
C  
C  NOW DO <BJ||AE> U(E,I)
C
        LISTW=26+ISPIN
        NUMSYW=IRPDPD(IRREPR,ISYTYP(2,LISTW))
        DISSYW=IRPDPD(IRREPR,ISYTYP(1,LISTW))
C
C  ALLOCATE CORE MEMORY
C
        IW=IREST
        IW2=IW+IINTFP*NUMSYW*DISSYW
        ITMP=IW2
        IEND=IW+IINTFP*NUMSYW*DISSYW
C
        IF(IEND.GE.MXCOR) CALL INSMEM('D1IAJB2',IEND,MXCOR)
C
C  READ IN THE <AE||BJ> AS AE, BJ
C
        CALL GETLST(ICORE(IW2),1,NUMSYW,1,IRREPR,LISTW)
C
C  TRANSPOSE FROM AE,BJ TO BJ,AE
C
        CALL TRANSP(ICORE(IW2),ICORE(IW),NUMSYW,DISSYW)
C
C  (BJ;AI) (R,L) <----- (BJ;AE) (R,R) (E,I) (X)
C
        CALL DFINDT(ICORE(ID),ICORE(IW),UAI,NUMSYD,DISSYD,
     &              NUMSYW,DISSYW,VRT(1,ISPIN),VRT(1,ISPIN),
     &              POP(1,ISPIN),IRREPR,IRREPL,IRREPX,
     &              IOFFU(1,ISPIN),1)
C
        IF(STERM) THEN
C
C THIRD TERM:
C
C CONSIDER FIRST ALL TERMS WHICH INCLUDE S(AE)
C
C    <BJ|AM> (-1/2 S(MI))
C
C  THE IRREP ON THE RIGHT SIDE IS UNCHANGED, SO IRREPR DETERMINES
C  THE LISTS OF ORIGINAL ZEROTH ORDER INTEGRALS
C  (USE THE SORTED LISTS 23 AND 24 !)
C
         LISTW=22+ISPIN
         NUMSYW=IRPDPD(IRREPR,ISYTYP(2,LISTW))
         DISSYW=IRPDPD(IRREPR,ISYTYP(1,LISTW))
C
C  ALLOCATE CORE MEMORY
C
         IEND=IW+IINTFP*NUMSYW*DISSYW
C
         IF(IEND.GE.MXCOR) CALL INSMEM('D1IAJB3',IEND,MXCOR)
C
C  READ IN THE <BJ||AM> AS BJ,Am 
C
         CALL GETLST(ICORE(IW),1,NUMSYW,1,IRREPR,LISTW)
C
C  (BJ;AM) (R,L) <----- (BJ;AM) (R,R) (MI) (X)
C
         CALL DFINDT(ICORE(ID),ICORE(IW),SIJ,NUMSYD,DISSYD,
     &               DISSYW,NUMSYW,VRT(1,ISPIN),POP(1,ISPIN),
     &               POP(1,ISPIN),IRREPR,IRREPL,IRREPX,
     &               IOFFS1(1,ISPIN),1)
C
C  TRANSPOSE THE TARGET LIST    BJ;AI --> BJ,IA
C
         CALL SYMTR1(IRREPL,VRT(1,ISPIN),POP(1,ISPIN),NUMSYD,
     &               ICORE(ID),ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYD),
     &               ICORE(ITMP+2*IINTFP*NUMSYD))
C
C TRANSPOSE THE INTEGRAL LIST
C
         CALL SYMTR1(IRREPR,VRT(1,ISPIN),POP(1,ISPIN),DISSYW,
     &               ICORE(IW),ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYW),
     &               ICORE(ITMP+2*IINTFP*DISSYW))
C
C  (BJ;IA) (R,L) <----- (BJ;IE) (R,R) (EA) (X)
C
         CALL DFINDT(ICORE(ID),ICORE(IW),SAB,NUMSYD,DISSYD,
     &               DISSYW,NUMSYW,POP(1,ISPIN),VRT(1,ISPIN),
     &               VRT(1,ISPIN),IRREPR,IRREPL,IRREPX,
     &               IOFFS2(1,ISPIN),1)
C
C
C  TRANSPOSE THE TARGET LIST    BJ;IA --> BJ,AI
C
         CALL SYMTR1(IRREPL,POP(1,ISPIN),VRT(1,ISPIN),NUMSYD,
     &               ICORE(ID),ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYD),
     &               ICORE(ITMP+2*IINTFP*NUMSYD))
C
        ENDIF 
C
C ALL DONE, SAVE THE INTEGRAL DERIVATIVES ON DISK
C HOWEVER, EACH CONTRIBUTION HAS TO BE ADDED TWICE TO THE
C CORRESPONDING INTEGRAL DERIVATIVES
C
C  FIRST, WE HAVE TO ADD    (R,L) TYPES WITH DERIVATIVES TAKEN
C  WITH RESPECT TO THE LEFT SIDE
C  SECOND WE HAVE TO TRANSPOSE THE WHOLE STUFF AND HAVE TO
C  ADD IT TO THOSE DERIVATIVES WHERE IT CORRESPONDS TO 
C  THE DERIVATIVES TAKEN WITh RESPECT TO THE LEFT SIDE
C
C  IRREPR LT IRREPL (MEANING FIRST CONTRIBUTION) AND NOT STERM,
C  INITIALIZE LIST, OTHERWISE UPDATE
C
        IF((IRREPR.GE.IRREPL).OR.STERM) THEN
C
C UPDATE
C
         ID2=IREST
         IEND=ID2+IINTFP*NUMSYD*DISSYD
         IF(IEND.GE.MXCOR) CALL INSMEM('D1IAJB4',IEND,MXCOR)
C
C GET INTEGRAL DERIVATIVES FROM DISK
C
         CALL GETLST(ICORE(ID2),1,DISSYD,1,IRREPL,LISTD)
C
         CALL SAXPY(NUMSYD*DISSYD,ONE,ICORE(ID),1,ICORE(ID2),1)
C
         CALL PUTLST(ICORE(ID2),1,DISSYD,1,IRREPL,LISTD)
C
        ELSE  
C
C INITIALIZE
C
         CALL PUTLST(ICORE(ID),1,DISSYD,1,IRREPL,LISTD)
C
        ENDIF
C 
C  TRANSPOSE TARGET LIST
C
        ID2=IREST
        IEND=ID2+IINTFP*NUMSYD*DISSYD
        IF(IEND.GE.MXCOR) CALL INSMEM('D1IAJB5',IEND,MXCOR)
C
        CALL TRANSP(ICORE(ID),ICORE(ID2),DISSYD,NUMSYD)
C
        IF((IRREPR.GT.IRREPL).OR.STERM) THEN
C
C UPDATE
C
         CALL GETLST(ICORE(ID),1,NUMSYD,1,IRREPR,LISTD)
C
         CALL SAXPY(NUMSYD*DISSYD,ONE,ICORE(ID2),1,ICORE(ID),1)
C
         CALL PUTLST(ICORE(ID),1,NUMSYD,1,IRREPR,LISTD)
C
        ELSE
C
C INITIALIZE
C
         CALL PUTLST(ICORE(ID2),1,NUMSYD,1,IRREPR,LISTD)
C
        ENDIF
C
1000  CONTINUE
C
C ALL DONE SO FAR
C
      RETURN
      END
