
C THIS PROGRAM CALCULATES THE PARAMAGNETIC CONTRIBUTION
C TO NMR CHEMICAL SHIFTS AT THE MBPT(2) LEVEL OF THEORY
C USING THE GAUGE INCLUDING ATOMIC ORBITAL ANSATZ.

C FOR REFERENCES, SEE: J. GAUSS, CHEM. PHYS. LETT. 191 (1992)
C                      J. GAUSS, J. CHEM. PHYS., SUBMITTED.

CEND

C CODED SEPT/91 - MARCH/92 J. GAUSS, UNIVERSITY OF KARLSRUHE

C VARIOUS EXTENSION (OUT-OF-CORE ALGHORITHM, SYMMETRY HANDLING)
C 1992, J. GAUSS, UNIVERISTY OF KARLRUHE

C CONVENTIONAL MP2-CALCULATION OF CHEMICAL SHIFTS ARE POSSIBLE
C BY RECOMPILING SETMET WITH GIAO SET TO .FALSE. (NO STANDARD
C OPTION)

      SUBROUTINE NMR(ICORE,ICRSIZ,IUHF)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)

      LOGICAL MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD
      LOGICAL FIELD,GEOM,ROHF,QRHF,SEMI,JNIT
      LOGICAL DOFCM,DODDP,DOPOL,NOABCD,GIAO,JSO,STERM
      INTEGER POP,VRT,DIRPRD
      DOUBLE PRECISION MSZ(3,3)
      CHARACTER*2 NXYZ(3)

      DIMENSION IUAI(2),IUIA(2),ISIJ(2),ISAB(2)

      INTEGER ICORE(*), IUSE

      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/INFO/NOCCO(2),NVRTO(2)
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),NJUNK(18)
      COMMON/METH/MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD
      COMMON/REF/ROHF,QRHF,SEMI
      COMMON/PERT/NTPERT1,NPERT(8),IIPERT(8),IXPERT,IYPERT,IZPERT,
     &            IYZPERT,IXZPERT,IXYPERT,ITRANSX,ITRANSY,ITRANSZ,
     &            NUCIND
      COMMON/PERT2/NTP,NFP,NTPERT(8),NFPERT(8),IPERT(8),IFPERT(8)
      COMMON/PERT3/IXYZSYM(3)
      COMMON/PERT4/IXYZ
      COMMON/PERTINF/INIT,MPERT(8)
      COMMON/OFFSETS/IOFFU(8,2),IOFFS1(8,2),IOFFS2(8,2)
      COMMON/CPHF/ LENUAI(2),LENSIJ(2),LENSAB(2),
     &             LUAI1,LUAI2,LSIJ1,LSIJ2,LSAB1,
     &             LSAB2,LSAI1,LSAI2
      COMMON/DSYM/IRREPX,I1PERT,NDT(2),NDF1(2),NDF2(2),
     &            IOFFIJ(8,2),IOFFAB(8,2),IOFFAI(8,2)
      COMMON/ABCD/NOABCD
      COMMON/TREATP/IPERNUM
      COMMON/GAUGE/GIAO
      COMMON/JNMR/JSO
      COMMON/MAGN/MSZ
      COMMON /TIMEINFO/ TIMEIN, TIMENOW, TIMETOT, TIMENEW

      DATA HALFM,ONEM,TWO /-.5D0,-1.D0,2.D0/
      DATA NXYZ /'Bx','By','Bz'/

c ----------------------------------------------------------------------

C SET MAXCOR
      MAXCOR=ICRSIZ

C CALL SETMET AND SETPERT TO INITIALIZE /METH/ AND /PERT/
      CALL SETMET(IUHF)
      CALL SETPERT

C SET STERM (.TRUE. IF OVERLAP DERIVATIVE CONTRIBUTION HAS TO BE INCLUDED)
      STERM=GIAO.AND.(.NOT.JSO)

C ZERO SPACE FOR MAGNETIC SUSCEPTIBILITY
      IF (.NOT.GIAO) CALL ZERO(MSZ,9)

C ALLOCATE MEMORY FOR SECOND DERIVATIVES
C HERE, ALLOCATE NFP*NTP WORDS
      IVAL=1
      IUSE=IVAL+IINTFP*NTP*NFP

C SET SECOND DERIVATIVE ARRAY TO ZERO
      CALL IZERO(ICORE(IVAL),IINTFP*NTP*NFP)

C RESET MAXCOR
      MAXCOR=MAXCOR-IINTFP*NTP*NFP

C MEMORY FOR RELAXED DENSITY MATRICES
      IDOO   = IUSE
      IDOOB  = IDOO + IINTFP*NF1(1)*IUHF
      IDVV   = IDOO + IINTFP*(NF1(1)+IUHF*NF1(2))
      IDVVB  = IDVV + IINTFP*NF2(1)*IUHF
      IDVO   = IDVV + IINTFP*(NF2(1)+IUHF*NF2(2))
      IDVOB  = IDVO + IINTFP*NT(1)*IUHF
      IUSE   = IDVO + IINTFP*(NT(1)+IUHF*NT(2))
      MAXCOR = MAXCOR-IINTFP*(NT(1)+NF1(1)+NF2(1)+
     &                        IUHF*(NT(2)+NF1(2)+NF2(2)))

C READ IN RELAXED DENSITY MATRICES
      CALL READD(ICORE(IDOO),ICORE(IDOOB),ICORE(IDVV),
     &           ICORE(IDVVB),ICORE(IDVO),ICORE(IDVOB),
     &           IUHF)

C FOR UHF RESORT LIST 23 AND 24
      IF (IUHF.EQ.1) THEN
         CALL ST2324(ICORE(IUSE),MAXCOR)
      END IF

      IPABS=0

C LOOP OVER IRREPS OF ALL FIELD PERTURBATIONS
      DO 10000 IRREPX=1,NIRREP

C  NUMBER OF FIELD AND MAGNETIC MOMENT PERTURBATIONS WITHIN
C  GIVEN IRREP :

C  NXF : NUMBER OF FIELD PERTURBATIONS
C  NXFZ: NUMBER OF FIELD PERTURBATIONS SOLVED FOR IN
C        THE FIRST-ORDER Z-VECTOR EQUATIONS
C  NXG : NUMBER OF NUCLEAR MAGNETIC MOMENT PERTURBATIONS

C NOTE THAT FOR THE CALCULATION OF COUPLING CONSTANTS
C NXF IS SET TO NXG

       NXG=NTPERT(IRREPX)
       NXF=NFPERT(IRREPX)
       IF(JSO) NXF=NXG
       NXFZ=NXF

       ISF=1
       IEF=NXF

C CHECK IF THERE ARE ANY PERTURBATIONS, IF NOT SKIP LOOP
       IF(NXF.EQ.0.OR.NXG.EQ.0) GO TO 10000

C OPEN THE FILE DERINT
       CALL ACES_IO_OPEN(4)

C OPEN THE FILE DERGAM
       CALL ACES_IO_OPEN(5)

C FILL COMMON BLOCK /DSYM/
       CALL MKDSYM

C INITIALIZE THE FILE DERINT
       CALL INIDI(IRREPX,IUHF)

C INITIALIZE THE FILE DERGAM
       CALL INIDG(IRREPX,IUHF)

C CREATE DENOMINATOR LISTS
       CALL DDENOM(ICORE(IUSE),MAXCOR,IUHF)

C SET LIST NUMBERS
       LSIJ1=170
       LSIJ2=171
       LSAB1=172
       LSAB2=173
       LSAI1=174
       LSAI2=175
       LFIJ1=176
       LFIJ2=177
       LFAB1=178
       LFAB2=179
       LFAI1=180
       LFAI2=181
       LUAI1=182
       LUAI2=183

C  DETERMINE LENGTHS OF U(AI), S(IJ), AND S(AB) VECTORS
       LENUAI(1)=IRPDPD(IRREPX,8+1)
       LENUAI(2)=IRPDPD(IRREPX,8+2)
       LENSIJ(1)=IRPDPD(IRREPX,20+1)
       LENSIJ(2)=IRPDPD(IRREPX,20+2)
       LENSAB(1)=IRPDPD(IRREPX,18+1)
       LENSAB(2)=IRPDPD(IRREPX,18+2)

C ALLOCATE SPACE FOR GRADIENT
       IGRAD=IUSE
       CALL IZERO(ICORE(IGRAD),IINTFP*NXF)

C  ALLOCATE SPACE FOR THESE ARRAYS :

C U(A,I)
       IUAI(1)=IGRAD+IINTFP*NXF

C U(a,i)
       IUAI(2)=IUAI(1)+LENUAI(1)*IUHF*IINTFP

C U(I,A)
       IUIA(1)=IUAI(2)+LENUAI(2)*IINTFP

C U(i,a)
       IUIA(2)=IUIA(1)+LENUAI(1)*IUHF*IINTFP

C S(I,J)
       ISIJ(1)=IUIA(2)+LENUAI(2)*IINTFP

C S(i,j)
       ISIJ(2)=ISIJ(1)+LENSIJ(1)*IUHF*IINTFP

C S(A,B)
       ISAB(1)=ISIJ(2)+LENSIJ(2)*IINTFP

C S(a,b)
       ISAB(2)=ISAB(1)+LENSAB(1)*IUHF*IINTFP
       IEND=ISAB(2)+LENSAB(2)*IINTFP

C ALLOCATE MEMORY FOR d I(P,Q)/ d chi
       IDIVO=IEND
       IDIVOB=IDIVO+IINTFP*NDT(1)
       IDIOV=IDIVO+IINTFP*(NDT(1)+IUHF*NDT(2))
       IDIOVB=IDIOV+IINTFP*NDT(1)
       IEND=IDIOV+IINTFP*(NDT(1)+IUHF*NDT(2))
       LENDI=2*NDT(1)+IUHF*2*NDT(2)

C ALLOCATE MEMORY FOR DERIVATIVES OF DENSITY MATRICES
       IDDOO=IEND
       IDDOOB=IDDOO+IINTFP*NDF1(1)*IUHF
       IDDVV=IDDOO+IINTFP*(NDF1(1)+IUHF*NDF1(2))
       IDDVVB=IDDVV+IINTFP*NDF2(1)*IUHF
       IDDVO=IDDVV+IINTFP*(NDF2(1)+IUHF*NDF2(2))
       IDDVOB=IDDVO+IINTFP*NDT(1)
       IEND=IDDVO+IINTFP*(NDT(1)+IUHF*NDT(2))
       LENDD=NDF1(1)+NDF2(1)+NDT(1)+IUHF*(NDF1(2)+NDF2(2)+NDT(2))

C ALLOCATE MEMORY FOR DERIVATIVES OF X(A,I)
       IXAI=IEND
       IXAIB=IXAI+IINTFP*NXF*NDT(1)*IUHF
       IEND=IXAI+IINTFP*NXF*(NDT(1)+IUHF*NDT(2))

C SET MXCOR
       MXCOR=MAXCOR-IEND-IUSE

C SET OFFSETS
       CALL MAKOFF(IOFFU,IOFFS1,IOFFS2,IRREPX)

C SAVE CURRENT IEND AND MXCOR FOR REUSE
       IEND0=IEND
       MXCOR0=MXCOR

C  LOOP OVER ALL PERTURBATIONS
       NXFREAL=0
       DO 990 IP=1,NXF
        IPZ=IP

C DETERMINE TYPE OF PERTURBATION (X, Y, OR Z)
        IPABS=IPABS+1
        IXYZ=IXYZSYM(IPABS)

C LOGIC FOR SEQUENTIAL TREATMENT OF PERTURBATIONS
        IF(IPERNUM.NE.0) THEN
         IF(IXYZ.NE.IPERNUM) GO TO 990
         NXFZ=1
         IPZ=1
         ISF=IP
         IEF=IP
        ELSE
        ENDIF
        IF(.NOT.JSO) THEN
         write(*,6000) NXYZ(IXYZ)
        ELSE
         write(*,6002) IP,IRREPX
        ENDIF
6000    FORMAT(' The perturbation ',A2,' will be treated.')
6002    FORMAT(' Pertubation Nr.',I3,' will be treated within',
     &         ' Irrep ',I1,'.')
        NXFREAL=NXFREAL+1

C RESET IEND AND MXCOR
        IEND=IEND0
        MXCOR=MXCOR0

C SET I1PERT
        I1PERT=IP

C SET OFFSETS IOFFX AND IOFFXB
        IOFFX=(IPZ-1)*NDT(1)*IINTFP
        IOFFXB=(IPZ-1)*NDT(2)*IINTFP

C TRANSFORM DERIVATIVE INTEGRALS
        CALL ZERINT(ICORE(IEND),MXCOR)
        IF(STERM) THEN
         CALL AODTRN(ICORE(IEND),MXCOR,IUHF,IRREPX,IP,.TRUE.)
        ENDIF

C ZERO THE d I(P,Q)/ d chi ARRAYS
        CALL IZERO(ICORE(IDIVO),IINTFP*LENDI)

C ZERO THE d D(P,Q)/ d chi ARRAYS
        CALL IZERO(ICORE(IDDOO),IINTFP*LENDD)

C  READ THE CPHF COEFFICIENTS U(A,I)
        CALL READU(ICORE(IUAI(1)),ICORE(IUAI(2)),ICORE(IUIA(1)),
     &             ICORE(IUIA(2)),ICORE(ISIJ(1)),ICORE(ISIJ(2)),
     &             ICORE(ISAB(1)),ICORE(ISAB(2)),IP,IRREPX,
     &             IUHF,STERM,.TRUE.)

C IF NOABCD IS SET TO TRUE, THEN FORM <AB|CI(chi)> INTEGRALS
        IF(NOABCD) THEN
         CALL TABCI(ICORE(IEND),MXCOR,ICORE(IUAI(1)),ICORE(IUAI(2)),
     &              ICORE(ISIJ(1)),ICORE(ISIJ(2)),IUHF,IRREPX,IP)
        ENDIF

C FORM THE  <PQ||RS>^chi INTEGRALS
        CALL UXINT2(ICORE(IUAI(1)),ICORE(IUAI(2)),ICORE(IUIA(1)),
     &              ICORE(IUIA(2)),ICORE(ISIJ(1)),ICORE(ISIJ(2)),
     &              ICORE(ISAB(1)),ICORE(ISAB(2)),ICORE(IGRAD+
     &              (IP-1)*IINTFP),ICORE(IEND),MXCOR,IRREPX,IP,
     &              .TRUE.,IUHF,.TRUE.)

C CALCULATE THE DI(P,Q) CONTRIBUTIONS INVOLVING d<PQ||RS>/dchi
        CALL DINTOV1(ICORE(IDIOV),ICORE(IEND),MXCOR,IUHF,IP,.TRUE.)
        CALL DINTVO1(ICORE(IDIVO),ICORE(IDOO),ICORE(IDVV),
     &               ICORE(IEND),MXCOR,IUHF,IP,.TRUE.)

C CALCULATE THE DERIVATIVE AMPLITUDES:
        CALL DVCC(ICORE(IEND),MXCOR,IUHF,.TRUE.)

C CALCULATE THE DERIVATIVE OF ONE AND TWO PARTICLE DENSITY MATRICES
        CALL DDENS(ICORE(IVAL),ICORE(IDDOO),ICORE(IDDVV),
     &             ICORE(IDDVO),ICORE(IDOO),ICORE(IDVV),ICORE(IDVO),
     &             ICORE(IUAI(1)),ICORE(IUIA(1)),ICORE(ISIJ(1)),
     &             ICORE(ISAB(1)),ICORE(IEND),MXCOR,IUHF,.TRUE.)


C CALCULATE THE DI(P,Q) CONTRIBUTIONS INVOLVING dt(pq,rs)/dchi
        CALL DINTOV2(ICORE(IDIOV),ICORE(IEND),MXCOR,IUHF,IP,.TRUE.)
        CALL DINTVO2(ICORE(IDIVO),ICORE(IDDOO),ICORE(IDDVV),
     &               ICORE(IEND),MXCOR,IUHF,IP,.TRUE.)

C FORM d X(ai)/ d chi = d I(ia)/ d chi - d I(ai)/ d chi
        CALL TIMER(1)
        call checksum('nmrm2xa',icore(idiov),ndt(1))
c YAU : old
c       CALL ICOPY(NDT(1)*IINTFP,ICORE(IDIOV),1,ICORE(IXAI+IOFFX),1)
c YAU : new
        CALL DCOPY(NDT(1),ICORE(IDIOV),1,ICORE(IXAI+IOFFX),1)
c YAU : end
        call checksum('nmrm2xa',icore(ixai+ioffx),ndt(1))
        call checksum('nmrm2xa',icore(idivo),ndt(1))
        CALL SAXPY(NDT(1),ONEM,ICORE(IDIVO),1,ICORE(IXAI+IOFFX),1)
        call checksum('nmrm2xa',icore(ixai+ioffx),ndt(1))
        IF(IUHF.NE.0) THEN
c YAU : old
c        CALL ICOPY(NDT(2)*IINTFP,ICORE(IDIOVB),1,ICORE(IXAIB+IOFFX),1)
c YAU : new
         CALL DCOPY(NDT(2),ICORE(IDIOVB),1,ICORE(IXAIB+IOFFX),1)
c YAU : end
         CALL SAXPY(NDT(2),ONEM,ICORE(IDIVOB),1,
     &              ICORE(IXAIB+IOFFXB),1)
         call checksum('nmrm2xb',icore(ixaib+ioffxb),ndt(2))
        ENDIF
        CALL TIMER(1)
        write(6,6001) TIMENEW
6001    FORMAT(' Calculation of d X(a,i)/d chi required ',f5.1,
     &         ' seconds.')

C ADD d A(pq,rs) /d chi D(rs) TO d X(pq)/d chi
        CALL FORMDX(ICORE(IXAI+IOFFX),ICORE(IXAIB+IOFFXB),
     &              ICORE(IDVO),ICORE(IDVOB),ICORE(IEND),MXCOR,
     &              IUHF,IP,.TRUE.)

990    CONTINUE

C SOLVE FOR ALL PERTURBATION WITHIN THE GIVEN IRREP
C THE FIRST-ORDER Z-VECTOR EQUATIONS
       IF(NXFREAL.NE.0) THEN
       IF(NXFZ.EQ.1) THEN
        write(*,9700) nxfz
9700    FORMAT(' First-order Z-vector equations are solved for ',I1,
     &         ' perturbation.')
       ELSE
        write(*,9701) nxfz
9701    FORMAT(' First-order Z-vector equations are solved for ',I1,
     &         ' perturbations.')
       ENDIF
       CALL SOLVER(IRREPX,NXFZ,ICORE(IXAI),ICORE(IEND),MXCOR,IUHF,
     &             .TRUE.)
       do 999 ip=1,nxfz
        ioffx=(ip-1)*ndt(1)*IINTFP
        call checksum('ddvo    ',icore(ixai+ioffx),ndt(1))
999    continue

C FORM THE CONTRACTION OF dD(ai)/d chi WITH ALL d h(ai)/d In
       CALL DDXDF2(ICORE(IVAL),ICORE(IXAI),ICORE(IEND),
     &             MXCOR,IUHF,ISF,IEF)
       ENDIF

C KILL DERINT AND DERGAM FILES
       CALL ACES_IO_REMOVE(53,'DERINT')
       CALL ACES_IO_REMOVE(54,'DERGAM')

10000 CONTINUE

C  WRITE CHEMICAL SHIFTS TO CSHIFT FILE
      IF (.NOT.JSO) THEN
         CALL DUMPCSH(ICORE(IVAL),NTP,ICORE(IEND))
      ELSE
         CALL DUMPJSO(ICORE(IVAL),NTP,ICORE(IEND))
      END IF
      IF (.NOT.GIAO) THEN
         CALL DUMPMSZ(MSZ,ICORE(IEND))
      END IF

      RETURN
      END

