      SUBROUTINE AODTRN(ICORE,MAXCOR,IUHF,IRREPX,IPERT,ANTI)
C
C THIS ROUTINE DRIVES THE TRANSFORMATION OF THE GIAO-2E-INTEGRALS.
C SYMMETRY HAS BEEN IMPLEMENTED FOR ALL ABELIAN POINT GROUPS AND
C OUT-OF-CORE ALGORITHMS ARE AVAILABLE FOR LARGE CASES.
C
C J. GAUSS, UNIVERSITY KARLSRUHE, 1991 - 1992
C
CEND
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION TIMEI,TIMEL,TSTART,TEND,TCPU,TIME,
     &                 TIMEIN, TIMENOW, TIMETOT, TIMENEW 
      CHARACTER*8 LABEL
      CHARACTER*8 NAMXYZ
      CHARACTER*80 FNAME
      LOGICAL RHF,ANTI,NLEFT
      DIMENSION ICORE(MAXCOR)
      DIMENSION IOFFAO(8),IOFFI(8),ISIZE3(8),ISIZE2(8,8)
      DIMENSION IOFF3(8,8,8),ISIZE33(8,8,8),ISIZE44(8,8,8)
      DIMENSION ISIZET(8,8),IOFFW(8,8)
      DIMENSION NSTART(8),NEND(8)
      DIMENSION ITOTAL(8)
C      
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /INFO /  NOCCO(2),NVRTO(2)
      COMMON /SYMINF/ NDUMMY,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
      COMMON /SYM/ POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON /AOPOPS/ AOPOP(8)
      COMMON /AOOFST/ INDOCC(8,2)
      COMMON /BFILE/NAMXYZ(4,3)
      COMMON /PERT4/IXYZ
      COMMON /METH/ MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD
      COMMON /INFOL/ NREADL,NPASSL,TIMEL
      COMMON /INFOI/ TIMEI,NWRITI
      COMMON /TIMEINFO/ TIMEIN, TIMENOW, TIMETOT, TIMENEW 
C
      DATA ZERO/0.D0/
C
      NNP1O2(I)=(I*(I+1))/2
C
      CALL TIMER(1)
C
      WRITE(6,20000)
20000 FORMAT(' Transformation of GIAO integrals from AO to MO basis:')
C
C SET MXCOR (MAXIMUM AVAILABLE CORE MEMORY
C
      MXCOR=MAXCOR
C
C SET RHF/UHF FLAG
C
      RHF=.TRUE.
      IF(IUHF.NE.0)RHF=.FALSE.
C
C FILL /AOPOPS/
C
      CALL FAOPOP(POP,VRT,AOPOP,NIRREP)
      NBAS=NOCCO(1)+NVRTO(1)
      NBAS2=NBAS*NBAS
      NBAS3=NBAS2*NBAS
C
C DETERMINE MAXIMUM DISTRIBUTION LENGTHS
C
      MAXDIS=0
      DO 1 IRREP=1,NIRREP
       MAXDIS=MAX(MAXDIS,
     &            IRPDPD(IRREP,ISYTYP(1,316)),
     &            IRPDPD(IRREP,ISYTYP(1,330)),
     &            IRPDPD(IRREP,ISYTYP(1,325)),
     &            IRPDPD(IRREP,ISYTYP(1,321)),
     &            IRPDPD(IRREP,ISYTYP(1,313)),
     &            IRPDPD(IRREP,ISYTYP(1,310)))
1     CONTINUE
C
C GET EIGENVECTORS
C
      I000=1
      I010=I000+NBAS2*(1+IUHF)*IINTFP
      CALL PROCEVEC(ICORE,MXCOR,IUHF)
C
C CREATE LOOK UP VECTOR FOR IRREP OF EACH AO
C
      I020=I010+NBAS 
      IF(MOD(I020,IINTFP).EQ.0) I020=I020+1
      IND=0
      DO 2 IRREP=1,NIRREP
       DO 2 I=1,AOPOP(IRREP)
        ICORE(I010+IND)=IRREP
        IND=IND+1
2     CONTINUE
C
C ALLOCATE MEMORY FOR INTEGRAL BUFFERS
C
      ILNBUF=(8192-2)/(IINTFP+1)
      I030=I020+ILNBUF*IINTFP
      I040=I030+ILNBUF
C
C LOAD UP THE AO INTEGRALS
C
C MEMORY ALLPCATION FOR LOAD STEP
C
C      I000 .... MO COEFFICIENTS                   NBAS2*(1+IUHF)*IINTFP
C      I010 .... LOOK UP VECTOR                    NBAS2
C      I020 .... INTEGRAL BUFFER (VALUES)          ILNBUF*IINTFP
C      I030 .... INTEGRAL BUFFER (INDICES)         ILNBUF
C      I040 .... INTEGRAL ARRAY                    NSIZE
C      I050 .... SCRATCH ARRAY                     IINTFP*NOCC,IINTFP*MSIZE
C
       IF(IRREPX.EQ.1) THEN
C
        NREADL=0
        NPASSL=0
        TIMEL=ZERO
        TIMEI=ZERO
        NWRITI=0
C
        WRITE(6,20100) NAMXYZ(1,IXYZ)
20100   FORMAT(' Transformation of ',A5,' integral derivatives.')
C
        CALL IZERO(IOFFAO,8)
        CALL IZERO(IOFFI,8)
        CALL IZERO(ISIZE3,8)
C
        DO 1001 IRREP=1,NIRREP
         NSTART(IRREP)=1
         NEND(IRREP)=POP(IRREP,1)
1001    CONTINUE
C
C TRY FIRST FULL IN-CORE ALLOCATION
C
        NSIZE=0
        MSIZE=0
        MSIZE1=0
        IAO=0
        DO 1010 IRREP=1,NIRREP
         IOFFAO(IRREP)=IAO
         IOFFI(IRREP)=NSIZE
         ISIZ2=AOPOP(IRREP)*AOPOP(IRREP)
         ISIZE3(IRREP)=ISIZ2*AOPOP(IRREP)
         ISIZE4=ISIZE3(IRREP)*POP(IRREP,1)
         NSIZE=NSIZE+ISIZE4
         MSIZE=MAX(MSIZE,ISIZE3(IRREP))
         MSIZE1=MAX(MSIZE1,2*ISIZ2)
         IAO=IAO+AOPOP(IRREP)
1010    CONTINUE
        MSIZE2=MAXDIS
        MSIZE=MSIZE+MSIZE1+MSIZE2
C
C ALLOCATE ADDITIONAL MEMORY
C
        I050=I040+NSIZE*IINTFP
        IEND=I050+MAX(NOCCO(1),MSIZE*IINTFP)
        NLEFT=.FALSE.
C
        IF(IEND.LT.MXCOR) GO TO 1030
C
C OUT-OF-CORE ALGORITHM
C
1025    CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
        CALL IZERO(NEND,NIRREP)
        NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
        MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I040+1
        MEM=MEMLEFT/IINTFP
        IF(MEM.LT.0) CALL INSMEM('AOGTRN1B',MEM,MXCOR)
        NUMTOT=0
        DO 1028 IRREP1=1,NIRREP
         NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
         IF(NUMLEFT.EQ.0) THEN
          NEND(IRREP1)=NSTART(IRREP1)-1
         ELSE
          IF(ISIZE3(IRREP1).NE.0) THEN
           NUMTREAT=MEM/ISIZE3(IRREP1)
          ELSE
           NUMTREAT=MEM
          ENDIF
          IF(NUMTREAT.LT.NUMLEFT) THEN
           NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
           NUMTOT=NUMTOT+NUMTREAT
           GO TO 1029
          ELSE
           NEND(IRREP1)=POP(IRREP1,1)
           MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
           NUMTOT=NUMTOT+POP(IRREP1,1)
          ENDIF
         ENDIF
1028    CONTINUE
        NLEFT=.FALSE.
1029    CONTINUE
C
        IF(NLEFT.AND.NUMTOT.EQ.0)
     &         CALL INSMEM('AOGTRN1',IEND,MXCOR)
C
        NSIZE=0
        DO 1040 IRREP=1,NIRREP
         IOFFI(IRREP)=NSIZE
         ISIZE4=ISIZE3(IRREP)*(NEND(IRREP)-NSTART(IRREP)+1)
         NSIZE=NSIZE+ISIZE4
1040    CONTINUE
C
C ALLOCATE ADDITIONAL MEMORY
C
        I050=I040+NSIZE*IINTFP
        IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
        IF(IEND.GE.MXCOR) CALL INSMEM('AOGTRN1',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
1030    CONTINUE
C
        CALL LOADA1(ICORE(I000),ICORE(I040),ICORE(I050),ICORE(I020),
     &              ICORE(I030),ICORE(I010),AOPOP,NSTART,NEND,
     &              ISIZE3,IOFFAO,IOFFI,NSIZE,ILNBUF,IPERT,1)
C
C TRANSFORM THIS SPIN CASE TO THE MO BASIS AND WRITE THE RESULT TO
C  DISK
C
C MEMORY FOR DINTRN1 STEP
C
C       I000 .... MO COEFFICIENTS          NBAS2*(1+IUHF)*IINTFP
C       I040 .... INTEGRALS                NSIZE*IINTFP
C       I050 .... SCRATCH ARRAY            MSIZE*IINTFP
C
        CALL DINTRN1(ICORE(I000),ICORE(I040),ICORE(I050),
     &               RHF,NSTART,NEND,1)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
        IF(NLEFT) THEN
         DO 1060 IRREP1=1,NIRREP
          NSTART(IRREP1)=NEND(IRREP1)+1
1060     CONTINUE
         GO TO 1025
        ENDIF
C
        IF(NPASSL.EQ.1) THEN
         WRITE(6,20111) NPASSL
        ELSE IF(NPASSL.LE.9) THEN
         WRITE(6,20121) NPASSL
        ELSE 
         WRITE(6,20131) NPASSL
        ENDIF
        WRITE(6,20102) NREADL,NAMXYZ(1,IXYZ)
        WRITE(6,20103) TIMEL
        WRITE(6,20104) TIMEI  
        WRITE(6,20105) NWRITI
        
20111   FORMAT(I2,' pass through the AO integral derivative',
     &            ' file was needed.')
20121   FORMAT(I2,' passes through the AO integral derivative',
     &            ' file were needed.')
20131   FORMAT(I3,' passes through the AO integral derivative',
     &            ' file were needed.')
20102   FORMAT(I10,' AO integral derivatives were read from file ',
     &             A5,'.')
20103   FORMAT(' Transformation of first index required ',f6.1,
     &         ' seconds.')
20104   FORMAT(' Transformation of remaining indices required ',f6.1,
     &         ' seconds.')
20105   FORMAT(I10,' MO integral derivatives were written to',
     &         ' file DERINT.')
C
        CALL GFNAME(NAMXYZ(1,IXYZ),FNAME,ILENGTH)
        OPEN(UNIT=99,FILE=FNAME(1:ILENGTH))
        CLOSE(UNIT=99,STATUS='DELETE')
C
        IF(NIRREP.GT.1) THEN 
C
C TRANSFORM IIJJ INTEGRALS (ONLY FOR IRREP GE 2)
C
         WRITE(6,20100) NAMXYZ(2,IXYZ)
C
         NREADL=0
         NPASSL=0
         TIMEL=ZERO
         TIMEI=ZERO
         NWRITI=0
C
C GET INDEXING ARRAYS AND ALLOCATE MEMORY
C
         CALL IZERO(IOFFI,8)
         CALL IZERO(ISIZE3,8)
         CALL IZERO(ISIZE2,64)
C
         DO 2001 IRREP=1,NIRREP
          NSTART(IRREP)=1
          NEND(IRREP)=POP(IRREP,1)
2001     CONTINUE
C
         NSIZE=0
         MSIZE=0
         MSIZE1=0
         DO 2010 IRREP1=1,NIRREP
          IOFF2=0
          DO 2011 IRREP2=1,NIRREP
           IF(IRREP1.EQ.IRREP2) GO TO 2011
           ISIZE2(IRREP1,IRREP2)=IOFF2
           IOFF2=IOFF2+AOPOP(IRREP2)*AOPOP(IRREP2)
           MSIZE=MAX(MSIZE,AOPOP(IRREP2)*AOPOP(IRREP2)*AOPOP(IRREP1))
           MSIZE1=MAX(MSIZE1,2*AOPOP(IRREP2)*AOPOP(IRREP1))
2011      CONTINUE
          ISIZE3(IRREP1)=AOPOP(IRREP1)*IOFF2
          MSIZE=MAX(MSIZE,IOFF2)
          IOFFI(IRREP1)=NSIZE
          NSIZE=NSIZE+POP(IRREP1,1)*ISIZE3(IRREP1)
2010     CONTINUE
C
         MSIZE=MSIZE+MSIZE1+MAXDIS
C
C ALLOCATE ADDITIONAL MEMORY
C
         I050=I040+NSIZE*IINTFP
         IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
         NLEFT=.FALSE.
C
         IF(IEND.LT.MXCOR) GO TO 2030
C
C OUT-OF-CORE ALGORITHM
C
2025     CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
         CALL IZERO(NEND,NIRREP)
         NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
         MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I040+1
         MEM=MEMLEFT/IINTFP
         IF(MEM.LT.0) CALL INSMEM('AOGTRN2B',MEM,MXCOR)
         NUMTOT=0
         DO 2028 IRREP1=1,NIRREP
          NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
          IF(NUMLEFT.EQ.0) THEN
           NEND(IRREP1)=NSTART(IRREP1)-1
          ELSE
           IF(ISIZE3(IRREP1).NE.0) THEN
            NUMTREAT=MEM/ISIZE3(IRREP1)
           ELSE
            NUMTREAT=MEM
           ENDIF
           IF(NUMTREAT.LT.NUMLEFT) THEN
            NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
            NUMTOT=NUMTOT+NUMTREAT
            GO TO 2029
           ELSE
            NEND(IRREP1)=POP(IRREP1,1)
            MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
            NUMTOT=NUMTOT+POP(IRREP1,1)
           ENDIF
          ENDIF
2028     CONTINUE
         NLEFT=.FALSE.
2029     CONTINUE
C
         NSIZE=0
         DO 2040 IRREP1=1,NIRREP
          IOFFI(IRREP1)=NSIZE
          NSIZE=NSIZE+(NEND(IRREP1)-NSTART(IRREP1)+1)
     &                   *ISIZE3(IRREP1)
2040     CONTINUE
C
C ALLOCATE ADDITIONAL MEMORY
C
         I050=I040+NSIZE*IINTFP
         IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
         IF(IEND.GE.MXCOR) CALL INSMEM('AOGTRN2',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
2030     CONTINUE
C
         CALL LOADA2(ICORE(I000),ICORE(I040),ICORE(I050),
     &               ICORE(I020),ICORE(I030),ICORE(I010),
     &               AOPOP,NSTART,NEND,ISIZE3,ISIZE2,IOFFAO,
     &               IOFFI,NSIZE,ILNBUF,IPERT,1)
C
C TRANSFORM THIS SPIN CASE TO THE MO BASIS AND WRITE THE RESULT TO
C  DISK
C
C MEMORY FOR DINTRN2 STEP
C
C       I000 .... MO COEFFICIENTS          NBAS2*(1+IUHF)*IINTFP
C       I040 .... INTEGRALS                NSIZE*IINTFP
C       I050 .... SCRATCH ARRAY            MSIZE*IINTFP
C
         CALL DINTRN2(ICORE(I000),ICORE(I040),ICORE(I050),RHF,
     &                NSTART,NEND,1)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
         IF(NLEFT) THEN
          DO 2060 IRREP1=1,NIRREP
           NSTART(IRREP1)=NEND(IRREP1)+1
2060      CONTINUE
          GO TO 2025
         ENDIF
C
         IF(NPASSL.EQ.1) THEN
          WRITE(6,20111) NPASSL
         ELSE IF(NPASSL.LE.9) THEN
          WRITE(6,20121) NPASSL
         ELSE 
          WRITE(6,20131) NPASSL
         ENDIF
         WRITE(6,20102) NREADL,NAMXYZ(2,IXYZ)
         WRITE(6,20103) TIMEL
         WRITE(6,20104) TIMEI  
         WRITE(6,20105) NWRITI
         CALL GFNAME(NAMXYZ(2,IXYZ),FNAME,ILENGTH)
         OPEN(UNIT=99,FILE=FNAME(1:ILENGTH))
         CLOSE(UNIT=99,STATUS='DELETE')
C
C TRANSFORM IJIJ INTEGRALS 
C
         WRITE(6,20100) NAMXYZ(3,IXYZ)
C
         NREADL=0
         NPASSL=0
         NWRITI=0
         TIMEL=ZERO
         TIMEI=ZERO
C
C GET INDEXING ARRAYS AND ALLOCATE MEMORY
C
         CALL IZERO(IOFFI,8)
         CALL IZERO(ISIZE3,8)
         CALL IZERO(IOFF3,64)
C
         DO 3001 IRREP=1,NIRREP
          NSTART(IRREP)=1
          NEND(IRREP)=POP(IRREP,1)
3001     CONTINUE
C
         NSIZE=0
         MSIZE=0
         MSIZE1=0
         DO 3010 IRREP1=1,NIRREP
          ISIZ3=0
          DO 3011 IRREP2=1,NIRREP
          IF(IRREP1.EQ.IRREP2) GO TO 3011
          IOFF3(IRREP1,IRREP2,1)=ISIZ3
          ISIZ3=ISIZ3+AOPOP(IRREP1)*AOPOP(IRREP2)*AOPOP(IRREP2)
          IOFF3(IRREP1,IRREP2,2)=ISIZ3
          ISIZ3=ISIZ3+AOPOP(IRREP1)*AOPOP(IRREP2)*AOPOP(IRREP2)
          MSIZE=MAX(MSIZE,AOPOP(IRREP1)*AOPOP(IRREP2)*AOPOP(IRREP2))
          MSIZE1=MAX(MSIZE1,2*AOPOP(IRREP2)*AOPOP(IRREP1))
3011      CONTINUE
          MSIZE1=MAX(MSIZE1,2*AOPOP(IRREP1)*AOPOP(IRREP1))
          ISIZE3(IRREP1)=ISIZ3
          IOFFI(IRREP1)=NSIZE
          NSIZE=NSIZE+ISIZ3*POP(IRREP1,1)
3010     CONTINUE
C
         MSIZE2=MAX(MSIZE1,MAXDIS)
         MSIZE=MSIZE+MSIZE1+MSIZE2
C
C ALLOCATE ADDITIONAL MEMORY
C
         I050=I040+NSIZE*IINTFP
         IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
         NLEFT=.FALSE.
C
         IF(IEND.LT.MXCOR) GO TO 3030
3025     CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
         CALL IZERO(NEND,NIRREP)
         NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
         MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I040+1
         MEM=MEMLEFT/IINTFP
         IF(MEM.LT.0) CALL INSMEM('AOGTRN3B',MEM,MXCOR)
         NUMTOT=0
         DO 3028 IRREP1=1,NIRREP
          NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
          IF(NUMLEFT.EQ.0) THEN
           NEND(IRREP1)=NSTART(IRREP1)-1
          ELSE
           IF(ISIZE3(IRREP1).NE.0) THEN
            NUMTREAT=MEM/ISIZE3(IRREP1)
           ELSE
            NUMTREAT=MEM
           ENDIF
           IF(NUMTREAT.LT.NUMLEFT) THEN
            NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
            NUMTOT=NUMTOT+NUMTREAT
            GO TO 3029
           ELSE
            NEND(IRREP1)=POP(IRREP1,1)
            MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
            NUMTOT=NUMTOT+POP(IRREP1,1)
           ENDIF
          ENDIF
3028     CONTINUE
         NLEFT=.FALSE.
3029     CONTINUE
C
         IF(NLEFT.AND.NUMTOT.EQ.0)
     &          CALL INSMEM('AOGTRN3',IEND,MXCOR)
C
         NSIZE=0
         DO 3040 IRREP=1,NIRREP
          IOFFI(IRREP)=NSIZE
          ISIZE4=ISIZE3(IRREP)*(NEND(IRREP)-NSTART(IRREP)+1)
          NSIZE=NSIZE+ISIZE4
3040     CONTINUE
C
C ALLOCATE ADDITIONAL MEMORY
C
         I050=I040+NSIZE*IINTFP
         IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
         IF(IEND.GE.MXCOR) CALL INSMEM('AOGTRN3',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE

3030     CONTINUE
C
         CALL LOADA3(ICORE(I000),ICORE(I040),ICORE(I050),
     &               ICORE(I020),ICORE(I030),ICORE(I010),
     &               AOPOP,NSTART,NEND,ISIZE3,IOFFAO,IOFFI,
     &               IOFF3,NSIZE,ILNBUF,IPERT,1)
C
C TRANSFORM THIS SPIN CASE TO THE MO BASIS AND WRITE THE RESULT TO
C  DISK
C
C MEMORY FOR DINTRN3 STEP
C
C       I000 .... MO COEFFICIENTS          NBAS2*(1+IUHF)*IINTFP
C       I040 .... INTEGRALS                NSIZE*IINTFP
C       I050 .... SCRATCH ARRAY            MSIZE*IINTFP
C
         CALL DINTRN3(ICORE(I000),ICORE(I040),ICORE(I050),RHF,
     &                NSTART,NEND,1)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
         IF(NLEFT) THEN
          DO 3060 IRREP1=1,NIRREP
           NSTART(IRREP1)=NEND(IRREP1)+1
3060      CONTINUE
          GO TO 3025
         ENDIF
C
         IF(NPASSL.EQ.1) THEN
          WRITE(6,20111) NPASSL
         ELSE IF(NPASSL.LE.9) THEN
          WRITE(6,20121) NPASSL
         ELSE 
          WRITE(6,20131) NPASSL
         ENDIF
         WRITE(6,20102) NREADL,NAMXYZ(3,IXYZ)
         WRITE(6,20103) TIMEL
         WRITE(6,20104) TIMEI  
         WRITE(6,20105) NWRITI
         CALL GFNAME(NAMXYZ(3,IXYZ),FNAME,ILENGTH)
         OPEN(UNIT=99,FILE=FNAME(1:ILENGTH))
         CLOSE(UNIT=99,STATUS='DELETE')
C
         IF(NIRREP.GT.2) THEN
C
          WRITE(6,20100) NAMXYZ(4,IXYZ)
C
          NREADL=0
          NPASSL=0
          NWRITI=0
          TIMEL=ZERO
          TIMEI=ZERO
C
          CALL IZERO(IOFFW,64)
          CALL IZERO(ISIZE33,512)
          CALL IZERO(ISIZE3,8)
          CALL IZERO(ISIZET,64)
C
          DO 4001 IRREP=1,NIRREP
           NSTART(IRREP)=1
           NEND(IRREP)=POP(IRREP,1)
4001      CONTINUE
C
C
          NSIZE=0
          MSIZE=0
          IOFF=0
          DO 4010 IRREP1=1,NIRREP
           DO 4020 IRREP2=1,NIRREP
            IOFFW(IRREP1,IRREP2)=IOFF
            IRREP12=DIRPRD(IRREP1,IRREP2)
            IF(IRREP12.EQ.1) GO TO 4020
            IOFF2=0
            DO 4030 IRREP3=1,NIRREP
             IF(IRREP3.EQ.IRREP1.OR.IRREP3.EQ.IRREP2) GO TO 4030
             IRREP4=DIRPRD(IRREP3,IRREP12)
             IF(IRREP4.EQ.IRREP1.OR.IRREP4.EQ.IRREP2
     &          .OR.IRREP4.EQ.IRREP3) GO TO 4030
             ISIZ3=AOPOP(IRREP2)*AOPOP(IRREP3)*AOPOP(IRREP4)
             ISIZE33(IRREP1,IRREP3,IRREP4)=IOFF2
             MSIZE=MAX(MSIZE,ISIZ3)
             IOFF2=IOFF2+AOPOP(IRREP3)*AOPOP(IRREP4)
             IOFF=IOFF+ISIZ3*POP(IRREP1,1)
             ISIZE3(IRREP1)=ISIZE3(IRREP1)+ISIZ3
4030        CONTINUE
            ISIZET(IRREP1,IRREP2)=IOFF2*AOPOP(IRREP2)
4020       CONTINUE
4010      CONTINUE
          NSIZE=IOFF
C
C ALLOCATE ADDITIONAL MEMORY
C
          I050=I040+NSIZE*IINTFP
          IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
          NLEFT=.FALSE.
          IF(IEND.LT.MXCOR) GO TO 4031
C
C OUT-OF-CORE ALGORITHM REQUIRED
C
4025      CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
           CALL IZERO(NEND,NIRREP)
           NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
           MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I040+1
           MEM=MEMLEFT/IINTFP
           IF(MEM.LT.0) CALL INSMEM('AOGTRN4B',MEM,MXCOR)
           NUMTOT=0
           DO 4028 IRREP1=1,NIRREP
            NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
            IF(NUMLEFT.EQ.0) THEN
             NEND(IRREP1)=NSTART(IRREP1)-1
            ELSE
             IF(ISIZE3(IRREP1).NE.0) THEN
              NUMTREAT=MEM/ISIZE3(IRREP1)
             ELSE
              NUMTREAT=MEM
             ENDIF
             IF(NUMTREAT.LT.NUMLEFT) THEN
              NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
              NUMTOT=NUMTOT+NUMTREAT
              GO TO 4029
             ELSE
              NEND(IRREP1)=POP(IRREP1,1)
              MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
              NUMTOT=NUMTOT+POP(IRREP1,1)
             ENDIF
            ENDIF
4028       CONTINUE
           NLEFT=.FALSE.
4029       CONTINUE
C
           IF(NLEFT.AND.NUMTOT.EQ.0)
     &               CALL INSMEM('AOGTRN4',IEND,MXCOR)
C
C GET POINTERS FOR ADRESS
C
           IOFF=0
           DO 4040 IRREP1=1,NIRREP
            DO 4050 IRREP2=1,NIRREP
             IOFFW(IRREP1,IRREP2)=IOFF
             IRREP12=DIRPRD(IRREP1,IRREP2)
             IF(IRREP12.EQ.1) GO TO 4050
             IOFF2=0
             DO 4060 IRREP3=1,NIRREP
              IF(IRREP3.EQ.IRREP1.OR.IRREP3.EQ.IRREP2) GO TO 4060
              IRREP4=DIRPRD(IRREP3,IRREP12)
              IF(IRREP4.EQ.IRREP1.OR.IRREP4.EQ.IRREP2
     &           .OR.IRREP4.EQ.IRREP3) GO TO 4060
              ISIZ3=AOPOP(IRREP2)*AOPOP(IRREP3)*AOPOP(IRREP4)
              IOFF=IOFF+ISIZ3*(NEND(IRREP1)-NSTART(IRREP1)+1)
4060         CONTINUE
4050        CONTINUE
4040      CONTINUE
C
C ALLOCATE ADDITIONAL MEMORY
C
          NSIZE=IOFF
          I050=I040+NSIZE*IINTFP
          IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
          IF(IEND.GE.MXCOR) CALL INSMEM('AOGTRN4A',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE


C
4031      CONTINUE
          CALL LOADA12(ICORE(I000),ICORE(I040),ICORE(I050),
     &                ICORE(I020),ICORE(I030),ICORE(I010),
     &                AOPOP,NSTART,NEND,IOFFAO,IOFFW,ISIZET,
     &                ISIZE33,NSIZE,ILNBUF,1,IPERT,1)
          CALL DINTRN12(ICORE(I000),ICORE(I040),ICORE(I050),RHF,
     &                NSTART,NEND,1,1)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
         IF(NLEFT) THEN
          DO 4080 IRREP1=1,NIRREP
           NSTART(IRREP1)=NEND(IRREP1)+1
4080       CONTINUE
          GO TO 4025
         ENDIF
C
          IF(NPASSL.EQ.1) THEN
           WRITE(6,20111) NPASSL
          ELSE IF(NPASSL.LE.9) THEN
           WRITE(6,20121) NPASSL
          ELSE 
           WRITE(6,20131) NPASSL
          ENDIF
          WRITE(6,20102) NREADL,NAMXYZ(4,IXYZ)
          WRITE(6,20103) TIMEL
          WRITE(6,20104) TIMEI  
          WRITE(6,20105) NWRITI
          CALL GFNAME(NAMXYZ(4,IXYZ),FNAME,ILENGTH)
          OPEN(UNIT=99,FILE=FNAME(1:ILENGTH))
          CLOSE(UNIT=99,STATUS='DELETE')
C
         ENDIF
        ENDIF
       ELSE
C
C TRANSFORM JIII INTEGRALS  (J = OCC) 
C
        WRITE(6,20100) NAMXYZ(1,IXYZ)
C
        NREADL=0
        NPASSL=0
        NWRITI=0
        TIMEL=ZERO
        TIMEI=ZERO
C
C ALLOCATE MEMORY AND GET INDEXING ARRAYS
C
        CALL IZERO(IOFFAO,8)
        CALL IZERO(ISIZE3,8)
        CALL IZERO(IOFFI,8)
C
        DO 5001 IRREP=1,NIRREP
         NSTART(IRREP)=1
         NEND(IRREP)=POP(IRREP,1)
5001    CONTINUE
C
        NSIZE=0
        MSIZE=0 
        MSIZE1=0 
        IAO=0
        DO 5010 IRREP1=1,NIRREP
C
         IOFFAO(IRREP1)=IAO
         IAO=IAO+AOPOP(IRREP1) 
         IRREP2=DIRPRD(IRREPX,IRREP1)
         ISIZE3(IRREP1)=AOPOP(IRREP2)*AOPOP(IRREP2)*AOPOP(IRREP2)
         IOFFI(IRREP1)=NSIZE
         NSIZE=NSIZE+ISIZE3(IRREP1)*POP(IRREP1,1)
         MSIZE=MAX(MSIZE,ISIZE3(IRREP1))
         MSIZE1=MAX(MSIZE,2*AOPOP(IRREP2)*AOPOP(IRREP2))
C
5010    CONTINUE
        MSIZE=MSIZE+MSIZE1+MAXDIS
C
C ALLOCATE ADDITIONAL MEMORY
C
C       I000 .... MO COEFFICIENTS
C       I010 ....
C       I020 ....
C       I030 ....
C       I040 .... AO-INTEGRALS WITh FIRST INDEX TRANSFORMED TO MO BASIS
C       I050 .... SCRATCH ARRAY OF SIZE NOCCO(1)
C
        I050=I040+NSIZE*IINTFP
        IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
        NLEFT=.FALSE.
C
        IF(IEND.LT.MXCOR) GO TO 5030
5025    CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
        CALL IZERO(NEND,NIRREP)
        NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
        MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I040+1
        MEM=MEMLEFT/IINTFP
        IF(MEM.LT.0) CALL INSMEM('AOGTRN5B',MEM,MXCOR)
        NUMTOT=0
        DO 5028 IRREP1=1,NIRREP
         NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
         IF(NUMLEFT.EQ.0) THEN
          NEND(IRREP1)=NSTART(IRREP1)-1
         ELSE
          IF(ISIZE3(IRREP1).NE.0) THEN
           NUMTREAT=MEM/ISIZE3(IRREP1)
          ELSE
           NUMTREAT=MEM
          ENDIF
          IF(NUMTREAT.LT.NUMLEFT) THEN
           NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
           NUMTOT=NUMTOT+NUMTREAT
           GO TO 5029
          ELSE
           NEND(IRREP1)=POP(IRREP1,1)
           MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
           NUMTOT=NUMTOT+POP(IRREP1,1)
          ENDIF
         ENDIF
5028    CONTINUE
        NLEFT=.FALSE.
5029    CONTINUE
C
        IF(NLEFT.AND.NUMTOT.EQ.0)
     &        CALL INSMEM('AOGTRN5',IEND,MXCOR)
C
        NSIZE=0
        DO 5040 IRREP1=1,NIRREP
         IOFFI(IRREP1)=NSIZE
         NSIZE=NSIZE+ISIZE3(IRREP1)*(NEND(IRREP1)-NSTART(IRREP1)+1)
5040    CONTINUE
C
C ALLOCATE ADDITIONAL MEMORY
C
        I050=I040+NSIZE*IINTFP
        IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
        IF(IEND.GE.MXCOR) CALL INSMEM('AOGTRN5',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
5030    CONTINUE
C
        CALL LOADA5(ICORE(I000),ICORE(I040),ICORE(I050),
     &              ICORE(I020),ICORE(I030),ICORE(I010),
     &              AOPOP,NSTART,NEND,ISIZE3,IOFFAO,
     &              IOFFI,NSIZE,ILNBUF,IRREPX,IPERT,1)
C
C MEMORY FOR DINTRN5 STEP
C
C       I000 .... MO COEFFICIENTS          NBAS2*(1+IUHF)*IINTFP
C       I040 .... INTEGRALS                NSIZE*IINTFP
C       I050 .... SCRATCH ARRAY            MSIZE*IINTFP
C
        CALL DINTRN5(ICORE(I000),ICORE(I040),ICORE(I050),RHF,
     &               NSTART,NEND,IRREPX,1)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
        IF(NLEFT) THEN
         DO 5060 IRREP1=1,NIRREP
          NSTART(IRREP1)=NEND(IRREP1)+1
5060     CONTINUE
         GO TO 5025
        ENDIF
C
C TRANSFORM IJII INTEGRALS (J SECOND INDEX)
C ALLOCATE MEMORY AND GET INDEXING ARRAYS
C
        CALL IZERO(ISIZE3,8)
        CALL IZERO(IOFFI,8)
C
        DO 6001 IRREP=1,NIRREP
         NSTART(IRREP)=1
         NEND(IRREP)=POP(IRREP,1)
6001   CONTINUE
C
        NSIZE=0
        MSIZE=0
        MSIZE1=0
        DO 6010 IRREP1=1,NIRREP
C
         IRREP2=DIRPRD(IRREPX,IRREP1)
         ISIZE3(IRREP1)=AOPOP(IRREP1)*AOPOP(IRREP1)*AOPOP(IRREP2)
         IOFFI(IRREP1)=NSIZE
         NSIZE=NSIZE+ISIZE3(IRREP1)*POP(IRREP1,1)
         MSIZE=MAX(MSIZE,ISIZE3(IRREP1))
         MSIZE1=MAX(MSIZE1,2*AOPOP(IRREP2)*AOPOP(IRREP1))
C
6010    CONTINUE
        MSIZE2=MAXDIS
        MSIZE=MSIZE+MSIZE1+MSIZE2
C
C ALLOCATE ADDITIONAL MEMORY
C
C       I000 .... MO COEFFICIENTS
C       I010 ....
C       I020 ....
C       I030 ....
C       I040 .... AO-INTEGRALS WITh FIRST INDEX TRANSFORMED TO MO BASIS
C       I050 .... SCRATCH ARRAY OF SIZE NOCCO(1)
C
        I050=I040+NSIZE*IINTFP
        IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
        NLEFT=.FALSE.
C
        IF(IEND.LT.MXCOR) GO TO 6030
6025    CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
        CALL IZERO(NEND,NIRREP)
        NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
        MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I040+1
        MEM=MEMLEFT/IINTFP
        IF(MEM.LT.0) CALL INSMEM('AOGTRN5B',MEM,MXCOR)
        NUMTOT=0
        DO 6028 IRREP1=1,NIRREP
         NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
         IF(NUMLEFT.EQ.0) THEN
          NEND(IRREP1)=NSTART(IRREP1)-1
         ELSE
          IF(ISIZE3(IRREP1).NE.0) THEN
           NUMTREAT=MEM/ISIZE3(IRREP1)
          ELSE
           NUMTREAT=MEM
          ENDIF
          IF(NUMTREAT.LT.NUMLEFT) THEN
           NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
           NUMTOT=NUMTOT+NUMTREAT
           GO TO 6029
          ELSE
           NEND(IRREP1)=POP(IRREP1,1)
           MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
           NUMTOT=NUMTOT+POP(IRREP1,1)
          ENDIF
         ENDIF
6028    CONTINUE
        NLEFT=.FALSE.
6029    CONTINUE
C
        IF(NLEFT.AND.NUMTOT.EQ.0)
     &         CALL INSMEM('AOGTRN6',IEND,MXCOR)
C
        NSIZE=0
        DO 6040 IRREP1=1,NIRREP
         IOFFI(IRREP1)=NSIZE
         NSIZE=NSIZE+ISIZE3(IRREP1)*(NEND(IRREP1)-NSTART(IRREP1)+1)
6040    CONTINUE
C
C ALLOCATE ADDITIONAL MEMORY
C
        I050=I040+NSIZE*IINTFP
        IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
        IF(IEND.GE.MXCOR) CALL INSMEM('AOGTRN6',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
6030    CONTINUE

        CALL LOADA6(ICORE(I000),ICORE(I040),ICORE(I050),
     &              ICORE(I020),ICORE(I030),ICORE(I010),
     &              AOPOP,NSTART,NEND,ISIZE3,IOFFAO,IOFFI,
     &              NSIZE,ILNBUF,IRREPX,IPERT,1)
C
C MEMORY FOR DINTRN6 STEP
C
C       I000 .... MO COEFFICIENTS          NBAS2*(1+IUHF)*IINTFP
C       I040 .... INTEGRALS                NSIZE*IINTFP
C       I050 .... SCRATCH ARRAY            MSIZE*IINTFP
C
        CALL DINTRN6(ICORE(I000),ICORE(I040),ICORE(I050),RHF,
     &               NSTART,NEND,IRREPX,1)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
        IF(NLEFT) THEN
         DO 6060 IRREP1=1,NIRREP
          NSTART(IRREP1)=NEND(IRREP1)+1
6060     CONTINUE
         GO TO 6025
        ENDIF
C
C TRANSFORM IIJI INTEGRALS (J THIRD INDEX)
C ALLOCATE MEMORY AND GET INDEXING ARRAYS
C
        CALL IZERO(ISIZE3,8)
        CALL IZERO(IOFFI,8)
C
        DO 7001 IRREP=1,NIRREP
         NSTART(IRREP)=1
         NEND(IRREP)=POP(IRREP,1)
7001    CONTINUE
C
        NSIZE=0
        MSIZE=0
        MSIZE1=0
        DO 7010 IRREP1=1,NIRREP
C
         IRREP2=DIRPRD(IRREPX,IRREP1)
         ISIZE3(IRREP1)=2*AOPOP(IRREP1)*AOPOP(IRREP1)*AOPOP(IRREP2)
         IOFFI(IRREP1)=NSIZE
         NSIZE=NSIZE+ISIZE3(IRREP1)*POP(IRREP1,1)
         MSIZE=MAX(MSIZE,ISIZE3(IRREP1))
         MSIZE1=MAX(MSIZE1,2*AOPOP(IRREP1)*AOPOP(IRREP1),
     &                     2*AOPOP(IRREP1)*AOPOP(IRREP2))
C
7010    CONTINUE
        MSIZE2=MAX(MAXDIS,MSIZE1)
        MSIZE=MSIZE+MSIZE1+MSIZE2
C
C ALLOCATE ADDITIONAL MEMORY
C
C       I000 .... MO COEFFICIENTS
C       I010 ....
C       I020 ....
C       I030 ....
C       I040 .... AO-INTEGRALS WITh FIRST INDEX TRANSFORMED TO MO BASIS
C       I050 .... SCRATCH ARRAY OF SIZE NOCCO(1)
C
        I050=I040+NSIZE*IINTFP
        IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
        NLEFT=.FALSE.
C
        IF(IEND.LT.MXCOR) GO TO 7030
7025    CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
        CALL IZERO(NEND,NIRREP)
        NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
        MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I040+1
        MEM=MEMLEFT/IINTFP
        IF(MEM.LT.0) CALL INSMEM('AOGTRN7B',MEM,MXCOR)
        NUMTOT=0
        DO 7028 IRREP1=1,NIRREP
         NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
         IF(NUMLEFT.EQ.0) THEN
          NEND(IRREP1)=NSTART(IRREP1)-1
         ELSE
          IF(ISIZE3(IRREP1).NE.0) THEN
           NUMTREAT=MEM/ISIZE3(IRREP1)
          ELSE
           NUMTREAT=MEM
          ENDIF
          IF(NUMTREAT.LT.NUMLEFT) THEN
           NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
           NUMTOT=NUMTOT+NUMTREAT
           GO TO 7029
          ELSE
           NEND(IRREP1)=POP(IRREP1,1)
           MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
           NUMTOT=NUMTOT+POP(IRREP1,1)
          ENDIF
         ENDIF
7028    CONTINUE
        NLEFT=.FALSE.
7029    CONTINUE
C
        IF(NLEFT.AND.NUMTOT.EQ.0)
     &         CALL INSMEM('AOGTRN7',IEND,MXCOR)
C
        NSIZE=0
        DO 7040 IRREP1=1,NIRREP
         IOFFI(IRREP1)=NSIZE
         NSIZE=NSIZE+ISIZE3(IRREP1)*(NEND(IRREP1)-NSTART(IRREP1)+1)
7040    CONTINUE

C ALLOCATE ADDITIONAL MEMORY
C
        I050=I040+NSIZE*IINTFP
        IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
        IF(IEND.GE.MXCOR) CALL INSMEM('AOGTRN7',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
7030    CONTINUE
C
        CALL LOADA7(ICORE(I000),ICORE(I040),ICORE(I050),
     &              ICORE(I020),ICORE(I030),ICORE(I010),
     &              AOPOP,NSTART,NEND,ISIZE3,IOFFAO,IOFFI,
     &              NSIZE,ILNBUF,IRREPX,IPERT,1)
C
        CALL DINTRN7(ICORE(I000),ICORE(I040),ICORE(I050),RHF,
     &               NSTART,NEND,IRREPX,1)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
        IF(NLEFT) THEN
         DO 7060 IRREP1=1,NIRREP
          NSTART(IRREP1)=NEND(IRREP1)+1
7060     CONTINUE
         GO TO 7025
        ENDIF
C
        IF(NPASSL.EQ.1) THEN
         WRITE(6,20111) NPASSL
        ELSE IF(NPASSL.LE.9) THEN
         WRITE(6,20121) NPASSL
        ELSE 
         WRITE(6,20131) NPASSL
        ENDIF
        WRITE(6,20102) NREADL,NAMXYZ(1,IXYZ)
        WRITE(6,20103) TIMEL
        WRITE(6,20104) TIMEI  
        WRITE(6,20105) NWRITI
        CALL GFNAME(NAMXYZ(1,IXYZ),FNAME,ILENGTH)
        OPEN(UNIT=99,FILE=FNAME(1:ILENGTH))
        CLOSE(UNIT=99,STATUS='DELETE')
C
        IF(NIRREP.GT.2) THEN
C
C TRANSFORM IIJK INTEGRALS
C
         WRITE(6,20100) NAMXYZ(2,IXYZ)
C
         NREADL=0
         NPASSL=0
         NWRITI=0
         TIMEL=ZERO
         TIMEI=ZERO
C
C ALLOCATE MEMORY AND GET INDEXING ARRAYS
C
         CALL IZERO(ISIZE3,8)
         CALL IZERO(ISIZET,64)
         CALL IZERO(IOFFI,8)
C
         DO 8001 IRREP=1,NIRREP
          NSTART(IRREP)=1
          NEND(IRREP)=POP(IRREP,1)
8001     CONTINUE
C
         NSIZE=0
         MSIZE=0 
         MSIZE2=0 
         MSIZE3=0 
         IOFF=0
         DO 8010 IRREP1=1,NIRREP
C
          IOFF1=0
          IOFFI(IRREP1)=IOFF
          MSIZE1=0
          DO 8011 IRREP3=1,NIRREP
           IRREP4=DIRPRD(IRREPX,IRREP3)
           IF(IRREP3.NE.IRREP1.AND.IRREP4.NE.IRREP1) THEN
            ISIZE3(IRREP1)=ISIZE3(IRREP1)+AOPOP(IRREP1)*          
     &                     AOPOP(IRREP3)*AOPOP(IRREP4)
            MSIZE1=MSIZE1+AOPOP(IRREP1)*AOPOP(IRREP3)*
     &                     AOPOP(IRREP4)
            MSIZE2=MAX(MSIZE2,AOPOP(IRREP1)*AOPOP(IRREP3)*AOPOP(IRREP4))
            MSIZE3=MAX(MSIZE3,2*AOPOP(IRREP1)*AOPOP(IRREP3))
            ISIZET(IRREP1,IRREP3)=IOFF1
            IOFF1=IOFF1+AOPOP(IRREP3)*AOPOP(IRREP4)
           ENDIF
8011      CONTINUE
          MSIZE=MAX(MSIZE,MSIZE1)
          IOFF=IOFF+ISIZE3(IRREP1)*POP(IRREP1,1)
          MSIZE3=MAX(MSIZE3,2*AOPOP(IRREP1)*AOPOP(IRREP1))
8010     CONTINUE
         NSIZE=IOFF
C
         MSIZE4=MAX(MSIZE3,MAXDIS)
         MSIZE=MAX(MSIZE,MSIZE2+MSIZE3+MSIZE4)
C
C ALLOCATE ADDITIONAL MEMORY
C
         I050=I040+NSIZE*IINTFP
         IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
         NLEFT=.FALSE.
C
         IF(IEND.LT.MXCOR) GO TO 8030 
8025     CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
         CALL IZERO(NEND,NIRREP)
         NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
         MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I040+1
         MEM=MEMLEFT/IINTFP
         IF(MEM.LT.0) CALL INSMEM('AOGTRN7B',MEM,MXCOR)
         NUMTOT=0
         DO 8028 IRREP1=1,NIRREP
          NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
          IF(NUMLEFT.EQ.0) THEN
           NEND(IRREP1)=NSTART(IRREP1)-1
          ELSE
           IF(ISIZE3(IRREP1).NE.0) THEN
            NUMTREAT=MEM/ISIZE3(IRREP1)
           ELSE
            NUMTREAT=MEM
           ENDIF
           IF(NUMTREAT.LT.NUMLEFT) THEN
            NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
            NUMTOT=NUMTOT+NUMTREAT
            GO TO 8029
           ELSE
            NEND(IRREP1)=POP(IRREP1,1)
            MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
            NUMTOT=NUMTOT+POP(IRREP1,1)
           ENDIF
          ENDIF
8028     CONTINUE
         NLEFT=.FALSE.
8029     CONTINUE
C
         IF(NLEFT.AND.NUMTOT.EQ.0)
     &          CALL INSMEM('AOGTRN8',IEND,MXCOR)
C
         NSIZE=0
         DO 8040 IRREP1=1,NIRREP
          IOFFI(IRREP1)=NSIZE
          NSIZE=NSIZE+ISIZE3(IRREP1)*(NEND(IRREP1)-NSTART(IRREP1)+1)
8040     CONTINUE
C
C ALLOCATE ADDITIONAL MEMORY
C
         I050=I040+NSIZE*IINTFP
         IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
         IF(IEND.GE.MXCOR) CALL INSMEM('AOGTRN8',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
8030     CONTINUE
C
         CALL LOADA8(ICORE(I000),ICORE(I040),ICORE(I050),
     &                ICORE(I020),ICORE(I030),ICORE(I010),
     &                AOPOP,NSTART,NEND,ISIZE3,IOFFAO,IOFFI,
     &                ISIZET,NSIZE,ILNBUF,IRREPX,IPERT,1)
         CALL DINTRN8(ICORE(I000),ICORE(I040),ICORE(I050),RHF,
     &                 NSTART,NEND,IRREPX,1)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
         IF(NLEFT) THEN
          DO 8060 IRREP1=1,NIRREP
           NSTART(IRREP1)=NEND(IRREP1)+1
8060      CONTINUE
          GO TO 8025
         ENDIF
C
C TRANSFORM JKII INTEGRALS
C ALLOCATE MEMORY AND GET INDEXING ARRAYS
C
         CALL IZERO(ISIZE3,8)
         CALL IZERO(ISIZET,64)
         CALL IZERO(IOFFI,8)
C
         DO 9001 IRREP=1,NIRREP
          NSTART(IRREP)=1
          NEND(IRREP)=POP(IRREP,1)
9001     CONTINUE
C
         NSIZE=0
         MSIZE=0
         MSIZE2=0
         MSIZE3=0 
         IOFF=0
C
         DO 9010 IRREP1=1,NIRREP
C
          IRREP2=DIRPRD(IRREP1,IRREPX)
          IOFFI(IRREP1)=IOFF
          IOFF1=0
          MSIZE1=0
C
          DO 9011 IRREP3=1,NIRREP
           IF(IRREP3.NE.IRREP1.AND.IRREP3.NE.IRREP2) THEN
            ISIZE3(IRREP1)=ISIZE3(IRREP1)+AOPOP(IRREP2)*          
     &                     AOPOP(IRREP3)*AOPOP(IRREP3)
            MSIZE1=MSIZE1+AOPOP(IRREP2)*AOPOP(IRREP3)*
     &                     AOPOP(IRREP3)
            MSIZE2=MAX(MSIZE2,AOPOP(IRREP2)*AOPOP(IRREP3)*AOPOP(IRREP3))
            MSIZE3=MAX(MSIZE3,2*AOPOP(IRREP1)*AOPOP(IRREP3))
            ISIZET(IRREP1,IRREP3)=IOFF1
            IOFF1=IOFF1+AOPOP(IRREP3)*AOPOP(IRREP3)
           ENDIF
9011      CONTINUE
          MSIZE=MAX(MSIZE,MSIZE1)
          MSIZE3=MAX(MSIZE3,2*AOPOP(IRREP1)*AOPOP(IRREP1))
          IOFF=IOFF+ISIZE3(IRREP1)*POP(IRREP1,1)
9010     CONTINUE
         NSIZE=IOFF
C
         MSIZE4=MAX(MAXDIS,MSIZE3)
         MSIZE=MAX(MSIZE,MSIZE2+MSIZE3+MSIZE4)
C
C ALLOCATE ADDITIONAL MEMORY
C
         I050=I040+NSIZE*IINTFP
         IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
         NLEFT=.FALSE.
C
         IF(IEND.LT.MXCOR) GO TO 9030 
9025     CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS
C
         CALL IZERO(NEND,NIRREP)
         NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
         MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I040+1
         MEM=MEMLEFT/IINTFP
         IF(MEM.LT.0) CALL INSMEM('AOGTRN7B',MEM,MXCOR)
         NUMTOT=0
         DO 9028 IRREP1=1,NIRREP
          NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
          IF(NUMLEFT.EQ.0) THEN
           NEND(IRREP1)=NSTART(IRREP1)-1
          ELSE
           IF(ISIZE3(IRREP1).NE.0) THEN
            NUMTREAT=MEM/ISIZE3(IRREP1)
           ELSE
            NUMTREAT=MEM
           ENDIF
           IF(NUMTREAT.LT.NUMLEFT) THEN
            NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
            NUMTOT=NUMTOT+NUMTREAT
            GO TO 9029
           ELSE
            NEND(IRREP1)=POP(IRREP1,1)
            MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
            NUMTOT=NUMTOT+POP(IRREP1,1)
           ENDIF
          ENDIF
9028     CONTINUE
         NLEFT=.FALSE.
9029     CONTINUE
C
         IF(NLEFT.AND.NUMTOT.EQ.0)
     &          CALL INSMEM('AOGTRN9',IEND,MXCOR)
C
         NSIZE=0
         DO 9040 IRREP1=1,NIRREP
          IOFFI(IRREP1)=NSIZE
          NSIZE=NSIZE+ISIZE3(IRREP1)*(NEND(IRREP1)-NSTART(IRREP1)+1)
9040     CONTINUE
C
C ALLOCATE ADDITIONAL MEMORY
C
         I050=I040+NSIZE*IINTFP
         IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
         IF(IEND.GE.MXCOR) CALL INSMEM('AOGTRN9',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
9030     CONTINUE
C
         CALL LOADA9(ICORE(I000),ICORE(I040),ICORE(I050),
     &               ICORE(I020),ICORE(I030),ICORE(I010),
     &               AOPOP,NSTART,NEND,ISIZE3,IOFFAO,IOFFI,
     &               ISIZET,NSIZE,ILNBUF,IRREPX,IPERT,1)
         CALL DINTRN9(ICORE(I000),ICORE(I040),ICORE(I050),RHF,
     &                NSTART,NEND,IRREPX,1)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
         IF(NLEFT) THEN
          DO 9060 IRREP1=1,NIRREP
           NSTART(IRREP1)=NEND(IRREP1)+1
9060      CONTINUE
          GO TO 9025
         ENDIF
C
         IF(NPASSL.EQ.1) THEN
          WRITE(6,20111) NPASSL
         ELSE IF(NPASSL.LE.9) THEN
          WRITE(6,20121) NPASSL
         ELSE 
          WRITE(6,20131) NPASSL
         ENDIF
         WRITE(6,20102) NREADL,NAMXYZ(2,IXYZ)
         WRITE(6,20103) TIMEL
         WRITE(6,20104) TIMEI  
         WRITE(6,20105) NWRITI
         CALL GFNAME(NAMXYZ(2,IXYZ),FNAME,ILENGTH)
         OPEN(UNIT=99,FILE=FNAME(1:ILENGTH))
         CLOSE(UNIT=99,STATUS='DELETE')
C
C ALLOCATE ADDITIONAL MEMORY
C
C    TRANSFORM IJIK INTEGRALS
C
         WRITE(6,20100) NAMXYZ(3,IXYZ)
C
         NREADL=0
         NPASSL=0
         NWRITI=0
         TIMEL=ZERO
         TIMEI=ZERO
         CALL IZERO(IOFFW,64)
C
         DO 10001 IRREP=1,NIRREP
          NSTART(IRREP)=1
          NEND(IRREP)=POP(IRREP,1)
10001    CONTINUE
C
C TRY FIRST ALLOCATION FOR FULL IN-CORE
C
         NSIZE=0
         MSIZE=0
         MSIZE1=0
         IOFF=0
         DO 10010 IRREP1=1,NIRREP
          DO 10020 IRREP2=1,NIRREP
           IOFFW(IRREP1,IRREP2)=IOFF
           IRREP3=DIRPRD(IRREP2,IRREPX)
           IF(IRREP3.EQ.IRREP1.OR.IRREP2.EQ.IRREP1) GO TO 10020
           ISIZ3=AOPOP(IRREP3)*AOPOP(IRREP2)*AOPOP(IRREP1)
           MSIZE=MAX(MSIZE,ISIZ3)
           MSIZE1=MAX(MSIZE1,2*AOPOP(IRREP1)*AOPOP(IRREP2))
           IOFF=IOFF+2*ISIZ3*POP(IRREP1,1)
10020     CONTINUE
10010    CONTINUE
         MSIZE2=MAX(MSIZE1,MAXDIS)
         NSIZE=IOFF
         MSIZE=MSIZE+MSIZE1+MSIZE2
C
C ALLOCATE ADDITIONAL MEMORY
C
         I050=I040+NSIZE*IINTFP
         IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
         NLEFT=.FALSE.
         IF(IEND.LT.MXCOR) GO TO 10030
C
C OUT-OF-CORE ALGORITHM REQUIRED
C
10025    CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS 
C
          CALL IZERO(NEND,NIRREP)
          NLEFT=.TRUE.
C
C DETERMINE TOTAL AMOUNT OF MEMORY REQUIRED FOR EACH IRREP
C
          DO 10026 IRREP1=1,NIRREP
           ISIZE=0
           DO 10027 IRREP2=1,NIRREP
            IRREP3=DIRPRD(IRREP2,IRREPX)
            IF(IRREP1.NE.IRREP3.AND.IRREP1.NE.IRREP2) THEN
             ISIZE=ISIZE+AOPOP(IRREP2)*AOPOP(IRREP3)
            ENDIF
10027      CONTINUE
           ITOTAL(IRREP1)=2*ISIZE*AOPOP(IRREP1)
10026     CONTINUE
C
C DETERMINE NSTART AND NEND
C
          MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I040+1
          MEM=MEMLEFT/IINTFP
          IF(MEM.LT.0) CALL INSMEM('AOGTRN11B',MEM,MXCOR)
          NUMTOT=0
          DO 10028 IRREP1=1,NIRREP         
           NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
           IF(NUMLEFT.EQ.0) THEN
            NEND(IRREP1)=NSTART(IRREP1)-1
           ELSE
            IF(ITOTAL(IRREP1).NE.0) THEN
             NUMTREAT=MEM/ITOTAL(IRREP1)
            ELSE
             NUMTREAT=MEM
            ENDIF
            IF(NUMTREAT.LT.NUMLEFT) THEN
             NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
             NUMTOT=NUMTOT+NUMTREAT
             GO TO 10029
            ELSE
             NEND(IRREP1)=POP(IRREP1,1)
             MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ITOTAL(IRREP1)
             NUMTOT=NUMTOT+POP(IRREP1,1)
            ENDIF
           ENDIF
10028     CONTINUE
          NLEFT=.FALSE.
10029     CONTINUE
C
          IF(NLEFT.AND.NUMTOT.EQ.0)
     &              CALL INSMEM('AOGTRN10',IEND,MXCOR)
C
C GET POINTERS FOR ADRESS
C
          IOFF=0
          DO 10040 IRREP1=1,NIRREP
           DO 10050 IRREP2=1,NIRREP
            IOFFW(IRREP1,IRREP2)=IOFF
            IRREP3=DIRPRD(IRREP2,IRREPX)
            IF(IRREP3.EQ.IRREP1.OR.IRREP2.EQ.IRREP1) GO TO 10050
            ISIZ3=AOPOP(IRREP3)*AOPOP(IRREP2)*AOPOP(IRREP1)
            IOFF=IOFF+2*ISIZ3*(NEND(IRREP1)-NSTART(IRREP1)+1)
10050      CONTINUE
10040     CONTINUE
          NSIZE=IOFF
C
C ALLOCATE ADDITIONAL MEMORY
C
          I050=I040+NSIZE*IINTFP
          IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
          IF(IEND.GE.MXCOR) CALL INSMEM('AOGTRN10A',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
10030     CONTINUE
C
          CALL LOADA10(ICORE(I000),ICORE(I040),ICORE(I050),
     &                 ICORE(I020),ICORE(I030),ICORE(I010),
     &                 AOPOP,NSTART,NEND,IOFFAO,IOFFW,
     &                 NSIZE,ILNBUF,IRREPX,IPERT,1)
          CALL DINTRN10(ICORE(I000),ICORE(I040),ICORE(I050),RHF,
     &                  NSTART,NEND,IRREPX,1)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
          IF(NLEFT) THEN
           DO 10060 IRREP1=1,NIRREP
            NSTART(IRREP1)=NEND(IRREP1)+1
10060      CONTINUE
           GO TO 10025
          ENDIF
C
C ALLOCATE ADDITIONAL MEMORY
C
          CALL IZERO(IOFFW,64)
C
          DO 11001 IRREP=1,NIRREP
           NSTART(IRREP)=1
           NEND(IRREP)=POP(IRREP,1)
11001     CONTINUE
C
          NSIZE=0
          MSIZE=0
          MSIZE1=0
          IOFF=0
          DO 11010 IRREP1=1,NIRREP
           IRREP3=DIRPRD(IRREP1,IRREPX)
           DO 11020 IRREP2=1,NIRREP
            IOFFW(IRREP1,IRREP2)=IOFF
            IF(IRREP3.EQ.IRREP2.OR.IRREP1.EQ.IRREP2) GO TO 11020
            ISIZ3=AOPOP(IRREP2)*AOPOP(IRREP2)*AOPOP(IRREP3)
            MSIZE=MAX(MSIZE,ISIZ3)
            MSIZE1=MAX(MSIZE1,AOPOP(IRREP1)*AOPOP(IRREP2),
     &                        AOPOP(IRREP1)*AOPOP(IRREP1))
            IOFF=IOFF+2*ISIZ3*POP(IRREP1,1)
11020      CONTINUE
11010     CONTINUE
          NSIZE=IOFF
          MSIZE2=MAX(MSIZE1,MAXDIS)
          NSIZE=IOFF
          MSIZE=MSIZE+MSIZE1+MSIZE2
C
C ALLOCATE ADDITIONAL MEMORY
C
          I050=I040+NSIZE*IINTFP
          IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
C
          NLEFT=.FALSE.
          IF(IEND.LT.MXCOR) GO TO 11030
C
C OUT-OF-CORE ALGORITHM REQUIRED
C
11025     CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS 
C
           CALL IZERO(NEND,NIRREP)
           NLEFT=.TRUE.
C
C DETERMINE TOTAL AMOUNT OF MEMORY REQUIRED FOR EACH IRREP
C
           DO 11026 IRREP1=1,NIRREP
            ISIZE=0
            IRREP3=DIRPRD(IRREP1,IRREPX)
            DO 11027 IRREP2=1,NIRREP
             IF(IRREP2.NE.IRREP3.AND.IRREP1.NE.IRREP2) THEN
              ISIZE=ISIZE+2*AOPOP(IRREP2)*AOPOP(IRREP2)*AOPOP(IRREP3)
             ENDIF
11027       CONTINUE
            ITOTAL(IRREP1)=ISIZE
11026      CONTINUE
C
C DETERMINE NSTART AND NEND
C
           MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I040+1
           MEM=MEMLEFT/IINTFP
           IF(MEM.LT.0) CALL INSMEM('AOGTRN11B',MEM,MXCOR)
           NUMTOT=0
           DO 11028 IRREP1=1,NIRREP         
            NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
            IF(NUMLEFT.EQ.0) THEN
             NEND(IRREP1)=NSTART(IRREP1)-1
            ELSE
             IF(ITOTAL(IRREP1).NE.0) THEN
              NUMTREAT=MEM/ITOTAL(IRREP1)
             ELSE
              NUMTREAT=MEM
             ENDIF
             IF(NUMTREAT.LT.NUMLEFT) THEN
              NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
              NUMTOT=NUMTOT+NUMTREAT
              GO TO 11029
             ELSE
              NEND(IRREP1)=POP(IRREP1,1)
              MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ITOTAL(IRREP1)
              NUMTOT=NUMTOT+POP(IRREP1,1)
             ENDIF
            ENDIF
11028      CONTINUE
           NLEFT=.FALSE.
11029      CONTINUE
C
           IF(NLEFT.AND.NUMTOT.EQ.0)
     &               CALL INSMEM('AOGTRN11',IEND,MXCOR)
C
C GET POINTERS FOR ADRESS
C
           IOFF=0
           DO 11040 IRREP1=1,NIRREP
            IRREP3=DIRPRD(IRREP1,IRREPX)
            DO 11050 IRREP2=1,NIRREP
             IOFFW(IRREP1,IRREP2)=IOFF
             IF(IRREP3.EQ.IRREP2.OR.IRREP2.EQ.IRREP1) GO TO 11050
             ISIZ3=AOPOP(IRREP3)*AOPOP(IRREP2)*AOPOP(IRREP2)
             IOFF=IOFF+2*ISIZ3*(NEND(IRREP1)-NSTART(IRREP1)+1)
11050       CONTINUE
11040      CONTINUE
           NSIZE=IOFF
C
C ALLOCATE ADDITIONAL MEMORY
C
          I050=I040+NSIZE*IINTFP
          IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
          IF(IEND.GE.MXCOR) CALL INSMEM('AOGTRN11A',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
11030     CONTINUE
C
C
          CALL LOADA11(ICORE(I000),ICORE(I040),ICORE(I050),
     &                 ICORE(I020),ICORE(I030),ICORE(I010),
     &                 AOPOP,NSTART,NEND,IOFFAO,IOFFW,
     &                 NSIZE,ILNBUF,IRREPX,IPERT,1)
          CALL DINTRN11(ICORE(I000),ICORE(I040),ICORE(I050),RHF,
     &                  NSTART,NEND,IRREPX,1)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
          IF(NLEFT) THEN
           DO 11060 IRREP1=1,NIRREP
            NSTART(IRREP1)=NEND(IRREP1)+1
11060      CONTINUE
           GO TO 11025
          ENDIF
C
          IF(NPASSL.EQ.1) THEN
           WRITE(6,20111) NPASSL
          ELSE IF(NPASSL.LE.9) THEN
           WRITE(6,20121) NPASSL
          ELSE 
           WRITE(6,20131) NPASSL
          ENDIF
          WRITE(6,20102) NREADL,NAMXYZ(3,IXYZ)
          WRITE(6,20103) TIMEL
          WRITE(6,20104) TIMEI  
          WRITE(6,20105) NWRITI
          CALL GFNAME(NAMXYZ(3,IXYZ),FNAME,ILENGTH)
          OPEN(UNIT=99,FILE=FNAME(1:ILENGTH))
          CLOSE(UNIT=99,STATUS='DELETE')
C
          IF(NIRREP.GT.4) THEN
C
C ONLY FOR D2H SYMMETRY REQUIRED
C
C
           WRITE(6,20100) NAMXYZ(4,IXYZ)
C
           NREADL=0
           NPASSL=0
           NWRITI=0
           TIMEL=ZERO
           TIMEI=ZERO
C
           CALL IZERO(IOFFW,64)
           CALL IZERO(ISIZE33,512)
           CALL IZERO(ISIZE3,8)
           CALL IZERO(ISIZET,64)
C
          DO 12001 IRREP=1,NIRREP
           NSTART(IRREP)=1
           NEND(IRREP)=POP(IRREP,1)
12001     CONTINUE
C
           NSIZE=0
           MSIZE=0
           IOFF=0
           DO 12010 IRREP1=1,NIRREP
            DO 12020 IRREP2=1,NIRREP
             IOFFW(IRREP1,IRREP2)=IOFF
             IRREP12=DIRPRD(IRREP1,IRREP2)
             IF(IRREP12.EQ.1) GO TO 12020
             IOFF2=0
             DO 12030 IRREP3=1,NIRREP
              IF(IRREP3.EQ.IRREP1.OR.IRREP3.EQ.IRREP2) GO TO 12030
              IRREP4=DIRPRD(IRREPX,DIRPRD(IRREP3,IRREP12))
              IF(IRREP4.EQ.IRREP1.OR.IRREP4.EQ.IRREP2
     &           .OR.IRREP4.EQ.IRREP3) GO TO 12030
              ISIZ3=AOPOP(IRREP2)*AOPOP(IRREP3)*AOPOP(IRREP4)
              ISIZE33(IRREP1,IRREP3,IRREP4)=IOFF2
              MSIZE=MAX(MSIZE,ISIZ3)
              IOFF2=IOFF2+AOPOP(IRREP3)*AOPOP(IRREP4)
              IOFF=IOFF+ISIZ3*POP(IRREP1,1)
              ISIZE3(IRREP1)=ISIZE3(IRREP1)+ISIZ3
12030        CONTINUE
             ISIZET(IRREP1,IRREP2)=IOFF2*AOPOP(IRREP2)
12020       CONTINUE
12010     CONTINUE
          NSIZE=IOFF
C
C ALLOCATE ADDITIONAL MEMORY
C
          I050=I040+NSIZE*IINTFP
          IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
          NLEFT=.FALSE.
          IF(IEND.LT.MXCOR) GO TO 12031
C
C OUT-OF-CORE ALGORITHM REQUIRED
C
12025     CONTINUE
C
C SET FIRST NLEFT TO TRUE, A FLAG WHICH TELLS TO DO ANOTHER PASS 
C
           CALL IZERO(NEND,NIRREP)
           NLEFT=.TRUE.
C
C DETERMINE NSTART AND NEND
C
           MEMLEFT=MXCOR-MAX(NOCCO(1),MSIZE)*IINTFP-I040+1
           MEM=MEMLEFT/IINTFP
           IF(MEM.LT.0) CALL INSMEM('AOGTRN12B',MEM,MXCOR)
           NUMTOT=0
           DO 12028 IRREP1=1,NIRREP         
            NUMLEFT=POP(IRREP1,1)-NSTART(IRREP1)+1
            IF(NUMLEFT.EQ.0) THEN
             NEND(IRREP1)=NSTART(IRREP1)-1
            ELSE
             IF(ISIZE3(IRREP1).NE.0) THEN
              NUMTREAT=MEM/ISIZE3(IRREP1)
             ELSE
              NUMTREAT=MEM
             ENDIF
             IF(NUMTREAT.LT.NUMLEFT) THEN
              NEND(IRREP1)=NSTART(IRREP1)+NUMTREAT-1
              NUMTOT=NUMTOT+NUMTREAT
              GO TO 12029
             ELSE
              NEND(IRREP1)=POP(IRREP1,1)
              MEM=MEM-(NEND(IRREP1)-NSTART(IRREP1)+1)*ISIZE3(IRREP1)
              NUMTOT=NUMTOT+POP(IRREP1,1)
             ENDIF
            ENDIF
12028      CONTINUE
           NLEFT=.FALSE.
12029      CONTINUE
C
           IF(NLEFT.AND.NUMTOT.EQ.0)
     &               CALL INSMEM('AOGTRN12',IEND,MXCOR)
C
C GET POINTERS FOR ADRESS
C
           IOFF=0
           DO 12040 IRREP1=1,NIRREP
            DO 12050 IRREP2=1,NIRREP
             IOFFW(IRREP1,IRREP2)=IOFF
             IRREP12=DIRPRD(IRREP1,IRREP2)
             IF(IRREP12.EQ.1) GO TO 12050
             IOFF2=0
             DO 12060 IRREP3=1,NIRREP
              IF(IRREP3.EQ.IRREP1.OR.IRREP3.EQ.IRREP2) GO TO 12060
              IRREP4=DIRPRD(IRREPX,DIRPRD(IRREP3,IRREP12))
              IF(IRREP4.EQ.IRREP1.OR.IRREP4.EQ.IRREP2
     &           .OR.IRREP4.EQ.IRREP3) GO TO 12060
              ISIZ3=AOPOP(IRREP2)*AOPOP(IRREP3)*AOPOP(IRREP4)
              IOFF=IOFF+ISIZ3*(NEND(IRREP1)-NSTART(IRREP1)+1)
12060        CONTINUE
12050       CONTINUE
12040     CONTINUE
C
C ALLOCATE ADDITIONAL MEMORY
C
          NSIZE=IOFF
          I050=I040+NSIZE*IINTFP
          IEND=I050+MAX(NOCCO(1),MSIZE)*IINTFP
          IF(IEND.GE.MXCOR) CALL INSMEM('AOGTRN12A',IEND,MXCOR)
C
C REENTRY POINT FOR IN-CORE
C
12031    CONTINUE
C
          CALL LOADA12(ICORE(I000),ICORE(I040),ICORE(I050),
     &                 ICORE(I020),ICORE(I030),ICORE(I010),
     &                 AOPOP,NSTART,NEND,IOFFAO,IOFFW,ISIZET,
     &                 ISIZE33,NSIZE,ILNBUF,IRREPX,IPERT,1)
          CALL DINTRN12(ICORE(I000),ICORE(I040),ICORE(I050),RHF,
     &                  NSTART,NEND,IRREPX,1)
C
C CHECK IF A SECOND PASS IS REQUIRED
C
         IF(NLEFT) THEN
          DO 12080 IRREP1=1,NIRREP
           NSTART(IRREP1)=NEND(IRREP1)+1
12080      CONTINUE
          GO TO 12025
         ENDIF
C
         IF(NPASSL.EQ.1) THEN
          WRITE(6,20111) NPASSL
         ELSE IF(NPASSL.LE.9) THEN
          WRITE(6,20121) NPASSL
         ELSE 
          WRITE(6,20131) NPASSL
         ENDIF
         WRITE(6,20102) NREADL,NAMXYZ(4,IXYZ)
         WRITE(6,20103) TIMEL
         WRITE(6,20104) TIMEI  
         WRITE(6,20105) NWRITI
         CALL GFNAME(NAMXYZ(4,IXYZ),FNAME,ILENGTH)
         OPEN(UNIT=99,FILE=FNAME(1:ILENGTH))
         CLOSE(UNIT=99,STATUS='DELETE')
C
C
        ENDIF
       ENDIF
C  
      ENDIF
C
      CALL TIMER(1)
      write(6,25000) TIMENEW
25000 FORMAT(' Transformation completed in ',f6.1,
     &       ' seconds.')
      RETURN
      END
