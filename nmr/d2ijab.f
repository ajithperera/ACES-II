      SUBROUTINE D2IJAB(UAIA,UAIB,SIJA,SIJB,UIAA,UIAB,SABA,
     &                  SABB,ICORE,MXCOR,IRREPX,IPERT,IUHF,
     &                  STERM,ANTI,GRAD1)
C
C  THIS ROUTINE CALCULATES THE DERIVATIVE INTEGRALS d <IJ//AB> / d chi.
C
C  THERE ARE EIGHT DIFFERENT TERMS.
C
CEND
C
C CODED JAN/91  JG
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DIRPRD,DISSYW,DISSYD,POP,VRT
      LOGICAL STERM,ANTI
C
      DIMENSION ICORE(MXCOR) 
      DIMENSION UAIA(1),UAIB(1),UIAA(1),UIAB(1)
      DIMENSION SIJA(1),SIJB(1),SABA(1),SABB(1)
C
      COMMON/OFFSETS/IOFFU(8,2),IOFFS1(8,2),IOFFS2(8,2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREPAA(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),NJUNK(18)
      COMMON /TIMEINFO/ TIMEIN, TIMENOW, TIMETOT, TIMENEW 
C
      DATA AZERO,ONE /0.D0,1.D0/
C
      CALL TIMER(1)
C
C  INCORE ALGORITHM
C
C  DO HERE ALPHA,BETA SPIN CASE
C
C  LOOP OVER ALL IRREPS OF THE DERIVATIVE INTEGRALS
C
      DO 1000 IRREPR=1,NIRREP
C
C  THE IRREP ON THE LEFT SIDE IS THEN GIVEN AS THE DIRECT PRODUCT
C   OF IRREPP AND IRREPR
C
       IRREPL=DIRPRD(IRREPR,IRREPX)
C
C DETERMINE LENGTH OF TARGET ARRAY
C
       NUMSYD=IRPDPD(IRREPR,ISYTYP(2,16))
       DISSYD=IRPDPD(IRREPL,ISYTYP(1,16))
C
C ALLOCATE CORE FOR TARGET ARRAY
C
       ID=1
       IREST=ID+IINTFP*NUMSYD*DISSYD
       IF(IREST.GE.MXCOR) CALL INSMEM('D2ABIJ1',IREST,MXCOR)
C
C  ZERO TARGET LIST
C
       CALL ZERO(ICORE(ID),NUMSYD*DISSYD)
C
C CONSIDER FIRST ALL TERMS WHICH INCLUDE U(IA)
C
C    <IJ//KB> U(KA) + <IJ//AK> U(KB)
C
C  THE IRREP ON THE RIGHT SIDE IS UNCHANGED, SO IRREPR DETERMINES
C  THE LISTS OF ORIGINAL ZEROTH ORDER INTEGRALS
C
       LISTW=10
       NUMSYW=IRPDPD(IRREPR,ISYTYP(2,LISTW))
       DISSYW=IRPDPD(IRREPR,ISYTYP(1,LISTW))
C
C  ALLOCATE CORE MEMORY
C
       IW=IREST
       ITMP=IW+IINTFP*NUMSYW*DISSYW
       IEND=ITMP+3*IINTFP*MAX(NUMSYW,DISSYW,NUMSYD,DISSYD)
C
       IF(IEND.GE.MXCOR) CALL INSMEM('D2IJAB2',IEND,MXCOR)
C
C  READ IN THE <Ij//Mb> AS <Ij//Mb>
C
        CALL GETLST(ICORE(IW),1,NUMSYW,1,IRREPR,LISTW)
C
C  TRANSPOSE THE LAST TWO INDICES :   Ij;Mb ---> Ij;bM
C
        CALL SYMTR1(IRREPR,POP(1,1),VRT(1,2),DISSYW,ICORE(IW),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYW),
     &              ICORE(ITMP+2*IINTFP*DISSYW))
C
C  (Ij;bA)(R,L) <---- (Ij;bM)(R,R) (A,M) (X)
C
        CALL DFINDT(ICORE(ID),ICORE(IW),UIAA,NUMSYD,DISSYD,
     &              DISSYW,NUMSYW,VRT(1,2),POP(1,1),VRT(1,1),
     &              IRREPR,IRREPL,IRREPX,IOFFU(1,1),2)
C
C  TRANSPOSE THE TARGET LIST    Ij;bA --> Ij,Ab
C
        CALL SYMTR1(IRREPL,VRT(1,2),VRT(1,1),NUMSYD,ICORE(ID),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYD),
     &              ICORE(ITMP+2*IINTFP*NUMSYD))
C
C  NOW DO <Ij//Am> U(m,b) , BUT ONLY FOR UHF
C
        IF(IUHF.EQ.1) THEN
C
         LISTW=9
         NUMSYW=IRPDPD(IRREPR,ISYTYP(2,LISTW))
         DISSYW=IRPDPD(IRREPR,ISYTYP(1,LISTW))
C
C  ALLOCATE CORE MEMORY
C
         IW=IREST
         ITMP=IW+IINTFP*NUMSYW*DISSYW
         IEND=ITMP+3*IINTFP*MAX(NUMSYW,DISSYW,DISSYD,NUMSYD)
C
         IF(IEND.GE.MXCOR) CALL INSMEM('D2ABIJ3',IEND,MXCOR)
C
C  READ IN THE <Ij//Am>
C
         CALL GETLST(ICORE(IW),1,NUMSYW,1,IRREPR,LISTW)
C
C  (Ij;Ab) (R,L) <----- (Ij;Am) (R,R) (b,m) (X)
C
         CALL DFINDT(ICORE(ID),ICORE(IW),UIAB,NUMSYD,DISSYD,
     &               DISSYW,NUMSYW,VRT(1,1),POP(1,2),VRT(1,2),
     &               IRREPR,IRREPL,IRREPX,IOFFU(1,2),2)
        ENDIF 
C
        IF(STERM) THEN
C
C  TRANSPOSE THE TARGET LIST    Ij;Ab --> Ij,bA
C
         ITMP=IREST
         IEND=ITMP+3*IINTFP*MAX(NUMSYD,DISSYD)
C
         IF(IEND.GE.MXCOR) CALL INSMEM('D2ABIJ4',IEND,MXCOR)
C
         CALL SYMTR1(IRREPL,VRT(1,1),VRT(1,2),NUMSYD,ICORE(ID),
     &               ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYD),
     &               ICORE(ITMP+2*IINTFP*NUMSYD))
C
C CONSIDER FIRST ALL TERMS WHICH INCLUDE S(AE)
C
C    <IJ//EB> (-1/2 S(AE))
C
C  THE IRREP ON THE RIGHT SIDE IS UNCHANGED, SO IRREPR DETERMINES
C  THE LISTS OF ORIGINAL ZEROTH ORDER INTEGRALS
C
         LISTW=16
         NUMSYW=IRPDPD(IRREPR,ISYTYP(2,LISTW))
         DISSYW=IRPDPD(IRREPR,ISYTYP(1,LISTW))
C
C  ALLOCATE CORE MEMORY
C
         IW=IREST
         IW2=IW+IINTFP*NUMSYW*DISSYW
         ITMP=IW2
         IEND=IW2+MAX(3*IINTFP*MAX(NUMSYW,NUMSYD,DISSYW,DISSYD),
     &                         IINTFP*NUMSYW*DISSYW)
C
         IF(IEND.GE.MXCOR) THEN
C
C IF THERE IS NOT ENOUGH MEMORY, READ DIRECTLY THE TRANSPOSED INTEGRAL LIST
C
          IEND=ITMP+3*IINTFP*MAX(NUMSYW,NUMSYD,DISSYW,DISSYD)
          IF(IEND.GE.MXCOR) CALL INSMEM('D2ABIJ5',IEND,MXCOR)
          CALL GETTRN(ICORE(IW),ICORE(ITMP),DISSYW,NUMSYW,1,
     &                IRREPR,LISTW)
C
         ELSE
C
C  READ IN THE <Ij//Eb> AS <Ij//Eb>
C
          CALL GETLST(ICORE(IW2),1,NUMSYW,1,IRREPR,LISTW)
C
C  TRANSPOSE <Ij//Eb>    (Eb;Ij) --> (Ij;Eb)
C
          CALL TRANSP(ICORE(IW2),ICORE(IW),NUMSYW,DISSYW)
C
         ENDIF
C
C  TRANSPOSE THE LAST TWO INDICES :   Ij;Eb ---> Ij;bE
C
         CALL SYMTR1(IRREPR,VRT(1,1),VRT(1,2),NUMSYW,ICORE(IW),
     &               ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYW),
     &               ICORE(ITMP+2*IINTFP*NUMSYW))
C
C  (Ij;bA) (R,L) <----- (Ij;bE) (R,R) (E,A) (X)
C
         CALL DFINDT(ICORE(ID),ICORE(IW),SABA,NUMSYD,DISSYD,
     &               NUMSYW,DISSYW,VRT(1,2),VRT(1,1),VRT(1,1),
     &               IRREPR,IRREPL,IRREPX,IOFFS2(1,1),1)
C
C  TRANSPOSE THE TARGET LIST    Ij;bA --> Ij,Ab
C
         CALL SYMTR1(IRREPL,VRT(1,2),VRT(1,1),NUMSYD,ICORE(ID),
     &               ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYD),
     &               ICORE(ITMP+2*IINTFP*NUMSYD))
C
         IF(IUHF.EQ.1) THEN
C
C  TRANSPOSE THE INTEGRAL LIST
C
          CALL SYMTR1(IRREPR,VRT(1,2),VRT(1,1),NUMSYW,ICORE(IW),
     &                ICORE(ITMP),ICORE(ITMP+IINTFP*NUMSYW),
     &                ICORE(ITMP+2*IINTFP*NUMSYW))
C
C  FOR UHF WE HAVE TO CALCULATE ACTUALLY THIS CONTRIBUTION
C
          CALL DFINDT(ICORE(ID),ICORE(IW),SABB,NUMSYD,DISSYD,
     &              NUMSYW,DISSYW,VRT(1,1),VRT(1,2),VRT(1,2),
     &              IRREPR,IRREPL,IRREPX,IOFFS2(1,2),1)
C
         ENDIF
        ENDIF 
C
C  TRANSPOSE TARGET LIST
C
        ID2=IREST
        IEND=ID2+IINTFP*NUMSYD*DISSYD
C
        IF(IEND.GE.MXCOR) CALL INSMEM('D2ABIJ6',IEND,MXCOR)
C
        CALL TRANSP(ICORE(ID),ICORE(ID2),DISSYD,NUMSYD)
c YAU : old
c       CALL ICOPY(IINTFP*NUMSYD*DISSYD,ICORE(ID2),1,ICORE(ID),1)
c YAU : new
        CALL DCOPY(NUMSYD*DISSYD,ICORE(ID2),1,ICORE(ID),1)
c YAU : end
        IF(ANTI) CALL VMINUS(ICORE(ID),NUMSYD*DISSYD)
C
C FOR GEOMETRICAL PERTURBATIONS, DEAL FIRST WITH THE S-TERMS
C
        IF(STERM) THEN
C
         LISTW=16
         NUMSYW=IRPDPD(IRREPL,ISYTYP(2,LISTW))
         DISSYW=IRPDPD(IRREPL,ISYTYP(1,LISTW))
C
         IW=IREST
         IEND=IW+IINTFP*NUMSYW*DISSYW
C
         IF(IEND.GE.MXCOR) CALL INSMEM('D2ABIJ7',IEND,MXCOR)
C
         CALL GETLST(ICORE(IW),1,NUMSYW,1,IRREPL,LISTW)
C
C   (Ab;Ij) (L,R) <----- (Ab;Im) (L,L) S(m,j) (X)
C
         CALL DFINDT(ICORE(ID),ICORE(IW),SIJB,DISSYD,NUMSYD,DISSYW,
     &               NUMSYW,POP(1,1),POP(1,2),POP(1,2),IRREPL,IRREPR,
     &               IRREPX,IOFFS1(1,2),1)
C
         ITMP=IEND
         IEND=ITMP+3*IINTFP*MAX(NUMSYD,NUMSYW,DISSYD,DISSYW)
C
         IF(IEND.GE.MXCOR) CALL INSMEM('D2ABIJ8',IEND,MXCOR)
C
         CALL SYMTR1(IRREPR,POP(1,1),POP(1,2),DISSYD,ICORE(ID),
     &               ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYD),
     &               ICORE(ITMP+2*IINTFP*DISSYD))
C
        IF(IUHF.EQ.1) THEN
C
         CALL SYMTR1(IRREPL,POP(1,1),POP(1,2),DISSYW,ICORE(IW),
     &               ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYW),
     &               ICORE(ITMP+2*IINTFP*DISSYW))
C
C   (Ab,jI) (L,R) <------ (Ab,jM) (L,L) S(M,I) (X)
C
         CALL DFINDT(ICORE(ID),ICORE(IW),SIJA,DISSYD,NUMSYD,DISSYW,
     &               NUMSYW,POP(1,2),POP(1,1),POP(1,1),IRREPL,
     &               IRREPR,IRREPX,IOFFS1(1,1),1)
        ENDIF
       ENDIF
C
       IF(.NOT.STERM) THEN
C
        ITMP=IEND
        IEND=ITMP+3*IINTFP*MAX(NUMSYD,NUMSYW,DISSYD,DISSYW)
C
        IF(IEND.GE.MXCOR) CALL INSMEM('D2ABIJ9',IEND,MXCOR)
C
        CALL SYMTR1(IRREPR,POP(1,1),POP(1,2),DISSYD,ICORE(ID),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYD),
     &              ICORE(ITMP+2*IINTFP*DISSYD))
       ENDIF
C
C NOW DEAL WITH THE RIGHT HAND SIDE
C
C  FIRST TERM    <Ab|Ej> U(E,I)
C
       LISTW=30
       DISSYW=IRPDPD(IRREPL,ISYTYP(1,LISTW))
       NUMSYW=IRPDPD(IRREPL,ISYTYP(2,LISTW))
C
C ALLOCATE MEMORY
C
       IW=IREST
       ITMP=IW+IINTFP*NUMSYW*DISSYW
       IEND=ITMP+3*IINTFP*MAX(NUMSYD,DISSYD,NUMSYW,DISSYW)
C
       IF(IEND.GT.MXCOR) THEN
C
C OUT-OF-CORE ALGORITHM
C
        ITMP=IREST
        IW=ITMP+3*IINTFP*MAX(NUMSYW,DISSYW,NUMSYD,DISSYD)
        MEM=MXCOR-IW
        NDIS=MEM/(IINTFP*DISSYW)
        IF(NDIS.LE.0) THEN
         write(*,*) ' @-D2IJAB-F, Out-of-core algorithm',
     &              ' not possible.'
         CALL ERREX
        ENDIF
C
C  TRANSPOSE THE TARGET LIST : Ab;jI --- Ab;Ij
C
        CALL SYMTR1(IRREPR,POP(1,2),POP(1,1),DISSYD,
     &              ICORE(ID),ICORE(ITMP),ICORE(ITMP+IINTFP
     &              *DISSYD),ICORE(ITMP+2*IINTFP*DISSYD))
C
        ISTART=1
        NLEFT=NUMSYW
910     NREAD=MIN(NDIS,NLEFT)
        NLEFT=NLEFT-NREAD
        IEND=ISTART+NREAD-1
C
        CALL GETLST(ICORE(IW),ISTART,NREAD,1,IRREPL,LISTW)
C
        CALL DFINDT3(ICORE(ID),ICORE(IW),UAIA,ISTART,IEND,
     &               DISSYD,NUMSYD,DISSYW,NREAD,POP(1,2),
     &               VRT(1,1),POP(1,1),IRREPL,IRREPR,
     &               IRREPX,IOFFU(1,1),1)
C
        ISTART=IEND+1
        IF(NLEFT.NE.0) GO TO 910
C
       ELSE
C
C IN-CORE ALGORITHM
C
C READ IN <Ab|Ej> INTEGRALS
C
        CALL GETLST(ICORE(IW),1,NUMSYW,1,IRREPL,LISTW)
C 
C TRANSPOSE LAST TWO INDICES
C
        CALL SYMTR1(IRREPL,VRT(1,1),POP(1,2),DISSYW,ICORE(IW),
     &              ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYW),
     &              ICORE(ITMP+2*IINTFP*DISSYW))
C
C  (Ab;jI) (L,R) <----- (Ab,jE) (L,L) (E,I) (X)
C
        CALL DFINDT(ICORE(ID),ICORE(IW),UAIA,DISSYD,NUMSYD,
     &              DISSYW,NUMSYW,POP(1,2),VRT(1,1),POP(1,1),
     &              IRREPL,IRREPR,IRREPX,IOFFU(1,1),1)
C
C  TRANSPOSE THE TARGET LIST : Ab;jI --- Ab;Ij
C
        CALL SYMTR1(IRREPR,POP(1,2),POP(1,1),DISSYD,
     &              ICORE(ID),ICORE(ITMP),ICORE(ITMP+IINTFP
     &              *DISSYD),ICORE(ITMP+2*IINTFP*DISSYD))
C
       ENDIF
C
C  NOW DO <Ab//Ie> U(e,j)
C
       IF(IUHF.EQ.1) THEN
C
C  FOR UHF WE HAVE TO CALCULATE ACTUALLY THIS CONTRIBUTION
C
        LISTW=29
        NUMSYW=IRPDPD(IRREPL,ISYTYP(2,LISTW))
        DISSYW=IRPDPD(IRREPL,ISYTYP(1,LISTW))
C
C  ALLOCATE MEMORY
C
        IW=IREST
        IEND=IW+IINTFP*NUMSYW*DISSYW
C
        IF(IEND.GT.MXCOR) CALL INSMEM('D2ABIJ11',IEND,MXCOR)
C
C  READ IN THE <Ab/Ie>
C
        CALL GETLST(ICORE(IW),1,NUMSYW,1,IRREPL,LISTW)
C
C  (Ab,Ij) (L,R) <----- (Ab,Ie) (L,L) (e,j) (X)
C
        CALL DFINDT(ICORE(ID),ICORE(IW),UAIB,DISSYD,NUMSYD,
     &              DISSYW,NUMSYW,POP(1,1),VRT(1,2),POP(1,2),
     &              IRREPL,IRREPR,IRREPX,IOFFU(1,2),1)
C
       ENDIF
C
C  FOR RHF, DO NOW ALL TRANSPOSITIONS
C
       IF(IUHF.EQ.0) THEN
C
        ITMP=IREST
C
        CALL DSYMRHF(IRREPL,IRREPR,VRT(1,1),POP(1,1),DISSYD,
     &               ICORE(ID),ICORE(ITMP),
     &               ICORE(ITMP+IINTFP*DISSYD),
     &               ICORE(ITMP+2*IINTFP*DISSYD))
C
       ENDIF
C
       call checksum('D2IJAB d',icore(Id),numsyd*dissyd)
C
C FOR GEOMETRICAL PERTURBATIONS, INCREMENT INTEGRAL DERIVATIVE LIST
C
       IF(STERM)THEN
        ID2=ID+NUMSYD*DISSYD*IINTFP
        IEND=ID2+NUMSYD*DISSYD*IINTFP
        IF(IEND.GT.MXCOR) CALL INSMEM('D2IJAB12',IEND,MXCOR) 
        CALL GETLST(ICORE(ID2),1,NUMSYD,
     &              1,IRREPR,316)
        CALL SAXPY(NUMSYD*DISSYD,ONE,ICORE(ID2),1,ICORE(ID),1)
        call checksum('D2IJAB t',icore(Id),numsyd*dissyd)
       ENDIF
       CALL PUTLST(ICORE(ID),1,NUMSYD,1,
     &             IRREPR,316)
C
C FOR DEBUGGING PURPOSE, CALCULATE CONTRIBUTION TO GRADIENT
C
c       IF(IRREPL.EQ.IRREPR) THEN
c        IW=ID+IINTFP*NUMSYD*DISSYD
c        IEND=IW+IINTFP*NUMSYD*DISSYD
c        IF(IEND.GT.MXCOR) CALL INSMEM('D2ABIJ10',IEND,MXCOR)
c        CALL GETLST(ICORE(IW),1,NUMSYD,1,IRREPR,46)
c        IF(IUHF.EQ.0) THEN
c         ITMP=IEND
c         CALL SPINAD1(IRREPR,POP(1,1),DISSYD,ICORE(IW), 
c     &                ICORE(ITMP),ICORE(ITMP+IINTFP*DISSYD))
c        ENDIF
c        GRAD1=GRAD1+SDOT(NUMSYD*DISSYD,ICORE(IW),1,ICORE(ID),1)
c        write(*,*) grad1,' grad1 after irrep ',irrepr,' for pert ',
c     &             ipert
c       ENDIF
1000  CONTINUE
C
C ALL DONE SO FAR, WRITE INFO MESSAGE, GET CPU-TIMINGS AND RETURN
C
      CALL TIMER(1)
     
      write(6,6000) TIMENEW
6000  FORMAT(' Integral derivatives d <ij||ab>/d',
     &           ' chi have been formed in ',f5.1,' seconds.')
C
      RETURN
C
      END
