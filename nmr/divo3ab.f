      SUBROUTINE DIVO3AB(G,W,MAXSIZE,DIVO,FACT,ISPIN,
     &                   POP1,POP2,VRT1,VRT2,DISSYG,NUMSYG,
     &                   DISSYW,NUMSYW,LISTG,LISTW,IRREPL,
     &                   IRREPR,TMP,IUHF)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYG,DISSYW,DISMAX,DISLEFT,DISREAD,DIRPRD,POP1,
     &        POP2,VRT1,VRT2
      DIMENSION G(DISSYG,1),W(DISSYW,1),DIVO(1),TMP(1)
      DIMENSION POP1(8),POP2(8),VRT1(8),VRT2(8),IPT(8) 
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
C
      DATA ONE,ONEM,TWO /1.0D0,-1.D0,2.D0/,HALF /0.5D0/
C
C      PICK UP FIRST THE G AMPLITUDES AND THE INTEGRALS
C
      CALL GETLST(G,1,NUMSYG,1,IRREPR,LISTG)
C
C SPIN ADAPTION FOR RHF
C
      IF(IUHF.EQ.0) THEN 
       CALL SPINAD1(IRREPR,POP1,DISSYG,G,TMP,TMP(1+DISSYG))
      ENDIF
C
C  DECIDE ABOUT THE ALGORITHM BY CHECKING MAXSIZE
C
      IF(MAXSIZE.GT.NUMSYW*DISSYW) THEN
C
C  FULL IN CORE ALGORITHM
C
       CALL GETLST(W,1,NUMSYW,2,IRREPL,LISTW)
C
C TRANSPOSE THE LAST TWO INDICES IN THE AA CASE
C
       IF(ISPIN.EQ.2.OR.IUHF.EQ.0) THEN 
        CALL SYMTR1(IRREPR,POP1,POP2,DISSYG,G,TMP,TMP(1+DISSYG),
     &              TMP(1+2*DISSYG))
        CALL SYMTR1(IRREPL,VRT1,POP2,DISSYW,W,TMP,TMP(1+DISSYW),
     &              TMP(1+2*DISSYW))
       ENDIF
C
C  PERFORM MULTIPLICATION
C
C  JOFFG AND JOFFW OFFSET IN THE RIGHT BLOCK OF G AND W
C  IOFF OFFSET IN DIVO
C
       JOFFG=1
       IOFF=1
       DO 90 IRREPIR=1,NIRREP
C          
C GET OCCUPATION NUMBER FOR JRREP     
C
        NOCCIR=POP1(IRREPIR)
C
C DETERMINE IRREPJ WHOSE DIRECT PRODUCT WITH IRREPI GIVES IRREP
C
        IRREPJ=DIRPRD(IRREPR,IRREPIR)
C
C GET OCCUPATION NUMBER FOR IRREPJ
C
        NOCCJ=POP2(IRREPJ)
C
        IRREPIL=DIRPRD(IRREPL,IRREPJ)
C
        NVRTIL=VRT1(IRREPIL)
C
        JOFFW=1
        DO 89 IRREP=1,IRREPIL-1
         JOFFW=JOFFW+VRT1(IRREP)*POP2(DIRPRD(IRREPL,IRREP))
89      CONTINUE
C
C  IF ZERO, NOTHING TO COMPUTE
C
        IF(MIN(NOCCIR,NOCCJ,NVRTIL).NE.0) THEN
C
         CALL XGEMM('T','N',NVRTIL,NOCCIR,DISSYG*NOCCJ,FACT,
     &              W(1,JOFFW),NOCCJ*DISSYW,G(1,JOFFG),      
     &              NOCCJ*DISSYG,ONE,DIVO(IOFF),NVRTIL)
C
        ENDIF
C
C  UPDATE OFFSETS
C
        JOFFG=JOFFG+NOCCJ*NOCCIR
        IOFF=IOFF+NOCCIR*NVRTIL
90     CONTINUE
C
      ELSE
C
C  OUT OF CORE ALGORITHM
C
C  DIFFER HERE BETWEEN THE TWO SPIN CASES
C
       IF(ISPIN.EQ.1) THEN
C
C  DETERMINE FIRST OFFSETS FOR DIVO
C
        IRREPX=DIRPRD(IRREPR,IRREPL)
        IPT(1)=1
        DO 150 IRREPJR=1,NIRREP-1
         IRREPJL=DIRPRD(IRREPJR,IRREPX)
         IPT(IRREPJR+1)=IPT(IRREPJR)+POP1(IRREPJR)*VRT1(IRREPJL)
150     CONTINUE
C
C DETERMINE MAXIMUM NUMBER OF DISTRIBUTIONS WHICH CAN BE HELD IN CORE
C
        MAXDIS=MAXSIZE/DISSYW
C
C  SET OFFSETS FOR INTEGRAL LIST AND FOR G AMPLITUDES
C
        IOFFSET=1
        JOFFG=1
C
C  LOOP OVER THE IRREP OF THE LAST INDEX
C
        DO 200 IRREPJ=1,NIRREP
C
         NOCCJ=POP2(IRREPJ)
         IRREPIR=DIRPRD(IRREPR,IRREPJ)
         IRREPIL=DIRPRD(IRREPL,IRREPJ)
         NOCCI=POP1(IRREPIR)
         NVRTI=VRT1(IRREPIL)
         IF(MIN(NOCCI,NOCCJ,NVRTI).NE.0) THEN
C
C  GET MAXIMUM NUMBER OF (Ef,A) BLOCKS WHICH CAN BE HELD IN CORE
C
          DISMAX=MAXDIS/NVRTI
          IF(DISMAX.LE.0) CALL INSMEM('DIVO3AB',DISMAX,1)
C
C  SET NUMBER OF (Ef,A) BLOCKS TO READ
C
          DISLEFT=NOCCJ
C
10        CONTINUE  
C
C DETERMINE NUMBER OF (Ef,A) BLOCKS WHICH ARE READ IN DURINg THIS PASS
C
           DISREAD=MIN(DISLEFT,DISMAX)
           DISLEFT=DISLEFT-DISREAD
C
C  GET THE DISTRIBUTIONS FROM DISK
C
           CALL GETLST(W,IOFFSET,DISREAD*NVRTI,2,IRREPL,LISTW)
C
C  UPDATE IOFFSET
C
           IOFFSET=IOFFSET+DISREAD*NVRTI
C
C  LOOP OVER ALL DISTRIBUTIONS AND PERFORM MULTIPLICATION
C
           JOFFW=1
           IOFF=IPT(IRREPIR)
C
           DO 250 NUM=1,DISREAD
C
            CALL XGEMM('T','N',NVRTI,NOCCI,DISSYW,FACT,
     &                 W(1,JOFFW),DISSYW,G(1,JOFFG),DISSYW,
     &                 ONE,DIVO(IOFF),NVRTI)
C
C UPDATE OFFSETS
C
            JOFFW=JOFFW+NVRTI
            JOFFG=JOFFG+NOCCI
C
250        CONTINUE
C
C  IF NOT ALL (Ef,A) BLOCKS HAVE BEEN PROCESSED, GO BACK TO 10
C
          IF(DISLEFT.NE.0) GO TO 10
C
         ELSE
C
C  UPDATE OFFSETS IN THE CASE NOTHING HAS BEEN DONE
C
          JOFFG=JOFFG+NOCCI*NOCCJ
          IOFFSET=IOFFSET+NOCCJ*NVRTI
         ENDIF
200     CONTINUE
C
       ELSE IF(ISPIN.EQ.2) THEN
C
C  DETERMINE MAXIMUM NUMBER OF DISTRIBUTIONS WHICH CAN BE HELD IN CORE
C
        MAXDIS=MAXSIZE/DISSYW
C
C  OFFSET FOR INTEGRAL LIST AND FOR G AMPLITUDES
C
        IOFFSET=1
        JOFFG=1
        IOFFX=1
C
C  LOOP OVER IRREPS OF THE LAST INDEX
C
        DO 300 IRREPJ=1,NIRREP
C
         NOCCJ=POP1(IRREPJ)
         NVRTJ=VRT1(IRREPJ)
         IRREPI=DIRPRD(IRREP,IRREPJ)
         NOCCI=POP2(IRREPI)
         IF(MIN(NOCCI,NOCCJ,NVRTJ).NE.0) THEN
C
C  DETERMINE NUMBER OF (Ef,M) BLOCKS WHICH CAN BE HELD IN CORE 
C
          DISMAX=MAXDIS/NOCCI
C
C  SET NUMBER OF (Ef,M) BLOCKS TO READ
C
          DISLEFT=NVRTJ
C
          IOFF=0
C
20        CONTINUE
C
C  DETERMIN NUMBER OF (Ef,M) BLOCKS WHICH ARE READ DURINg THIS PASS
C
           DISREAD=MIN(DISLEFT,DISMAX)
           DISLEFT=DISLEFT-DISREAD
C 
C  GET THE DISTRIBUTIONS FROM DISK
C
           CALL GETLST(W,IOFFSET,DISREAD*NOCCI,2,IRREP,LISTW)
C
C  UPDATE IOFFSET
C
           IOFFSET=IOFFSET+DISREAD*NOCCI
C
C  PERFORM MULTIPLICATION
C
           CALL XGEMM('T','N',DISREAD,NOCCJ,DISSYW*NOCCI,FACT,
     &                W,DISSYW*NOCCI,G(1,JOFFG),DISSYW*NOCCI,
     &                ONE,DIVO(IOFFX+IOFF),NVRTJ)
C
           IOFF=IOFF+DISREAD 
C
C  IF NOT ALL (Ef,M) BLOCKS HAVE BEEN PROCESSED, GO BACK TO 20 
C
          IF(DISLEFT.NE.0) GO TO 20
C
         ELSE
C
C  UPDATE OFFSETS IN THE CASE NOTHING HAS BEEN DONE
C
          IOFFSET=IOFFSET+NOCCI*NVRTJ
         ENDIF
C
C  UPDATE OFFSETS
C
         IOFFX=IOFFX+NOCCJ*NVRTJ
         JOFFG=JOFFG+NOCCJ*NOCCI
300     CONTINUE
C
       ENDIF
      ENDIF
C
      RETURN
      END
