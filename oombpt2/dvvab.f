      SUBROUTINE DVVAB(T1,T2,T,DVV,FACT,ISPIN,POP1,POP2,
     &                 VRT1,VRT2,DISSYT,NUMSYT,LISTT1,LISTT2,LISTT3,
     &                 IRREP,TMP,IUHF,IFLAG)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT,DIRPRD,POP1,POP2,VRT1,VRT2
      DIMENSION T1(NUMSYT,1),T2(NUMSYT,2),T(DISSYT,1),DVV(1),TMP(1)
      DIMENSION POP1(8),POP2(8),VRT1(8),VRT2(8)
      COMMON /MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
C
      DATA ONE,ONEM,TWO/1.0D0,-1.D0,2.D0/
C
C PICK UP THE T1 AND T2 AMPLITUDES AND CHECK IFLAG
C
      CALL GETLST(T2,1,NUMSYT,1,IRREP,LISTT1)
      CALL TRANSP(T2,T1,NUMSYT,DISSYT)

      IF(IFLAG.GT.1) THEN
C
C GENERAL CASE, GET T AND L AMPLITUDES (CC-METHODS)
C
       CALL GETLST(T,1,NUMSYT,2,IRREP,LISTT2)
       CALL TRANSP(T,T2,NUMSYT,DISSYT)

       IF(IFLAG.EQ.3) THEN
C
C FOR MBPT(3), FORM T[2] + 1/2 T[1], NOTE THAT THE VECTOR T2 CONTAINS
C T[1] + T[2], THEREFORE THE FACTOR IS ONEM
C
        CALL SSCAL(NUMSYT*DISSYT,TWO,T2,1)
        CALL SAXPY(NUMSYT*DISSYT,ONEM,T1,1,T2,1) 
C
       ELSE IF(IFLAG.EQ.4) THEN
C
C FOR SECOND CALL MBPT(4), ...
C
        CALL SSCAL(NUMSYT*DISSYT,TWO,T1,1)
        CALL SAXPY(NUMSYT*DISSYT,ONE,T2,1,T1,1)
        CALL GETLST(T,1,NUMSYT,2,IRREP,LISTT3)
        CALL TRANSP(T,T2,NUMSYT,DISSYT)
C
       ELSE IF(IFLAG.EQ.5) THEN
C
C ROHF-MBPT(3), FORM  T[1] + T[2] + L[2]
C
        CALL SAXPY(NUMSYT*DISSYT,ONE,T1,1,T2,1)
        CALL GETLST(T,1,NUMSYT,1,IRREP,LISTT3)
        CALL TRANSP(T,T1,NUMSYT,DISSYT)
        CALL SAXPY(NUMSYT*DISSYT,ONE,T1,1,T2,1)
C
       ELSE IF(IFLAG.EQ.6) THEN
C Regularized techniques, esp. for LinCC
C Scale T2 with reg/epsilon^2
        CALL GETLST(T,1,NUMSYT,2,IRREP,LISTT3)
        CALL TRANSP(T,T2,NUMSYT,DISSYT)
        call VECPRD(T1,T2,T1,NUMSYT*DISSYT)
        call getlst(T,1,NUMSYT,1,IRREP,LISTT2)
        CALL TRANSP(T,T2,NUMSYT,DISSYT)
       ENDIF
C
      ELSE 
C
C T1 AND T2 ARE IDENTICAL (MBPT(2) AND FIRST CALL MBPT(4)
C
c YAU : old
c      CALL ICOPY(NUMSYT*DISSYT*IINTFP,T1,1,T2,1)
c YAU : new
       CALL DCOPY(NUMSYT*DISSYT,T1,1,T2,1)
c YAU : end
C
       ENDIF 
C
C SPIN ADAPTED CODE FOR RHF
C
       IF(IUHF.EQ.0) THEN
        CALL SPINAD3(IRREP,POP1,NUMSYT,DISSYT,T2,TMP,
     &               TMP(1+DISSYT))
       ENDIF
C
C  TRANSPOSE THE LAST TWO INDICES IN THE AA CASE
C
C  HOWEVER, IN RHF TAKE ADVANTAGE IF THE SPIN SYMMETRY
C
      IF(IUHF.EQ.1.AND.ISPIN.EQ.1) THEN
        CALL SYMTR1(IRREP,VRT1,VRT2,NUMSYT,T1,TMP,TMP(1+NUMSYT),
     &              TMP(1+2*NUMSYT))
        CALL SYMTR1(IRREP,VRT1,VRT2,NUMSYT,T2,TMP,TMP(1+NUMSYT),
     &              TMP(1+2*NUMSYT))
      ENDIF
C
C  PERFORM MULTIPLICATION
C
C  JOFF OFFSET IN THE VIRTUAL-VIRTUAL BLOCK OF T1 AND T2
C  IOFF OFFSET IN DVV
C
      IOFF=1
      JOFF=1
      DO 90 IRREPI=1,NIRREP
C          
C        GET NUMBER OF VIRTUAL ORBITALS FOR IRREPJ
C
       NVRTI=VRT1(IRREPI)
C
C        DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH IRREPJ GIVES IRREP
C
       IRREPJ=DIRPRD(IRREP,IRREPI)
C
C        GET NUMBER OF VIRTUAL ORBITALS FOR KRREP
C
       NVRTJ=VRT2(IRREPJ)
C
C        IF NVRTI OR NVRTJ EQUAL ZERO, NOTHING TO COMPUTE
C
       IF(MIN(NVRTJ,NVRTI).NE.0) THEN
C
          CALL XGEMM('T','N',NVRTI,NVRTI,NUMSYT*NVRTJ,FACT,
     &               T1(1,JOFF),NVRTJ*NUMSYT,T2(1,JOFF),
     &               NVRTJ*NUMSYT,ONE,DVV(IOFF),NVRTI)
       ENDIF
C
C  UPDATE THE OFFSETS
C
       JOFF=JOFF+NVRTJ*NVRTI
       IOFF=IOFF+NVRTI*NVRTI
90    CONTINUE
C
      RETURN
      END
