      SUBROUTINE TRPS3(
     1                 EVAL,SCR1,SCR2,SCR3,
     1                 OOOV,
     1                 T2BAB,T2BAAI,T2BAAJ,T2BBBI,T2BBBJ,
     1                 IADBLK,LENBLK,IADT2,LENT2,
     1                 IADV,LENV,OOOVAD,LENINT,
     1                 ICORE,
     1                 LNOOOV,NOCA,NOCB,NVRTA,NVRTB,MAXCOR,
     1                 IUHF,S1A,S1B)
      IMPLICIT INTEGER (A-Z)
      INTEGER ABSOCC,ABSVRT,DIRPRD,POP,VRT
      LOGICAL IJEQL,NONEQL
      LOGICAL CCSDT4,CCSDT
      LOGICAL TRIPNI,TRIPNI1,TRIPIT,T3STOR
      DOUBLE PRECISION T1A(1),T1B(1),FOVA(1),FOVB(1),
     1                 D1T1A(1),D1T1B(1),S1A(1),S1B(1),
     1                 SCR1(1),SCR2(1),SCR3(1),EVAL(NOCA+NVRTA,2)
C     OOOV  ijka integrals/intermediates for D3T3 = WT2
      DOUBLE PRECISION  OOOV(LNOOOV,4)
      DOUBLE PRECISION T2BAB(1),T2BAAI(1),T2BAAJ(1),
     1                 T2BBBI(1),T2BBBJ(1)
      DOUBLE PRECISION ICORE(1)
C
      DOUBLE PRECISION E4TAAA,E4TBBB,E4TAAB,E4TBBA,E5STA,E5STB,
     1                 E5ST2A,E5ST2B,E4STA,E4STB,E4ST2A,E4ST2B,
     1                 E5TD1,E5TD4,E5TD2,E5TD3,
     1                 E5TT1,E5TT4,E5TT2,E5TT3
      DOUBLE PRECISION E5QT1,E5QT4,E5QT2,E5QT3,
     1                 E6TT1,E6TT4,E6TT2,E6TT3
      DOUBLE PRECISION SDOT
      DOUBLE PRECISION DIJK
C
#include "maxbasfn.par"
      DIMENSION OOOVAD(8,4),LENINT(8,4)
      DIMENSION LEN(8,8),IADBLK(8),LENBLK(8)
      DIMENSION                        IADT2(8) ,LENT2(8),
     1                                 IADV(8)  ,LENV(8)
      DIMENSION IADW(8),LENW(8)
      DIMENSION IADW2(8)
C
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON /SYM/    POP(8,2),VRT(8,2),NTAA,NTBB,NF1AA,NF2AA,
     1                NF1BB,NF2BB
      COMMON /INFO/   NOCCO(2),NVRTO(2)
      COMMON /FLAGS/  IFLAGS(100)
      EQUIVALENCE(ICLLVL,IFLAGS( 2))
      EQUIVALENCE(INONHF,IFLAGS(38))
      EQUIVALENCE(IORBTP,IFLAGS(39))
C
C     T3 ARRAYS
C
      COMMON /TRIPLES/ TRIPNI,TRIPNI1,TRIPIT,T3STOR
      COMMON /ACTORB/ ABSVRT(MAXBASFN,8,2),ABSOCC(MAXBASFN,8,2)
      COMMON /T3OFF/  IOFFVV(8,8,10),IOFFOO(8,8,10),IOFFVO(8,8,4)
      COMMON /T3ENRG/ E4TAAA,E4TBBB,E4TAAB,E4TBBA,
     1                E5STA ,E5STB ,
     1                E4STA ,E4STB ,
     1                E5TD1 ,E5TD4 ,E5TD2 ,E5TD3,
     1                E5TT1 ,E5TT4 ,E5TT2 ,E5TT3,
     1                E5QT1 ,E5QT4 ,E5QT2 ,E5QT3,
     1                E6TT1 ,E6TT4 ,E6TT2 ,E6TT3
      COMMON /LISWI/  LWIC11,LWIC12,LWIC13,LWIC14,
     1                LWIC15,LWIC16,LWIC17,LWIC18,
     1                LWIC21,LWIC22,LWIC23,LWIC24,
     1                LWIC25,LWIC26,LWIC27,LWIC28,
     1                LWIC31,LWIC32,LWIC33,
     1                LWIC34,LWIC35,LWIC36,
     1                LWIC37,LWIC38,LWIC39,LWIC40,LWIC41,LWIC42
      COMMON /T3IOOF/ IJKPOS(8,8,8,2),IJKLEN(36,8,4),IJKOFF(36,8,4),
     1                NCOMB(4)
      COMMON /T3METH/ CCSDT4,CCSDT
C
      INDEX(I) = I*(I-1)/2
C
      WRITE(6,1015)
 1015 FORMAT(' @TRPS3-I, Spin case BBA ')
C
C     Get eigenvalues (more precisely, diagonal Fock matrix elements)
C
      CALL GETREC(20,'JOBARC','SCFEVALA',(NOCA+NVRTA)*IINTFP,
     1            EVAL(1,1))
      CALL GETREC(20,'JOBARC','SCFEVALB',(NOCB+NVRTB)*IINTFP,
     1            EVAL(1,2))
C
C     Determine the lengths and dimensions of the NIRREP**2 T2 BBA arrays.
C
C      WRITE(6,1070)
 1070 FORMAT(' @TRPS3-I, TRIPLES SYMMETRY BLOCK INFORMATION ')
      DO  100 IRPIJK=1,NIRREP
      DO   90 IRPC  =1,NIRREP
      IRPAB = DIRPRD(IRPIJK,IRPC)
      LEN(IRPC,IRPIJK) = IRPDPD(IRPAB,2) * VRT(IRPC,1)
C      WRITE(6,1080) IRPIJK,IRPC,IRPAB,LEN(IRPC,IRPIJK)
 1080 FORMAT('   FOR IJK BLOCK ',I4,/,
     1       '       C   BLOCK ',I4,' AB BLOCK ',I4,' LENGTH IS ',I6)
   90 CONTINUE
  100 CONTINUE
C
C     Compute addresses and lengths of OOOV quantities.
C
      DO  410 ISPIN=1,4
      DO  400 IRREP=1,NIRREP
      IF(ISPIN.EQ.1)THEN
      LENINT(IRREP,ISPIN) = IRPDPD(IRREP, 3) * IRPDPD(IRREP,16)
      ENDIF
      IF(ISPIN.EQ.2)THEN
      LENINT(IRREP,ISPIN) = IRPDPD(IRREP, 4) * IRPDPD(IRREP,17)
      ENDIF
      IF(ISPIN.EQ.3)THEN
      LENINT(IRREP,ISPIN) = IRPDPD(IRREP,14) * IRPDPD(IRREP,11)
      ENDIF
      IF(ISPIN.EQ.4)THEN
      LENINT(IRREP,ISPIN) = IRPDPD(IRREP,14) * IRPDPD(IRREP,18)
      ENDIF
  400 CONTINUE
  410 CONTINUE
C
      OOOVAD(1,1) = 1
      OOOVAD(1,2) = 1
      OOOVAD(1,3) = 1
      OOOVAD(1,4) = 1
      DO  430 ISPIN=1,4
      IF(NIRREP.GT.1)THEN
      DO  420 IRREP = 2,NIRREP
      OOOVAD(IRREP,ISPIN) = OOOVAD(IRREP-1,ISPIN) +
     1                      LENINT(IRREP-1,ISPIN)
  420 CONTINUE
      ENDIF
  430 CONTINUE
C      WRITE(6,1200)
 1200 FORMAT(' @TRPS3-I, OOOV ARRAY LENGTHS AND ADDRESSES ')
      DO  450 ISPIN=1,4
      DO  440 IRREP=1,NIRREP
C      WRITE(6,1210) ISPIN,IRREP,LENINT(IRREP,ISPIN),OOOVAD(IRREP,ISPIN)
 1210 FORMAT(' SPIN, IRREP, LENGTH, ADDRESS ',2I4,I6,I6)
  440 CONTINUE
  450 CONTINUE
C
      DO  460 IRREP=1,NIRREP
      CALL GETTRN(OOOV(OOOVAD(IRREP,4),4),ICORE,
     1            IRPDPD(IRREP,14),IRPDPD(IRREP,18),
     1            2,IRREP,LWIC14)
      CALL GETTRN(OOOV(OOOVAD(IRREP,2),2),ICORE,
     1            IRPDPD(IRREP, 4),IRPDPD(IRREP,17),
     1            2,IRREP,LWIC12)
      CALL GETTRN(OOOV(OOOVAD(IRREP,3),3),ICORE,
     1            IRPDPD(IRREP,14),IRPDPD(IRREP,11),
     1            2,IRREP,LWIC13)
  460 CONTINUE
C
      DO  471 IRPIJ=1,NIRREP
      CALL SYMTR3(IRPIJ,POP(1,2),VRT(1,2),IRPDPD(IRPIJ,17),
     1            IRPDPD(IRPIJ,4),OOOV(OOOVAD(IRPIJ,2),2),
     1            SCR1,SCR2,SCR3)
      CALL SYMTR3(IRPIJ,VRT(1,1),POP(1,2),IRPDPD(IRPIJ,11),
     1            IRPDPD(IRPIJ,14),OOOV(OOOVAD(IRPIJ,3),3),
     1            SCR1,SCR2,SCR3)
      CALL SYMTR3(IRPIJ,POP(1,1),VRT(1,2),IRPDPD(IRPIJ,12),
     1            IRPDPD(IRPIJ,14),OOOV(OOOVAD(IRPIJ,4),4),
     1            SCR1,SCR2,SCR3)
  471 CONTINUE
C
C     Compute number of free double words.
      MCORE = MAXCOR / IINTFP
      WRITE(6,1230) MAXCOR,MCORE,IINTFP
 1230 FORMAT(' @TRPS3-I, Number of free integer words ',I10,/,
     1       '           Number of free double  words ',I10,/,
     1       '           Ratio                        ',I10)
C
      E4TBBA = 0.0D+00
      ISPIN1 = 2
      ISPIN2 = 1
C
      DO 1000 IRPIJK=1,NIRREP
C
      IJKVAL = 0
C
      DO  990 IRPK  =1,NIRREP
      IF(POP(IRPK,ISPIN2).EQ.0) GOTO 990
C
      KLOW  = 1
      KHIGH = POP(IRPK,ISPIN2)
C
      DO  980 IRPJ=1,NIRREP
      IF(POP(IRPJ,ISPIN1).EQ.0) GOTO 980
      IRPJK = DIRPRD(IRPJ,IRPK)
      IRPI  = DIRPRD(IRPJK,IRPIJK)
      IF(IRPI.GT.IRPJ) GOTO 980
C
      IF(POP(IRPI,ISPIN1).EQ.0) GOTO 980
C
      IJEQL  = .FALSE.
      NONEQL = .FALSE.
      IF(IRPI.EQ.IRPJ)THEN
      IJEQL  = .TRUE.
      JLOW  = 2
      JHIGH = POP(IRPJ,ISPIN1)
      ILOW  = 1
      NIJ = (POP(IRPJ,ISPIN1) * (POP(IRPJ,ISPIN1)-1))/2
      ELSE
      NONEQL = .TRUE.
      JLOW  = 1
      JHIGH = POP(IRPJ,ISPIN1)
      ILOW  = 1
      IHIGH = POP(IRPI,ISPIN1)
      NIJ =  POP(IRPI,ISPIN1) * POP(IRPJ,ISPIN1)
      ENDIF
C
      NIK = POP(IRPI,ISPIN1) * POP(IRPK,ISPIN2)
      NJK = POP(IRPJ,ISPIN1) * POP(IRPK,ISPIN2)
C
      IF(IJEQL.AND.POP(IRPJ,ISPIN1).LT.2) GOTO 980
C
      IRPIJ =  DIRPRD(IRPI,IRPJ)
      IRPIK =  DIRPRD(IRPI,IRPK)
C
C     COMPUTE ADDRESSES AND LENGTHS OF ABC SYMMETRY BLOCKS FOR
C     THIS IJK. THIS LOOP IS EFFECTIVELY OVER IRREPS OF C (IE
C     COLUMNS OF THE EVENTUAL TARGET).
C
C     MAIN CORE VECTOR ADDRESSING : (DOUBLE PRECISION WORDS)
C
C           I000   SYMMETRY PACKED T3 FOR THIS IJK BLOCK
C           I010                   W
C           I020   UNEXPANDED T2(  ,IJ) BBBB FOR THIS IJ BLOCK
C           I030   EXPANDED   T2(  ,IJ) BBBB
C           I040   T2(  ,JK) ABAB FOR THIS JK BLOCK
C           I050   T2(  ,IK) ABAB FOR THIS IK BLOCK
C           ISTART CURRENT STARTING ADDRESS OF REUSABLE CORE
C
      I000 = 1
      DO  600 IRREP=1,NIRREP
      IF(IRREP.EQ.1)THEN
      IADBLK(IRREP) = 1
      ELSE
      IADBLK(IRREP) = IADBLK(IRREP-1) + LEN(IRREP-1,IRPIJK)
      ENDIF
      LENBLK(IRREP) = LEN(IRREP,IRPIJK)
  600 CONTINUE
C
      LENABC=0
      DO  610 IRREP=1,NIRREP
      LENABC = LENABC + LENBLK(IRREP)
  610 CONTINUE
C
      I010 = I000 + LENABC
      DO  630 IRREP=1,NIRREP
      IRPA = DIRPRD(IRPIJK,IRREP)
      LENW(IRREP) = VRT(IRPA,2) * IRPDPD(IRREP,13)
  630 CONTINUE
C
      DO  640 IRREP=1,NIRREP
      IF(IRREP.EQ.1)THEN
      IADW(IRREP) = 1
      ELSE
      IADW(IRREP) = IADW(IRREP-1) + LENW(IRREP-1)
      ENDIF
  640 CONTINUE
C
      IOFFT2 = I010
      DO  641 IRREP=1,NIRREP
      IOFFT2 = IOFFT2 + LENW(IRREP)
  641 CONTINUE
C
      I020 = IOFFT2
C     GET VARIOUS "SMALL" BLOCKS OF T2 AND <IJ//KA> IN CORE, ORGANIZED
C     APPROPRIATELY.
C
C     BLOCK OF BBBB T(  ,IJ) WHERE I AND J ARE DIFFERENT SYMMETRY
C     BLOCKS. LENGTH IS IRPDPD(IRPIJ,2) * NIJ.
C
      CALL GETLST(ICORE(I020),IOFFOO(IRPJ,IRPIJ,2)+1,NIJ,1,IRPIJ,45)
C
C     EXPAND INTO A DIFFERENT REGION OF CORE SO WE KEEP UNTOUCHED T2
C     AS WELL AS EXPANDED ONE. LENGTH IS DSZEXP * NIJ.
C
      DSZ   = IRPDPD(IRPIJ,2)
      DSZEXP= IRPDPD(IRPIJ,18+ISPIN1)
      I030 = I020 + DSZ    * NIJ
      I040 = I030 + DSZEXP * NIJ
      CALL SYMEXP2(IRPIJ,VRT(1,ISPIN1),DSZEXP,DSZ,NIJ,ICORE(I030),
     1             ICORE(I020))
C
C     BLOCK OF ABAB T(  ,JK). LENGTH IS IRPDPD(IRPJK,13) * NJK
C
      I050 = I040 + IRPDPD(IRPJK,13) * NJK
      CALL GETLST(ICORE(I040),IOFFOO(IRPJ,IRPJK,5)+1,NJK,1,IRPJK,46)
C
C     BLOCK OF ABAB T(  ,IK). LENGTH IS IRPDPD(IRPIK,13) * NIK
C
      CALL GETLST(ICORE(I050),IOFFOO(IRPI,IRPIK,5)+1,NIK,1,IRPIK,46)
C
      I060 = I050 + IRPDPD(IRPIK,13) * NIK
C
      LNVOIJ  = IRPDPD(IRPIJ,10)
      LNVOIK  = IRPDPD(IRPIK,11)
      LNVOJK  = IRPDPD(IRPJK,11)
      LNVOIK2 = IRPDPD(IRPIK,12)
      LNVOJK2 = IRPDPD(IRPJK,12)
C
C     SET A STARTING ADDRESS FOR REST OF CORE, THAT PART WHICH CAN BE
C     REUSED AFTER D1T3.
C
      I070 = I060 + LENABC
C
      I080 = I070 + LENABC
C
C     Disconnected pieces.
C
      I090 = I080 + LENABC
      I100 = I090 + I020 - I010
      ISTART = I100
      NLEFT = MCORE - ISTART
C
      IF(ISTART.GE.MCORE)THEN
      WRITE(6,9010)
      CALL INSMEM('TRPS3',ISTART,MCORE)
      ENDIF
C
C     COMPUTE DENOMINATOR ARRAY

      CALL MKD33(ICORE(I060),EVAL,IADBLK,IRPIJK,NOCA,NOCB,NVRTA,NVRTB)
C
      DO  649    K=KLOW,KHIGH
      DO  648    J=JLOW,JHIGH
      IF(IJEQL) IHIGH = J-1
      DO  647    I=ILOW,IHIGH
C
      CALL ZERO(ICORE(I000),LENABC)
C
      LENGTHW = 0
      DO 9647 IRREP=1,NIRREP
      LENGTHW = LENGTHW + LENW(IRREP)
 9647 CONTINUE
      CALL ZERO(ICORE(I010),LENGTHW)
C
      CALL D1T3( ICORE(I000),ICORE(I010),
     1           ICORE(I030),ICORE(I040),ICORE(I050),
     1 OOOV(OOOVAD(IRPIJ,2)+IOFFOO(IRPJ,IRPIJ,2)*IRPDPD(IRPIJ,17),2),
     1 OOOV(OOOVAD(IRPJK,4)+IOFFOO(IRPJ,IRPJK,5)*IRPDPD(IRPJK,12),4),
     1 OOOV(OOOVAD(IRPIK,4)+IOFFOO(IRPI,IRPIK,5)*IRPDPD(IRPIK,12),4),
     1 OOOV(OOOVAD(IRPJK,3)+IOFFOO(IRPJ,IRPJK,5)*IRPDPD(IRPJK,11),3),
     1 OOOV(OOOVAD(IRPIK,3)+IOFFOO(IRPI,IRPIK,5)*IRPDPD(IRPIK,11),3),
     1 ICORE(ISTART),IUHF,
     1 IADBLK,LENBLK,IADW,LENW,IADT2,LENT2,IADV,LENV,
     1 I,J,K,IRPI,IRPJ,IRPK,IRPIJ,IRPJK,IRPIK,IRPIJK,
     1 DSZEXP,IRPDPD(IRPJK,13),IRPDPD(IRPIK,13),
     1 IRPDPD(IRPIJ,17),IRPDPD(IRPJK,12),IRPDPD(IRPIK,12),
     1 IRPDPD(IRPJK,11),IRPDPD(IRPIK,11),
     1 SCR1,SCR2,SCR3)
C
c      IJK = IJKPOS(IRPI,IRPJ,IRPK,2)
c      IOFF = IJKOFF(IJK,IRPIJK,ISPIN1+1)
c      IF(IJEQL ) IJKVAL = IOFF + (K-1)*NIJ + INDEX(J-1) + I
c      IF(NONEQL) IJKVAL = IOFF + (K-1)*NIJ + (J-1)*POP(IRPI,ISPIN1) + I
      IJKVAL = IJKVAL + 1
C
      IF(TRIPNI)THEN
      CALL   ZERO(ICORE(ISTART),LENABC)
c YAU : old
c     CALL ICOPY(IINTFP*LENABC,ICORE(I000),1,ICORE(ISTART),1)
c YAU : new
      CALL DCOPY(LENABC,ICORE(I000),1,ICORE(ISTART),1)
c YAU : end
      CALL EXPSC2(ICORE(ISTART),ICORE(I010),IADBLK,IADW,IRPIJK)
      CALL GETLIST(ICORE(I070),IJKVAL,1,1,IRPIJK,ISPIN1 + 1 + 4)
      E5TD3 = E5TD3 + SDOT(LENABC,ICORE(I070),1,ICORE(ISTART),1) 
C
C     QT piece.
C
      CALL ZERO(ICORE(I080),LENABC)
      CALL ZERO(ICORE(I090),LENGTHW)
      CALL S1S223N(S1A,S1B,ICORE(ISTART),ICORE(I080),ICORE(I090),
     1             IADBLK,IADW,ISPIN1,ISPIN2,I,J,K,IRPI,IRPJ,IRPK,
     1             IRPIJ,IRPIK,IRPJK,IRPIJK,IUHF,3)
      E5QT3 = E5QT3 + SDOT(LENABC,ICORE(I070),1,ICORE(I080),1)
C
      CALL   ZERO(ICORE(ISTART),LENABC)
      ENDIF
C
C     TT terms.
C
      CALL ZERO(ICORE(I000),LENABC)
      CALL ZERO(ICORE(I010),LENGTHW)
C
C     CCSDT or non-HF (non-canonical) if semicanonical orbitals not
C     used. (ii) Occupied orbital sum.
C
      IF(ICLLVL.EQ.18.OR.(INONHF.EQ.1.AND.IORBTP.EQ.0))THEN
      CALL T3FT323V(ICORE(I000),ICORE(I010),ICORE(ISTART),MAXCOR,IUHF,
     1              2,1,LENABC,LENGTHW,IRPIJK,IJKVAL,IADBLK,IADW)
      ENDIF
      IF(CCSDT4.OR.CCSDT)THEN
C     CCSDT abef intermediate contribution.
      CALL T3WT323P(ICORE(I000),ICORE(I010),ICORE(ISTART),MAXCOR,IUHF,
     1              2,1,LENABC,LENGTHW,IRPIJK,IJKVAL,IADBLK,IADW)
C     CCSDT maei intermediate contribution.
      CALL T3WT323R(ICORE(I000),ICORE(I010),ICORE(ISTART),MAXCOR,2,1,
     1              IADBLK,IADW,IRPI,IRPJ,IRPK,I,J,K,IRPIJK,IUHF)
      ENDIF
C
C     CCSDT or non-HF (non-canonical) if semicanonical orbitals not
C     used. (ii) Occupied orbital sum.
C
      IF(ICLLVL.EQ.18.OR.(INONHF.EQ.1.AND.IORBTP.EQ.0))THEN
      CALL T3FT323O(ICORE(I000),ICORE(ISTART),MAXCOR,IUHF,2,1,LENABC,
     1              IRPI,IRPJ,IRPK,IRPIJK,I,J,K)
      ENDIF
      IF(CCSDT4.OR.CCSDT)THEN
      CALL T3WT323HH(ICORE(I000),ICORE(ISTART),MAXCOR,IUHF,2,1,LENABC,
     1              IRPI,IRPJ,IRPK,IRPIJK,I,J,K)
      ENDIF
C
      CALL EXPSC3(ICORE(I000),ICORE(I010),IADBLK,IADW,IRPIJK)
C
      IF(TRIPNI)THEN
      E5TT3 = E5TT3 + SDOT(LENABC,ICORE(I070),1,ICORE(I000),1) 
      ENDIF
C
C     Try to do the E6TT pieces.
Cihere
      CALL ZERO(ICORE(I070),LENABC)
      CALL ZERO(ICORE(I010),LENGTHW)
      CALL S1S223N(S1A,S1B,ICORE(ISTART),ICORE(I070),ICORE(I010),
     1             IADBLK,IADW,ISPIN1,ISPIN2,I,J,K,IRPI,IRPJ,IRPK,
     1             IRPIJ,IRPIK,IRPJK,IRPIJK,IUHF,1)
      DIJK = EVAL(ABSOCC(I,IRPI,2),2) + EVAL(ABSOCC(J,IRPJ,2),2)
     1     + EVAL(ABSOCC(K,IRPK,1),1)
      CALL RMD314(ICORE(I070),ICORE(I060),LENABC,DIJK)
      E6TT3 = E6TT3 + SDOT(LENABC,ICORE(I070),1,ICORE(I000),1)
C
C     REMOVE DENOMINATORS
C
      DIJK = EVAL(ABSOCC(I,IRPI,2),2) + EVAL(ABSOCC(J,IRPJ,2),2)
     1     + EVAL(ABSOCC(K,IRPK,1),1)
      CALL RMD314(ICORE(I000),ICORE(I060),LENABC,DIJK)
C
C     COMPUTE T(CCSD) ENERGY
C
      CALL E4TIJK(ICORE(I000),ICORE(I060),LENABC,DIJK,E4TBBA)
C
c      IJK = IJKPOS(IRPI,IRPJ,IRPK,2)
c      IOFF = IJKOFF(IJK,IRPIJK,ISPIN1+1)
c      IF(IJEQL ) IJKVAL = IOFF + (K-1)*NIJ + INDEX(J-1) + I
c      IF(NONEQL) IJKVAL = IOFF + (K-1)*NIJ + (J-1)*POP(IRPI,ISPIN1) + I
C      IF(T3STOR)THEN
C      CALL PUTLIST(ICORE(I000),IJKVAL,1,1,IRPIJK,ISPIN1 + 1)
C      ENDIF
  647 CONTINUE
  648 CONTINUE
  649 CONTINUE
C
  980 CONTINUE
  990 CONTINUE
C
 1000 CONTINUE
c      write(6,*) ' @trps3-i, e5td, e5tt ', e5td3,e5tt3
c      write(6,*) ' @trps3-i, e5qt3 ',E5QT3
C
      RETURN
 9010 FORMAT(' TRPS3-I, Insufficient memory to continue. ')
      END
