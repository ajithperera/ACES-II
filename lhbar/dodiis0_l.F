      SUBROUTINE DODIIS0_L(SCR,MAXCOR,IUHF,IRREPX,ICYCLE,
     &                   ICONVG,ICONTL,SING,LISTT20,LISTT21,
     &                   LISTT10,IOFF0,LISTT11,IOFF1,LSTERR,
     &                   TYPE)

C
C DRIVER FOR DIIS CONVERGENCE ACCELERATION FOR DERIVATIVE T AMPLITUDE
C EQUATIONS
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL SING
C
      DIMENSION SCR(MAXCOR)
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/DIISDAT1/LENVEC,NDIMR,IDIMR
      COMMON/DIISDAT2/R(2500)
      COMMON/FLAGS/IFLAGS(100)
C
      DATA ONE,ONEM/1.D0,-1.D0/
C
      INDXF(I,J,N)=I+(J-1)*N
C
      TOL=10.D0**(-ICONTL)
      ICONVG=1
      MAXDIM=IFLAGS(12)
      MAXDM1=MAXDIM+2
      NDIMR=MAX(NDIMR,1)
C
C DO BOOKKEEPING AND COMPUTE RESIDUAL VECTOR
C
      I000=1
      I010=I000+MAX(LENVEC,MAXDM1*MAXDM1)
      I020=I010+MAX(LENVEC,MAXDM1*MAXDM1)
      IEND=I020+MAXDM1
      IF(IEND.GE.MAXCOR) CALL INSMEM('DODIIS0',IEND,MAXCOR)
C
C Symmetrize the T2 amplitudes for RHF cases.
C
      IF (IUHF.EQ.0) THEN
         CALL SYMETRIZE_T2(SCR, MAXCOR, 1, LISTT20+2)
         CALL SYMETRIZE_T2(SCR, MAXCOR, 1, LISTT21+2)
      END IF
C
      IOFFT=I000
      IOFFHT=I010
      IF(SING)THEN
       DO 10 ISPIN=1,1+IUHF
        CALL GETLST(SCR(IOFFT) ,1,1,1,IOFF0+ISPIN,LISTT10)
        CALL GETLST(SCR(IOFFHT),1,1,1,IOFF1+ISPIN,LISTT11)
        IOFFT=IOFFT+IRPDPD(IRREPX,8+ISPIN)
        IOFFHT=IOFFHT+IRPDPD(IRREPX,8+ISPIN)
10     CONTINUE
      ENDIF
      DO 11 ISPIN=3,1,IUHF-2
       LISTT=LISTT20-1+ISPIN
       NSIZE=IDSYMSZ(IRREPX,ISYTYP(1,LISTT),ISYTYP(2,LISTT))
       CALL GETALL(SCR(IOFFT) ,NSIZE,IRREPX,LISTT20-1+ISPIN)
       CALL GETALL(SCR(IOFFHT),NSIZE,IRREPX,LISTT21-1+ISPIN)

       IOFFT=IOFFT+NSIZE
       IOFFHT=IOFFHT+NSIZE
11    CONTINUE
c
C
C SAVE OLD T AS NEW APPROXIMATE SOLUTION VECTOR ON 1,LSTERR
C
      CALL PUTLST(SCR(I000),IDIMR,1,1,1,LSTERR)
      CALL SAXPY(LENVEC,ONEM,SCR(I000),1,SCR(I010),1)
      RESMITER=SCR(I010-1+ISAMAX(LENVEC,SCR(I010),1))
cpr      print *,"RESMITER = ",resmiter
C
C SAVE T(NEW)-T(OLD) AS CORRESPONDING ERROR VECTOR ON 2,LSTERR
C
      CALL PUTLST(SCR(I010),IDIMR,1,1,2,LSTERR)
C
C CALCULATE ERROR MATRIX UP TO THIS POINT
C
      DO 100 I=1,NDIMR
       CALL GETLST(SCR(I000),I,1,1,2,LSTERR)
       DO 101 J=1,I
        CALL GETLST(SCR(I010),J,1,1,2,LSTERR)
c
        X=SDOT(LENVEC,SCR(I000),1,SCR(I010),1)
        R(INDXF(I,J,MAXDIM))=X
        R(INDXF(J,I,MAXDIM))=X
101    CONTINUE
100   CONTINUE 
C
C CALCULATE DIIS EXPANSION COEFFICIENTS
C
      CALL DODIIS(R,SCR(I000),SCR(I020),MAXDIM,NDIMR)
C
      IF(IFLAGS(1).GE.1)THEN
       WRITE(6,1000)
       CALL PRVECR(SCR(I020),NDIMR)
      ENDIF
C
C EVALUATE DIIS RESIDUAL
C
      IOFF=I020
      CALL ZERO(SCR(I000),LENVEC)
      DO 500 I=1,NDIMR 
       FACT=SCR(IOFF)
       CALL GETLST(SCR(I010),I,1,1,2,LSTERR)
       CALL SAXPY (LENVEC,FACT,SCR(I010),1,SCR(I000),1)
       IOFF=IOFF+1
500   CONTINUE
      RESMDIIS=SCR(ISAMAX(LENVEC,SCR,1))
C
C WRITE OUT RESIDUALS AND CHECK CONVERGENCE
C
      WRITE(6,1001)ICYCLE
      WRITE(6,1002)RESMITER
      WRITE(6,1003)RESMDIIS
      IF(ABS(RESMITER).LT.TOL)THEN
       ICONVG=0
       WRITE(6,1004)ICYCLE
      ELSEIF(ABS(RESMDIIS).LT.TOL)THEN
       ICONVG=0
       WRITE(6,1004)ICYCLE
      ELSE
       ICONVG=1
      ENDIF
C
C EXTRAPOLATE, SKIP ONLY IN THE FIRST ITERATION
C
      IF(NDIMR.GE.2) THEN
COLD
C
C PUT DIIS RESIDUAL ON DISK - THIS CORRESPONDS TO DIIS EXTRAPOLANT
C
c       CALL PUTLST(SCR(I000),1,1,1,2,LSTERR)
COLD
C
C USE (DIIS EXTRAPOLANT + JACOBI UPDATE) AS NEXT VECTOR
C
C GENERATE UPDATED GUESS, THE JACOBI UPDATE IS ALREADY ON SCR(I000)
C ADD THE SOLUTION VECTORS WITH APPROPRIATE COEFFICIENTS
C
c       CALL ZERO(SCR(I000),LENVEC)
       IOFF=I020
       DO 501 I=1,NDIMR
        FACT=SCR(IOFF)
        CALL GETLST(SCR(I010),I,1,1,1,LSTERR)
        CALL SAXPY (LENVEC,FACT,SCR(I010),1,SCR(I000),1)
        IOFF=IOFF+1
501    CONTINUE
COLD
c       CALL PUTLST(SCR(I000),1,1,1,1,LSTERR)
C
C GENERATE UPDATED JACOBI GUESS
C
c       CALL GETLST(SCR(I010),1,1,1,2,LSTERR)
c       CALL SAXPY (LENVEC,ONE,SCR(I010),1,SCR(I000),1)
COLD
C
C WRITE IT OVER CURRENT INCREMENT LISTS
C
       IOFFT=I000
       IF(SING)THEN
        DO 110 ISPIN=1,1+IUHF
         CALL PUTLST(SCR(IOFFT),1,1,1,IOFF1+ISPIN,LISTT11)
#ifdef _DEBUG_LVL0
         call checksum("L1-DISS2 :",scr(iofft),IRPDPD(IRREPX,8+ISPIN))
#endif
         IOFFT=IOFFT+IRPDPD(IRREPX,8+ISPIN)
110     CONTINUE
       ENDIF
       DO 111 ISPIN=3,3-2*IUHF,-1
        LISTT=LISTT20-1+ISPIN
        NSIZE=IDSYMSZ(IRREPX,ISYTYP(1,LISTT),ISYTYP(2,LISTT))
        CALL PUTALL(SCR(IOFFT),NSIZE,IRREPX,LISTT21-1+ISPIN)
#ifdef _DEBUG_LVL0
        call checksum("L2-DISS2 :",scr(iofft), nsize)
#endif
        IOFFT=IOFFT+NSIZE
111    CONTINUE
C
C Create the AA list from AB list for RHF calcualtions.
C
       IF (IUHF.EQ.0) CALL ABTOAA(SCR, MAXCOR*IINTFP, IUHF, LISTT21)
C
      ENDIF
C
C INCREMENT NDIMR (UP TO MAXIMUM DIMENSION LENGTH MAXDIM)
C INCREMENT IDIMR, IF MAXIMUM NUMBER IS ACHIEVED, START AGAIN WITH 1
C
      NDIMR=MIN(MAXDIM,NDIMR+1)
      IDIMR=IDIMR+1
      IF(IDIMR.GT.MAXDIM) IDIMR=1
C
      RETURN
1000  FORMAT(T3,'Current DIIS expansion coefficients : ')
1001  FORMAT(T3,'Convergence information after ',I5,' iterations: ')
1002  FORMAT(T3,'Largest element of residual vector : ',E15.8,'.')
1003  FORMAT(T3,'Largest element of DIIS residual   : ',E15.8,'.')
1004  FORMAT(T3,'Lambda equations converged in ',I5, 
     &          ' iterations.')
      END
