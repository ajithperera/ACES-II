
      SUBROUTINE DHBIAJK6(ICORE,MAXCOR,IUHF,IRREPT,IRREPW,TAUFAC,
     &                    LSTT1U,LSTT1D,LISTT0,LISTW0,LISTZ0,SWITCH,
     &                    TAU,CCSD)
C
C CALCULATES THE CONTRACTION 
C
C    Z(IA,JK) = 1/2 T(EF,JK) * W(IA,EF)
C
C FOR EITHER DIFFERENTIATED OR UNDIFFERENTIATED QUANTITIES
C
C
C CONTRACTION :  TAU(EF,JK) * W(IA,EF) [ISPIN=1,2]
C                TAU(Ef,Jk) * W(Ia,Ef) [ISPIN=4] 
C                TAU(Fe,Kj) * W(Ai,Fe) [ISPIN=3]
C          
CEND
      IMPLICIT INTEGER (A-Z)
      DIMENSION ICORE(MAXCOR),I0T(2),I0DT(2)
      LOGICAL SWITCH,TAU,CCSD, CC2
      DOUBLE PRECISION ONE,ONEM,ZILCH,TAUFAC,FACT
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/SYMINF/NSTART,NIRREP,IRREPY(255,2),DIRPRD(8,8)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/SYMLOC/ISYMOFF(8,8,25)
      COMMON/FLAGS/ IFLAGS(100)
      
C
      DATA ONE,ONEM,ZILCH /1.0D0,-1.0D0,0.0D0/
C
      IRREPZ=DIRPRD(IRREPT,IRREPW)
      
      CC2 = (IFLAGS(2) .EQ. 47)
C
      IF(SWITCH)THEN
       FACT=ONEM
      ELSE
       FACT=ONE
      ENDIF
C
      I0T(1) =1
      I0T(2) =I0T(1)+IINTFP*IRPDPD(1,9)*IUHF
      I0DT(1)=I0T(2)+IINTFP*IRPDPD(1,10)
      I0DT(2)=I0DT(1)+IINTFP*IRPDPD(IRREPT,9)*IUHF
      I000   =I0DT(2)+IINTFP*IRPDPD(IRREPT,10)
      CALL GETLST(ICORE(I0T(1)),1,1,1,1,LSTT1U)
      CALL GETLST(ICORE(I0DT(1)),1,1,1,1,LSTT1D)
      IF(IUHF.NE.0)THEN
       CALL GETLST(ICORE(I0T(2)),1,1,1,2,LSTT1U)
       CALL GETLST(ICORE(I0DT(2)),1,1,1,2,LSTT1D)
      ENDIF
      DO 10 ISPIN=4,4-3*IUHF,-1
       LISTT=LISTT0+MIN(3,ISPIN)
       LISTZ=LISTZ0+ISPIN
       IF(ISPIN.LE.2)THEN
        LISTW =LISTW0+ISPIN
        ISP1  =ISPIN
        ISP2  =ISPIN
       ELSEIF(ISPIN.EQ.3)THEN
        LISTW=LISTW0+4
        ISP1 =1
        ISP2 =2
       ELSEIF(ISPIN.EQ.4)THEN
        LISTW=LISTW0+3+(1-IUHF)
        ISP1 =1
        ISP2 =2
       ENDIF
C  
       DO 20 IRREPZL=1,NIRREP
        IRREPZR=DIRPRD(IRREPZL,IRREPZ)
        IRREPTR=IRREPZR
        IRREPTL=DIRPRD(IRREPTR,IRREPT)
        IRREPWL=IRREPZL
        IRREPWR=DIRPRD(IRREPWL,IRREPW)
        DISSYT=IRPDPD(IRREPTL,ISYTYP(1,LISTT))
        NUMDST=IRPDPD(IRREPTR,ISYTYP(2,LISTT))
        DISSYW=IRPDPD(IRREPWR,ISYTYP(1,LISTW))
        NUMDSW=IRPDPD(IRREPWL,ISYTYP(2,LISTW))
        DISSYZ=IRPDPD(IRREPZR,ISYTYP(1,LISTZ))
        NUMDSZ=IRPDPD(IRREPZL,ISYTYP(2,LISTZ))
        I010=I000+IINTFP*DISSYZ*NUMDSZ
        I020=I010+IINTFP*DISSYT*NUMDST
        I030=I020+IINTFP*DISSYW*NUMDSW
        MAXTMP=MAX(DISSYT,NUMDST,DISSYW,NUMDSW,DISSYZ,NUMDSZ)
        ITMP1=I020
        ITMP2=ITMP1+IINTFP*MAXTMP
        ITMP3=ITMP2+IINTFP*MAXTMP
        CALL GETLST(ICORE(I010),1,NUMDST,1,IRREPTR,LISTT)

        IF (CC2) THEN
           CALL ZERO(ICORE(I010),DISSYT*NUMDST)
        ENDIF
C 
CJDW 10/20/95 Logic for CC3 energies
      IF(IFLAGS(2).EQ.33 .AND. .NOT.CCSD)THEN
        CALL ZERO(ICORE(I010),DISSYT*NUMDST)
      ENDIF
CJDW END
        IF(TAU)THEN
         CALL DTAU(IRREPTL,IRREPTR,1,IRREPT,ICORE(I010),
     &             ICORE(I0T(ISP1)),ICORE(I0T(ISP2)),
     &             ICORE(I0DT(ISP1)),ICORE(I0DT(ISP2)),
     &             MIN(ISPIN,3),TAUFAC)
        ENDIF
        IF(IUHF.EQ.0)THEN
         CALL SYMTR3(IRREPTL,VRT,VRT,DISSYT,NUMDST,ICORE(I010),
     &               ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
        ENDIF
C
C CONTRACTION :  T(EF,JK) * W(IA,EF) [ISPIN=1,2]
C                T(Ef,Jk) * W(Ia,Ef) [ISPIN=4] [T(fe,jk)*W(fe,ai) FOR RHF]
C                T(Fe,Kj) * W(Ai,Fe) [ISPIN=3]
C
CSSS        call checksum("Tau:",ICORE(I010),DISSYT*NUMDST)
        MXCOR=MAXCOR-I020+1
        NINCOR=MXCOR/(IINTFP*MAX(1,DISSYW))
        NLEFT =NUMDSW
        IFIRST=1
        IZ=I000
1       NREAD =MIN(NLEFT,NINCOR)
        CALL GETLST(ICORE(I020),IFIRST,NREAD,1,IRREPWL,LISTW)
CSSS        call checksum("W:",ICORE(I020),DISSYW*NUMDSW)
        IF (MIN(DISSYZ,NREAD,DISSYW).NE.0) THEN
           IF (ISPIN.GT.2) THEN
              CALL XGEMM('T','N',DISSYZ,NREAD,DISSYW,FACT,ICORE(I010),
     &                   DISSYT,ICORE(I020),DISSYW,
     &                   ZILCH,ICORE(IZ),DISSYZ)
           ELSE
              CALL XGEMM('T','N',DISSYZ,NREAD,DISSYW,-FACT,ICORE(I010),
     &                   DISSYT,ICORE(I020),DISSYW,
     &                   ZILCH,ICORE(IZ),DISSYZ)
           END IF
        ELSE
           CALL DZERO(ICORE(IZ),DISSYZ*NREAD)
        END IF
        IZ=IZ+IINTFP*DISSYZ*NREAD
        NLEFT=NLEFT-NREAD
        IFIRST=IFIRST+NREAD
        IF(NLEFT.NE.0)GOTO 1
        IF(IUHF.EQ.0)THEN
         CALL SYMTR1(IRREPZL,VRT,POP,DISSYZ,ICORE(I000),
     &               ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
        ELSEIF(ISPIN.LE.2)THEN
         CALL SYMTR1(IRREPZL,VRT(1,ISPIN),POP(1,ISPIN),DISSYZ,
     &               ICORE(I000),ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
        ENDIF
        CALL GETLST(ICORE(I010),1,NUMDSZ,1,IRREPZL,LISTZ)
CSSS        call checksum("Z :",ICORE(I010),NUMDSZ*DISSYZ) 
        CALL SAXPY (DISSYZ*NUMDSZ,ONE,ICORE(I010),1,ICORE(I000),1)
CSSS        call checksum("Z+T :",ICORE(I000),NUMDSZ*DISSYZ) 
        CALL PUTLST(ICORE(I000),1,NUMDSZ,1,IRREPZL,LISTZ)

20     CONTINUE
C
10    CONTINUE
C
      RETURN
      END
