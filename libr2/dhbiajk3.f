      SUBROUTINE DHBIAJK3(ICORE,MAXCOR,IUHF,IRREPT,IRREPW,LISTT,
     &                    LSTWAAAA,LSTWBBBB,LSTWABAB,LSTWBABA,
     &                    LSTWBAAB,LSTWABBA,LISTZ0,SWITCH)
C
C CALCULATES THE CONTRACTION 
C
C    Z(IA,JK) = T(EJ) * W(IA,EK) - T(EI) * W(JA,EK)
C
C FOR EITHER DIFFERENTIATED OR UNDIFFERENTIATED INTEGRALS
C
C
C CONTRACTION :  Z(IA,JK) <= T(EJ)*W(IA,EK) + ASSYM2 [ISPIN=1,2]
C                Z(iA,jK) <= T(ej)*W(iA,eK) - T(EK)*W(iA,Ej) [ISPIN=3]
C                Z(Ia,Jk) <= T(EJ)*W(Ia,Ek) - T(ek)*W(Ia,eJ) [ISPIN=4]
C          
C
C THIS ROUTINE ASSUMES THAT THE W(IA,EK) ELEMENTS, WHICH ARE USUALLY
C STORED AS W(EI,AK) HAVE BEEN RESORTED TO W(EK,AI)
C
CEND
      IMPLICIT INTEGER (A-Z)
      DIMENSION ICORE(MAXCOR),I0T(2)
      LOGICAL SWITCH
      DOUBLE PRECISION ONE,ONEM,ZILCH,X
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/SYMINF/NSTART,NIRREP,IRREPY(255,2),DIRPRD(8,8)
      COMMON/SYMLOC/ISYMOFF(8,8,25)
C
      DATA ONE,ONEM,ZILCH /1.0D0,-1.0D0,0.0D0/
C
      IF(SWITCH)THEN
       X=ONEM
      ELSE
       X=ONE
      ENDIF
C
      IRREPZ=DIRPRD(IRREPT,IRREPW)
      I0T(1)=1
      I0T(2)=I0T(1)+IINTFP*IRPDPD(IRREPT,9)*IUHF
      I000  =I0T(2)+IINTFP*IRPDPD(IRREPT,10)
      CALL GETLST(ICORE(I0T(1)),1,1,1,1,LISTT)
      IF(IUHF.NE.0)CALL GETLST(ICORE(I0T(2)),1,1,1,2,LISTT)
C
C DO AAAA AND BBBB SPIN CASES FOR UHF ONLY
C
      IF(IUHF.NE.0)THEN
       DO 10 ISPIN=1,2
        LISTW=LSTWAAAA+(ISPIN-1)
        LISTZ=LISTZ0+ISPIN
        DO 20 IRREPZL=1,NIRREP
         IRREPZR=DIRPRD(IRREPZL,IRREPZ)
         IRREPWL=IRREPZL
         IRREPWR=DIRPRD(IRREPWL,IRREPW)
         DISSYZ=IRPDPD(IRREPZR,ISYTYP(1,LISTZ))
         NUMDSZ=IRPDPD(IRREPZL,ISYTYP(2,LISTZ))
         DISSYZX=IRPDPD(IRREPZR,20+ISPIN)
         DISSYW=IRPDPD(IRREPWR,ISYTYP(1,LISTW))
         NUMDSW=IRPDPD(IRREPWL,ISYTYP(2,LISTW))
         MAXTMP=MAX(DISSYW,NUMDSW,DISSYZX,NUMDSZ)
         I010=I000+IINTFP*MAX(DISSYZX*NUMDSZ,DISSYW*NUMDSW)
         I020=I010+IINTFP*MAX(DISSYW*NUMDSW,DISSYZ*NUMDSZ)
         ITMP1=I020
         ITMP2=ITMP1+IINTFP*MAXTMP
         ITMP3=ITMP2+IINTFP*MAXTMP
C
C READ W(EK,AI) AND REORDER TO W(AI,KE)
C
         CALL GETLST(ICORE(I000),1,NUMDSW,1,IRREPWL,LISTW)
CSSS         Call checksum("TWW",ICORE(I000),NUMDSW*DISSYW)
         CALL TRANSP(ICORE(I000),ICORE(I010),NUMDSW,DISSYW)
         CALL SYMTR1(IRREPWR,VRT(1,ISPIN),POP(1,ISPIN),NUMDSW,
     &               ICORE(I010),ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
C
C CALCULATE Z(AI,KJ) <= W(AI,KE) * T(EJ)
C
         DO 30 IRREPJ=1,NIRREP
          IRREPE=DIRPRD(IRREPJ,IRREPT)
          IRREPK=DIRPRD(IRREPE,IRREPWR)
          NUMJ=POP(IRREPJ,ISPIN)
          NUMK=POP(IRREPK,ISPIN)
          NUME=VRT(IRREPE,ISPIN)
          NROW=NUMDSZ*NUMK
          NCOL=NUMJ
          NSUM=NUME
          IOFFZ=I000+IINTFP*NUMDSZ*(ISYMOFF(IRREPJ,IRREPZR,20+ISPIN)-1)
          IF (MIN(NROW,NCOL,NSUM).NE.0) THEN
             IOFFT=I0T(ISPIN)+IINTFP*(ISYMOFF(IRREPJ,IRREPT,8+ISPIN)-1) 
             IOFFW=I010
     &            +IINTFP*NUMDSW*(ISYMOFF(IRREPE,IRREPWR,15+ISPIN)-1)
             CALL XGEMM('N','N',NROW,NCOL,NSUM,X*ONE,ICORE(IOFFW),NROW,
     &                  ICORE(IOFFT),NUME,ZILCH,ICORE(IOFFZ),NROW)
          ELSE
             CALL DZERO(ICORE(IOFFZ),NROW*NCOL)
          END IF
30       CONTINUE
C
C NOW ANTISYMMETRIZE ON KJ, TRANSPOSE AND WRITE TO DISK
C
         CALL ASSYM2(IRREPZR,POP(1,ISPIN),NUMDSZ,ICORE(I000))
         CALL TRANSP(ICORE(I000),ICORE(I010),DISSYZ,NUMDSZ)
         CALL SYMTR1(IRREPZL,VRT(1,ISPIN),POP(1,ISPIN),DISSYZ,
     &               ICORE(I010),ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
         CALL GETLST(ICORE(I000),1,NUMDSZ,1,IRREPZL,LISTZ)
         CALL SAXPY (NUMDSZ*DISSYZ,ONE,ICORE(I010),1,ICORE(I000),1)
         CALL PUTLST(ICORE(I000),1,NUMDSZ,1,IRREPZL,LISTZ)
C
20      CONTINUE
C
10     CONTINUE
C
      ENDIF
C
C NOW DO SPIN CASES 4 AND 3
C
      DO 110 ISPIN=4,4-IUHF,-1
       LISTZ=LISTZ0+ISPIN
C
       DO 120 IRREPZL=1,NIRREP
        IRREPZR=DIRPRD(IRREPZL,IRREPZ)
        IRREPWL=IRREPZL
        IRREPWR=DIRPRD(IRREPWL,IRREPW)
        DISSYZ=IRPDPD(IRREPZR,ISYTYP(1,LISTZ))
        NUMDSZ=IRPDPD(IRREPZL,ISYTYP(2,LISTZ))
        I010=I000+IINTFP*DISSYZ*NUMDSZ
C
C FIRST CONTRACTION:
C
C                 T(ej)*W(iA,eK) [ISPIN=3, W STORED AS ON LIST 57]
C                 T(EJ)*W(Ia,Ek) [ISPIN=4, W STORED AS ON LIST 56]
C
        IF(ISPIN.EQ.3)THEN
         LISTW=LSTWBABA
        ELSE
         LISTW=LSTWABAB
        ENDIF
        DISSYW=IRPDPD(IRREPWR,ISYTYP(1,LISTW))
        NUMDSW=IRPDPD(IRREPWL,ISYTYP(2,LISTW))
        MAXTMP=MAX(DISSYW,NUMDSW,DISSYZ,NUMDSZ)
        I010=I000+IINTFP*MAX(DISSYZ*NUMDSZ,DISSYW*NUMDSW)
        I020=I010+IINTFP*DISSYW*NUMDSW
        ITMP1=I020
        ITMP2=ITMP1+IINTFP*MAXTMP
        ITMP3=ITMP2+IINTFP*MAXTMP
C
C READ W(ek,ai) AND REORDER TO W(ai,ke)
C
        CALL GETLST(ICORE(I000),1,NUMDSW,1,IRREPWL,LISTW)
CSSS         Call checksum("TWW",ICORE(I000),NUMDSW*DISSYW)
        CALL TRANSP(ICORE(I000),ICORE(I010),NUMDSW,DISSYW)
        CALL SYMTR1(IRREPWR,VRT(1,5-ISPIN),POP(1,ISPIN-2),NUMDSW,
     &              ICORE(I010),ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
C
C CALCULATE       
C
C                Z(Ai,Kj) = W(Ai,Ke) * T(ej)  [ISPIN=3]
C                Z(aI,kJ) = W(Ia,kE) * T(EJ)  [ISPIN=4]
C
        ISPINT=5-ISPIN
        WTYPE =18+(ISPIN-3)*7
        ZTYPE =14+(ISPIN-3)*10
        DO 130 IRREPJ=1,NIRREP
         IRREPE=DIRPRD(IRREPJ,IRREPT)
         IRREPK=DIRPRD(IRREPE,IRREPWR)
         NUMJ=POP(IRREPJ,ISPINT)
         NUME=VRT(IRREPE,ISPINT)
         NUMK=POP(IRREPK,3-ISPINT)
         NROW=NUMDSZ*NUMK
         NCOL=NUMJ
         NSUM=NUME
         IOFFZ=I000+IINTFP*NUMDSZ*(ISYMOFF(IRREPJ,IRREPZR,ZTYPE)-1) 
         IF (MIN(NROW,NCOL,NSUM).NE.0) THEN
            IOFFT=I0T(ISPINT)+IINTFP*(ISYMOFF(IRREPJ,IRREPT,8+ISPINT)-1)
            IOFFW=I010+IINTFP*NUMDSW*(ISYMOFF(IRREPE,IRREPWR,WTYPE)-1)
            CALL XGEMM('N','N',NROW,NCOL,NSUM,X*ONE,ICORE(IOFFW),NROW,
     &                 ICORE(IOFFT),NSUM,ZILCH,ICORE(IOFFZ),NROW)
         ELSE
            CALL DZERO(ICORE(IOFFZ),NROW*NCOL)
         END IF
130     CONTINUE
C
C TRANSPOSE K AND J FOR NEXT CONTRACTION
C
        CALL SYMTR1(IRREPZR,POP(1,3-ISPINT),POP(1,ISPINT),NUMDSZ,
     &              ICORE(I000),ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
C
C SECOND CONTRACTION:
C
C               -  T(EK)*W(iA,Ej) [ISPIN=3, W STORED AS ON LIST 58]
C               -  T(ek)*W(Ia,eJ) [ISPIN=4, W STORED AS ON LIST 59]
C
        IF(ISPIN.EQ.3.OR.IUHF.EQ.0)THEN
         LISTW=LSTWBAAB
        ELSE
         LISTW=LSTWABBA
        ENDIF
        DISSYW=IRPDPD(IRREPWR,ISYTYP(1,LISTW))
        NUMDSW=IRPDPD(IRREPWL,ISYTYP(2,LISTW))
        MAXTMP=MAX(DISSYW,NUMDSW,DISSYZ,NUMDSZ)
        I010=I000+IINTFP*MAX(DISSYZ*NUMDSZ,DISSYW*NUMDSW)
        I020=I010+IINTFP*MAX(DISSYW*NUMDSW,DISSYZ*NUMDSZ)
        ITMP1=I020
        ITMP2=ITMP1+IINTFP*MAXTMP
        ITMP3=ITMP2+IINTFP*MAXTMP
C
C READ W(Ej,Ai) AND REORDER TO W(Ai,jE) [ISPIN=3]
C READ W(eJ,aI) AND REORDER TO W(aI,Je) [ISPIN=4] 
C
        CALL GETLST(ICORE(I020),1,NUMDSW,1,IRREPWL,LISTW)
CSSS        Call checksum("TWW",ICORE(I020),NUMDSW*DISSYW)
        CALL TRANSP(ICORE(I020),ICORE(I010),NUMDSW,DISSYW)
        CALL SYMTR1(IRREPWR,VRT(1,ISPIN-2),POP(1,5-ISPIN),NUMDSW,
     &              ICORE(I010),ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
C
C CALCULATE       
C
C                Z(Ai,jK) = W(Ai,jE) * T(EK)  [ISPIN=3]
C                Z(aI,Jk) = W(aI,Je) * T(ek)  [ISPIN=4]
C
        ISPINT=ISPIN-2
        ZTYPE =24-(ISPIN-3)*10
        WTYPE =25-(ISPIN-3)*7
        DO 140 IRREPK=1,NIRREP
         IRREPE=DIRPRD(IRREPK,IRREPT)
         IRREPJ=DIRPRD(IRREPE,IRREPWR)
         NUMJ=POP(IRREPJ,3-ISPINT)
         NUME=VRT(IRREPE,ISPINT)
         NUMK=POP(IRREPK,ISPINT)
         NROW=NUMDSZ*NUMJ
         NCOL=NUMK
         NSUM=NUME
         IF (MIN(NROW,NCOL,NSUM).NE.0) THEN
            IOFFT=I0T(ISPINT)+IINTFP*(ISYMOFF(IRREPK,IRREPT,8+ISPINT)-1)
            IOFFW=I010+IINTFP*NUMDSW*(ISYMOFF(IRREPE,IRREPWR,WTYPE)-1)
            IOFFZ=I000+IINTFP*NUMDSZ*(ISYMOFF(IRREPK,IRREPZR,ZTYPE)-1) 
            CALL XGEMM('N','N',NROW,NCOL,NSUM,X*ONE,ICORE(IOFFW),NROW,
     &                 ICORE(IOFFT),NSUM,ONE,ICORE(IOFFZ),NROW)
         END IF
140     CONTINUE
C
C NOW:  Z(Ai,jK) => Z(jK,Ai) => Z(Kj,Ai) [ISPIN=3]
C       Z(aI,Jk) => Z(Jk,aI) => Z(Jk,Ia) [ISPIN=4]
C
        CALL TRANSP(ICORE(I000),ICORE(I010),DISSYZ,NUMDSZ)
        IF(ISPIN.EQ.3)THEN
         CALL SYMTR3(IRREPZR,POP(1,2),POP(1,1),DISSYZ,NUMDSZ,
     &               ICORE(I010),ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
        ELSE
         CALL SYMTR1(IRREPZL,VRT(1,2),POP(1,1),DISSYZ,ICORE(I010),
     &               ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
        ENDIF
C
        CALL GETLST(ICORE(I000),1,NUMDSZ,1,IRREPZL,LISTZ)
        CALL SAXPY (NUMDSZ*DISSYZ,ONE,ICORE(I010),1,ICORE(I000),1)
        CALL PUTLST(ICORE(I000),1,NUMDSZ,1,IRREPZL,LISTZ)
C   
120    CONTINUE
C
110   CONTINUE
C
      RETURN
      END
