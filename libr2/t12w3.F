      SUBROUTINE T12W3(W,Z,SCR,T1A,T1B,DISSYW,DISSYZ,DISTMP,NUMSYW,
     &                 NUMSYZ,NUMTMP,NOCCSQ,POP1,POP2,VRT1,VRT2,
     &                 LISTW,LISTZ,FACT,IRREP,IUHF,MXCOR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL bRedundant
      INTEGER DISSYW,DISSYZ,DISTMP,DIRPRD,POP1,POP2,VRT1,VRT2
      DIMENSION W(DISSYW,NUMSYW),Z(DISTMP,NUMSYZ),T1A(1),T1B(1),
     &          POP1(8),POP2(8),VRT1(8),VRT2(8), SCR(MXCOR)
C     
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),
     &                DIRPRD(8,8)
      COMMON /FLAGS2/IFLAGS2(500)
      integer         iintln, ifltln, iintfp, ialone, ibitwd
      common /machsp/ iintln, ifltln, iintfp, ialone, ibitwd
C 
      DATA AZERO,ONE /0.D0,1.D0/

      bRedundant = IFLAGS2(155).EQ.0
C
C IF THE SIZE OF THE TARGET ARRAY IS ZERO, RETURN
C
      IF(MIN(NUMSYZ,DISSYZ).EQ.0) RETURN
C
C GET INTEGRALS AND TRANSPOSE LAST TWO INDICES
C
c      IF(bRedundant .AND. (LISTW.LT.17 .OR. LISTW .GT. 22)) THEN
      IF(bRedundant) THEN
         CALL GETLST(Z,1,NUMSYW,2,IRREP,LISTW)
      ELSE
         CALL GETLST_NR(Z,SCR,MXCOR*IINTFP,LISTW,IRREP)
      ENDIF
      CALL SYMTRA(IRREP,VRT2,POP1,DISSYW,Z,W)
C
C ZERO TARGET ARRAY
C
      CALL ZERO(Z,DISTMP*NOCCSQ)
C
C PERFORM FIRST MULTIPLICATION
C
      IOFFT=1
      IOFFZ=1
      IOFFW=1
      DO 100 IRREPJ=1,NIRREP
       NVRTJ=VRT2(IRREPJ)
       NOCCJ=POP2(IRREPJ)
       IRREPI=DIRPRD(IRREPJ,IRREP)
       NOCCI=POP1(IRREPI) 
       IF(NOCCI.NE.0.AND.NOCCJ.NE.0.AND.NVRTJ.NE.0) THEN
C
        CALL XGEMM('N','N',DISSYW*NOCCI,NOCCJ,NVRTJ,ONE,W(1,IOFFW),
     &             DISSYW*NOCCI,T1A(IOFFT),NVRTJ,AZERO,Z(1,IOFFZ),
     &             DISSYW*NOCCI)
       ENDIF
       IOFFT=IOFFT+NOCCJ*NVRTJ
       IOFFZ=IOFFZ+NOCCJ*NOCCI
       IOFFW=IOFFW+NOCCI*NVRTJ
100   CONTINUE
C
C TRANSPOSE AGAIN LAST TWO INDICES
C
      CALL SYMTRA(IRREP,POP1,POP2,DISSYW,Z,W)
C
C ZERO TARGET ARRAY
C
      CALL ZERO(Z,NUMSYZ*DISSYZ)
C
C PERFORM SECOND MULTIPLICATION
C
      IOFFT=1
      IOFFW=1
      IOFFZ=1
      DO 200 IRREPJ=1,NIRREP
       NVRTJ=VRT1(IRREPJ)
       NOCCJ=POP1(IRREPJ)
       IRREPI=DIRPRD(IRREPJ,IRREP)
       NOCCI=POP2(IRREPI)
       IF(NOCCI.NE.0.AND.NOCCJ.NE.0.AND.NVRTJ.NE.0) THEN
C
        CALL XGEMM('N','T',DISSYW*NOCCI,NVRTJ,NOCCJ,FACT,W(1,IOFFW),
     &             DISSYW*NOCCI,T1B(IOFFT),NVRTJ,AZERO,Z(1,IOFFZ),
     &             DISSYW*NOCCI)
       ENDIF
       IOFFT=IOFFT+NOCCJ*NVRTJ
       IOFFZ=IOFFZ+NOCCI*NVRTJ
       IOFFW=IOFFW+NOCCI*NOCCJ
200   CONTINUE
C
C TRANSPOSE AGAIN THE LAST TWO INDICES 
C
      CALL SYMTRA(IRREP,POP2,VRT1,DISSYW,Z,W)
C 
C  UPDATE W(TWIDDLE) ON LISTZ
C
      CALL GETLST(Z,1,NUMSYZ,1,IRREP,LISTZ)
      CALL VADD(Z,Z,W,NUMSYZ*DISSYZ,ONE)
      CALL PUTLST(Z,1,NUMSYZ,1,IRREP,LISTZ)
   

CSSS     CALL GETLST(Z,1,NUMSYW,2,IRREP,LISTW)
CSSS     CALL SYMTRA(IRREP,VRT2,POP1,DISSYW,W,Z)
cSSS     CALL GETLST(Z,1,NUMSYZ,1,IRREP,LISTZ)
CSSS     CALL DAXPY(NUMSYZ*DISSYZ,-1.0D0, W, 1, Z, 1)
CSSS     CALL PUTLST(Z,1,NUMSYZ,1,IRREP,LISTZ)
C
      RETURN
      END
