       SUBROUTINE FORMV1(ICORE,MAXCOR,IUHF)
C
C THIS ROUTINE COMPUTES :
C
C       1/2 SUM E,F TAU(MN,EF) L(IJ,EF)
C
C     NOT  FOR MBPT(4) AND UCC   L(IJ,EF) = T(IJ,EF)
C
C THE MULTIPLICATION IS CARRIED OUT USING SYMMETRY
C AND THE RESULTING PRODUCT ARRAY IS STORED IN A 
C SYMMETRY ADAPTED WAY
C
C NOTE  ISPIN = 1   .... H3(MN,EF) (UHF ONLY)
C       ISPIN = 2   .... H3(mn,ef) (UHF ONLY)
C       ISPIN = 3   .... H3(Mn,Ef) (RHF AND UHF)
C
C FOR CCSD METHODS THE T2 AMPLITUDES HAVE TO BE SUBSTITUTED
C BY THE TAU AMPLITUDES
C
CEND
C
C CODED JG AUGUST/90
C 
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DIRPRD,DISSYL,DISSYT,POP1,POP2,VRT1,VRT2
      LOGICAL MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC
      LOGICAL TAU,ISAME,MBPT4,CC2
      DIMENSION ICORE(MAXCOR)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /METH/MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC,
     &             CC2
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),
     &DIRPRD(8,8)
      COMMON /SYM/ POP1(8),POP2(8),VRT1(8),VRT2(8),NTAA,NTBB,
     &             NF1AA,NF1BB,NF2AA,NF2BB
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),NTOT(18)
C
      MXCOR=MAXCOR
      MBPT4=M4DQ.OR.M4SDQ.OR.M4SDTQ.OR.UCC
      TAU=.FALSE.
      IF(CCSD .OR.CC2) THEN
C
C   ALLOCATE CORE MEMORY FOR T1 AMPLITUDES
C
      I0TA=MXCOR+1-NTAA*IINTFP
      MXCOR=MXCOR-NTAA*IINTFP
      IF(IUHF.EQ.0) THEN
       I0TB=I0TA
      ELSE
       I0TB=I0TA-NTBB*IINTFP
       MXCOR=MXCOR-NTBB*IINTFP
      ENDIF
      CALL GETLST(ICORE(I0TA),1,1,1,1,90)
      IF(IUHF.EQ.1) CALL GETLST(ICORE(I0TB),1,1,1,2,90)
      TAU=.TRUE.
      ENDIF
C     
      IF(IUHF.EQ.1) THEN
C
C      AAAA AND BBBB SPIN CASES
C
      DO 1000 ISPIN=1,2   
C
       IF(ISPIN.EQ.1) THEN
        I0T=I0TA
       ELSE
        I0T=I0TB
       ENDIF
C
       LISTT=ISPIN+43
       IF(MBPT4) THEN
        ISAME=.TRUE.
        LISTL=LISTT
       ELSE
        ISAME=.FALSE.
        LISTL=ISPIN+143
       ENDIF
C
C LOOP OVER IRREPS.
C
       DO 100 IRREP=1,NIRREP
C
C RETRIEVE INTEGRALS AND T2 AMPLITUDES.
C
        DISSYL=IRPDPD(IRREP,ISYTYP(1,LISTL))
        DISSYT=IRPDPD(IRREP,ISYTYP(1,LISTT))
        NUMSYL=IRPDPD(IRREP,ISYTYP(2,LISTL))
        NUMSYT=IRPDPD(IRREP,ISYTYP(2,LISTT))
        I001=1
        I002=I001+IINTFP*NUMSYL*DISSYL
        I003=I002+IINTFP*NUMSYT*DISSYT
        IF(MIN(NUMSYT,NUMSYL,DISSYT,DISSYL).NE.0)THEN
         I004=I003+IINTFP*NUMSYT*NUMSYL
         I005=I004+IINTFP*MAX(DISSYT,DISSYL)
         IF(I005.LT.MXCOR) THEN
C  
C         IN CORE VERSION
C
          CALL V1ALL(ICORE(I001),ICORE(I002),ICORE(I003),ICORE(I0T),
     &               ICORE(I0T),ISPIN,TAU,ISAME,DISSYL,DISSYT,NUMSYL,
     &               NUMSYT,LISTL,LISTT,IRREP,ICORE(I004))
         ELSE
C
C         OUT OF CORE VERSION
C
          CALL INSMEM('V1ALL ',I005,MXCOR)
         ENDIF
C
        ELSE
        ENDIF
100    CONTINUE
1000   CONTINUE
      ENDIF
C
C       AB SPIN CASE
C
       LISTT=46
       IF(MBPT4) THEN
        LISTL=LISTT
        ISAME=.TRUE.
       ELSE
        LISTL=146
        ISAME=.FALSE.
       ENDIF
C
C      LOOP OVER IRREPS.
C
       DO 110 IRREP=1,NIRREP
C
C     RETRIEVE INTEGRALS AND T2 AMPLITUDES
C
        DISSYL=IRPDPD(IRREP,ISYTYP(1,LISTL))
        DISSYT=IRPDPD(IRREP,ISYTYP(1,LISTT))
        NUMSYL=IRPDPD(IRREP,ISYTYP(2,LISTL))
        NUMSYT=IRPDPD(IRREP,ISYTYP(2,LISTT))
        I001=1
        I002=I001+IINTFP*NUMSYL*DISSYL
        I003=I002+IINTFP*NUMSYT*DISSYT
        IF(MIN(NUMSYT,NUMSYL,DISSYT,DISSYL).NE.0)THEN
         I004=I003+IINTFP*NUMSYT*NUMSYL
         I005=I004+IINTFP*MAX(DISSYT,DISSYL)
         IF(I005.LT.MXCOR) THEN
C
C         IN CORE VERSION
C
          CALL V1ALL(ICORE(I001),ICORE(I002),ICORE(I003),ICORE(I0TA),
     &               ICORE(I0TB),3,TAU,ISAME,DISSYL,DISSYT,NUMSYL,
     &               NUMSYT,LISTL,LISTT,IRREP,ICORE(I005))
         ELSE
C
          CALL INSMEM('V1ALL ',I005,MXCOR)
C
         ENDIF
        ELSE
        ENDIF
110    CONTINUE
C
      RETURN
      END
