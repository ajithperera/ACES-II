      SUBROUTINE H4ALL(ICORE,MAXCOR,SPCASE,IUHF)
C
C  THIS ROUTINE COMPUTES THE RING-TYPE H(ME,JB)
C  INTERMEDIATE FOR ALL SIX POSSIBLE SPIN CASES.  THE ALGORITHM
C  ASSUMES IN-CORE STORAGE OF SYMMETRY PACKED TARGET AND T2 LISTS
C  VECTORS AND USES THE DPD SYMMETRY APPROACH TO EVALUATE THE
C  CONTRACTIONS.
C
CEND
C
C  CODED AUGSUT/90  JG
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL ISAME
      LOGICAL MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC
      LOGICAL CC,MBPT4,bRedundant
      INTEGER DIRPRD,DISSYG,DSSYT1A,DSSYT2A,DSSYT1B,DSSYT2B,
     &        DSSYT1,DSSYT2,DSSYT3A,DSSYT3B,DSSYT4A,DSSYT4B,
     &        DISSYG2  
      CHARACTER*4 SPCASE
      DIMENSION ICORE(MAXCOR)
      COMMON /METH/MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /FILES/ LUOUT,MOINTS
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),
     &                DIRPRD(8,8)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),NTOT(18)
      COMMON /FLAGS2/IFLAGS2(500)
C
      DATA AZERO,HALF,ONE,ONEM,TWO /0.0D+0,0.5D0,1.0D+0,-1.D+0,2.D0/
#include "parcc.com"
C
      MBPT4=M4DQ.OR.M4SDQ.OR.M4SDTQ.OR.UCC
      CC=CCD.OR.CCSD.OR.QCISD
C
      bRedundant = IFLAGS2(155).EQ.0
C
C DO SPIN CASE AAAA AND BBBB:
C
C  MBPT(4) :    H(MEJB) =  SUM N,F T1(MN,EF) T1(NJ,FB) 
C                                   + T1(Mn,Ef) T1(Jn,Fb)
C
C  STORAGE MODE :   EM,BJ    ACTUALLY  = T1(MN,FE) T1(NJ,BF)
C                                  STORAGE HERE   EM,NF AND NF, BJ
C                                  SIGN = ONE  * -1 --> ONEM
C                            T1(Mn,Ef) T1(Jn,Bf)  STORAGE HERE BJ nf
C                                   SIGN = ONE * -1 --> ONEM
C  AAAA :     UHF ONLY
C
C  BBBB :     UHF ONLY           
C
C  THE ADDITIONAL TERM FOR QCISD AND CCSD IS
C
C  H(MEJB) = TWO L(M,E) T(I,A)
C
C   THE SIGN IS HERE ONE  * -1   --> ONEM
C
C   THE FACTOR OF TWO IS TAKEN INTO ACCOUT BY MULTIPLYING ALL PREVIOUS
C   TERMS BY HALF
C
      IF(SPCASE.EQ.'AAAA'.OR.SPCASE.EQ.'BBBB')THEN
       IF(SPCASE.EQ.'AAAA')THEN
        ISPIN=1
       ELSEIF(SPCASE.EQ.'BBBB')THEN
        ISPIN=2
       ENDIF
       MAXSIZ=0
       LISTG =53+ISPIN
       IF(MBPT4) THEN
        ISAME=.TRUE.
        FACT=ONEM
        LIST1A=33+ISPIN
        LIST2A=33+ISPIN
        LIST1B=38-ISPIN
        LIST2B=38-ISPIN
       ELSE IF(CC) THEN
        LIST1A=133+ISPIN
        LIST2A=33+ISPIN
        LIST1B=138-ISPIN
        LIST2B=38-ISPIN
        ISAME=.FALSE.
        FACT=ONEM
       ENDIF
       DO 100 IRREP=1,NIRREP 
        DSSYT1A=IRPDPD(IRREP,ISYTYP(1,LIST1A))
        DSSYT2A=IRPDPD(IRREP,ISYTYP(1,LIST2A))
        NMSYT1A=IRPDPD(IRREP,ISYTYP(2,LIST1A))
        NMSYT2A=IRPDPD(IRREP,ISYTYP(2,LIST2A))
        DSSYT1B=IRPDPD(IRREP,ISYTYP(1,LIST1B))
        DSSYT2B=IRPDPD(IRREP,ISYTYP(1,LIST2B))
        NMSYT1B=IRPDPD(IRREP,ISYTYP(2,LIST1B))
        NMSYT2B=IRPDPD(IRREP,ISYTYP(2,LIST2B))
        DISSYG=IRPDPD(IRREP,ISYTYP(1,LISTG))
        NUMSYG=IRPDPD(IRREP,ISYTYP(2,LISTG))

C
C FIRST TERM
C
        I000=1
        I010=I000+IINTFP*DISSYG*NUMSYG
        IF(ISAME) THEN
         I020=I010
        ELSE
         I020=I010+IINTFP*NMSYT1A*DSSYT1A
        ENDIF
        I030=I020+IINTFP*NMSYT2A*DSSYT2A
        IF(MAXCOR.LT.I030) CALL INSMEM('H4ALL ',I030,MAXCOR)
        CALL IZERO(ICORE(I000),DISSYG*NUMSYG*IINTFP)

        IF(bRedundant) THEN
           CALL GETLST(ICORE(I010),1,NMSYT1A,1,IRREP,LIST1A)
           IF(.NOT.ISAME) CALL GETLST(ICORE(I020),1,NMSYT2A,2,IRREP,
     &                                LIST2A)
        ELSE
           CALL GETLST_NR(ICORE(I010),ICORE(I020),MAXCOR-I020, LIST1A,
     &                   IRREP)
           IF(.NOT.ISAME) CALL GETLST_NR(ICORE(I020),ICORE(I030),
     &                   MAXCOR-I030, LIST2A, IRREP)
        ENDIF

c        call chksums("H4ALL 1 ",icore(i010),nmsyt1a*dssyt1a)
c        call chksums("H4ALL 1 ",icore(i020),nmsyt2a*dssyt2a)

        CALL XGEMM('N','N',DISSYG,NUMSYG,DSSYT2A,FACT,ICORE(I010),
     &             DSSYT1A,ICORE(I020),DSSYT2A,AZERO,ICORE(I000),
     &             DISSYG)
C
C SECOND TERM
C
        IF(ISAME) THEN
         I020=I010
        ELSE
         I020=I010+IINTFP*NMSYT1B*DSSYT1B
        ENDIF
        I030=I020+IINTFP*NMSYT2B*DSSYT2B
        IF(bRedundant) THEN
           CALL GETLST(ICORE(I010),1,NMSYT1B,1,IRREP,LIST1B)
           IF(.NOT.ISAME) CALL GETLST(ICORE(I020),1,NMSYT2B,2,IRREP,
     &                                LIST2B)
        ELSE
          CALL GETLST_NR(ICORE(I010),ICORE(I020),MAXCOR-I020, LIST1B,
     &                   IRREP)
          IF(.NOT.ISAME) CALL GETLST_NR(ICORE(I020),ICORE(I030),
     &                   MAXCOR-I030, LIST2B, IRREP)
        ENDIF

c        call chksums("H4ALL 2 ",icore(i010),nmsyt1b*dssyt1b)
c        call chksums("H4ALL 2 ",icore(i020),nmsyt2b*dssyt2b)

        CALL XGEMM('N','T',DISSYG,NUMSYG,NMSYT2B,FACT,ICORE(I010),
     &             DSSYT1B,ICORE(I020),DSSYT2B,ONE,ICORE(I000),
     &             DISSYG)
C
C  SAVE H4 INTERMEDIATE ON DISK
C
        CALL PUTLST(ICORE(I000),1,NUMSYG,2,IRREP,LISTG)
CSSS        CALL Checksum(SPCASE,ICORE(I000), NUMSYG*DISSYG)
100    CONTINUE
C
C DO SPIN CASES ABBA AND BAAB:
C
C MBPT(4) :  H(MEjb) =  SUM N,F T1(MN,EF) T1(jN,bF) + T1(Mn,Ef) T1(jn,bf)
C
C  THIS CORRESPONDS TO <Ia//jB> = <Ia/jB> = - <Ij//Ba> (LIST 18)
C
C STORAGE : EM,bj (ACTUALLY HERE WE ARE INTERESTED IN THE NEGATIVE OF
C                  THIS TERM (<Ia//jB> =  - <Ia//Bj> = - <Ba//Ij>)
C
C      ACTUALLY T1(MN,EF) T1(jN,bF) = - T1(MN,FE) T1(Nj,Fb)
C
C      STORAGE    EM, FN ; FN, bj    OVERALL SIGN :  ONE * -1 --> ONEM
C
C      ACTUALLY  T1(Mn,Ef) T1(jn,bf) = - T1(Mn,Ef) T1(jn,fb)
C
C      STORAGE    EM, nf ;  nf,  jb   OVERALL SIGN : ONE * -1 --> ONEM
C
C  NOTE THE SECOND TERM IS FOR MBPT(4)  IN RHF  TRANSPOSITION OF THE
C  FIRST TERM AND THEREFORE NOT REQUIRED
C
C  ALSO AT LEAST FOR MBPT(4)  ONLY THE ABAB CASE IS REQUIRED, SINCE
C  WE HAVE SYMMETRY WITH RESPECT TO THE INDICES
C
C FOR ALL OTHER CASES : RHF CASE : CALCULATE ONLY ABBA
C                       UHF CASE : CALCULATE ABBA AND BAAB
C    
C  THE ADDITIONAL TERMS FOR QCISD AND CCSD ARE
C
C   TWO    L(M,E) T(j,b)     OVERALL SIGN ONEM BECAUSE OF THE SIGN REVERSAL
C                                   * -1  ---> ONE
C   
C   DISCUSSED ABOVE, THE FACTOR TWO IS EQUIVALENT TO MULTIPLYING ALL
C   PREVIOUS TERMS BY HALF
C
      ELSEIF(SPCASE.EQ.'ABBA'.OR.SPCASE.EQ.'BAAB')THEN
       IF(SPCASE.EQ.'ABBA')THEN
        LISTG=56
        IF(MBPT4) THEN
        FACT=ONEM
        LIST1A=34
        LIST2A=37
        LIST1B=37
        LIST2B=34+IUHF
        ELSE IF(CC) THEN
         FACT=ONEM
         LIST1A=134
         LIST2A=37
         LIST1B=137
         LIST2B=34+IUHF
        ENDIF
       ENDIF
       IF(SPCASE.EQ.'ABBA'.AND.IUHF.EQ.1.AND.CC)THEN 
        LISTG2=57
        FACT=ONEM
        LIST3A=135
        LIST4A=36
        LIST3B=136
        LIST4B=34
       ENDIF

       DO 200 IRREP=1,NIRREP 
        DSSYT1A=IRPDPD(IRREP,ISYTYP(1,LIST1A))
        DSSYT2A=IRPDPD(IRREP,ISYTYP(1,LIST2A))
        NMSYT1A=IRPDPD(IRREP,ISYTYP(2,LIST1A))
        NMSYT2A=IRPDPD(IRREP,ISYTYP(2,LIST2A))
        DSSYT1B=IRPDPD(IRREP,ISYTYP(1,LIST1B))
        DSSYT2B=IRPDPD(IRREP,ISYTYP(1,LIST2B))
        NMSYT1B=IRPDPD(IRREP,ISYTYP(2,LIST1B))
        NMSYT2B=IRPDPD(IRREP,ISYTYP(2,LIST2B))
        DISSYG=IRPDPD(IRREP,ISYTYP(1,LISTG))
        NUMSYG=IRPDPD(IRREP,ISYTYP(2,LISTG))
C
C  FIRST TERM
C
        I000=1
        I010=I000+IINTFP*DISSYG*NUMSYG
        I020=I010+IINTFP*NMSYT1A*DSSYT1A
        I030=I020+IINTFP*NMSYT2A*DSSYT2A
        CALL IZERO(ICORE(I000),DISSYG*NUMSYG*IINTFP)

        IF(bRedundant) THEN
           CALL GETLST(ICORE(I020),1,NMSYT2A,1,IRREP,LIST2A)
           CALL GETLST(ICORE(I010),1,NMSYT1A,1,IRREP,LIST1A)
        ELSE
           CALL GETLST_NR(ICORE(I020),ICORE(I030),MAXCOR-I030, LIST2A,
     &                   IRREP)
           CALL GETLST_NR(ICORE(I010),ICORE(I030),MAXCOR-I030, LIST1A,
     &                   IRREP)
        ENDIF

        CALL XGEMM('N','N',DISSYG,NUMSYG,DSSYT2A,FACT,ICORE(I010),
     &             DSSYT1A,ICORE(I020),DSSYT2A,AZERO,ICORE(I000),
     &             DISSYG)
C        CALL Checksum(SPCASE,ICORE(I000), NUMSYG*DISSYG)
C
C IN MBPT4 WITH RHF-REFERENZ THE SECOND IS THE TRANSPOSE OF THE FIRST
C
        IF(IUHF.NE.0.OR.CC) THEN
         I020=I010+IINTFP*NMSYT1B*DSSYT1B
         I030=I020+IINTFP*NMSYT2B*DSSYT2B
         IF(MAXCOR.LT.I030) CALL INSMEM('H4ALL ',I030,MAXCOR)
        
         IF(bRedundant) THEN
            CALL GETLST(ICORE(I020),1,NMSYT2B,1,IRREP,LIST2B)
            CALL GETLST(ICORE(I010),1,NMSYT1B,1,IRREP,LIST1B)
         ELSE
            CALL GETLST_NR(ICORE(I020),ICORE(I030),MAXCOR-I030, LIST2B,
     &                   IRREP)
            CALL GETLST_NR(ICORE(I010),ICORE(I030),MAXCOR-I030, LIST1B,
     &                   IRREP)
         ENDIF
         CALL XGEMM('N','N',DISSYG,NUMSYG,DSSYT2B,FACT,ICORE(I010),
     &              DSSYT1B,ICORE(I020),DSSYT2B,ONE,ICORE(I000),
     &              DISSYG)
        ELSE
         I020=I010+IINTFP*NUMSYG*DISSYG
         IF(MAXCOR.LT.I020) CALL INSMEM('H4ALL ',I030,MAXCOR)
         CALL TRANSP(ICORE(I000),ICORE(I010),NUMSYG,DISSYG)
         CALL SAXPY(NUMSYG*DISSYG,ONE,ICORE(I010),1,ICORE(I000),1)
        ENDIF
C
C  SAVE LIST 56
C
C        CALL Checksum(SPCASE,ICORE(I000), NUMSYG*DISSYG)
        CALL PUTLST(ICORE(I000),1,NUMSYG,2,IRREP,LISTG) 
C
C  EVALUATE FOR UHF AS WELL ABBA
C
        IF(IUHF.EQ.1) THEN
         IF(MBPT4) THEN
          CALL TRANSP(ICORE(I000),ICORE(I010),NUMSYG,DISSYG)
          CALL PUTLST(ICORE(I010),1,DISSYG,2,IRREP,LISTG+1)
         ELSE IF(CC) THEN
          DSSYT3A=IRPDPD(IRREP,ISYTYP(1,LIST3A))
          DSSYT4A=IRPDPD(IRREP,ISYTYP(1,LIST4A))
          NMSYT3A=IRPDPD(IRREP,ISYTYP(2,LIST3A))
          NMSYT4A=IRPDPD(IRREP,ISYTYP(2,LIST4A))
          DSSYT3B=IRPDPD(IRREP,ISYTYP(1,LIST3B))
          DSSYT4B=IRPDPD(IRREP,ISYTYP(1,LIST4B))
          NMSYT3B=IRPDPD(IRREP,ISYTYP(2,LIST3B))
          NMSYT4B=IRPDPD(IRREP,ISYTYP(2,LIST4B))
          DISSYG2=IRPDPD(IRREP,ISYTYP(1,LISTG2))
          NUMSYG2=IRPDPD(IRREP,ISYTYP(2,LISTG2))
C
C  FIRST TERM
C
          I020=I010+IINTFP*NMSYT3A*DSSYT3A
          I030=I020+IINTFP*NMSYT4A*DSSYT4A
          CALL IZERO(ICORE(I000),DISSYG2*NUMSYG2*IINTFP)
          IF(bRedundant) THEN
             CALL GETLST(ICORE(I020),1,NMSYT4A,1,IRREP,LIST4A)
             CALL GETLST(ICORE(I010),1,NMSYT3A,1,IRREP,LIST3A)
          ELSE
             CALL GETLST_NR(ICORE(I020),ICORE(I030),MAXCOR-I030, LIST4A,
     &                   IRREP)
             CALL GETLST_NR(ICORE(I010),ICORE(I030),MAXCOR-I030, LIST3A,
     &                   IRREP)
          ENDIF
          CALL XGEMM('N','N',DISSYG2,NUMSYG2,DSSYT4A,FACT,ICORE(I010),
     &               DSSYT3A,ICORE(I020),DSSYT4A,AZERO,ICORE(I000),
     &               DISSYG2)
          I020=I010+IINTFP*NMSYT3B*DSSYT3B
          I030=I020+IINTFP*NMSYT4B*DSSYT4B
          IF(MAXCOR.LT.I030) CALL INSMEM('H4ALL ',I030,MAXCOR)
          IF(bRedundant) THEN
             CALL GETLST(ICORE(I020),1,NMSYT4B,1,IRREP,LIST4B)
             CALL GETLST(ICORE(I010),1,NMSYT3B,1,IRREP,LIST3B)
          ELSE
             CALL GETLST_NR(ICORE(I020),ICORE(I030),MAXCOR-I030, LIST4B,
     &                   IRREP)
             CALL GETLST_NR(ICORE(I010),ICORE(I030),MAXCOR-I030, LIST3B,
     &                   IRREP)
          ENDIF
          CALL XGEMM('N','N',DISSYG2,NUMSYG2,DSSYT4B,FACT,ICORE(I010),
     &               DSSYT3B,ICORE(I020),DSSYT4B,ONE,ICORE(I000),
     &               DISSYG2)
C
C  SAVE 57 ON DISK
C
          CALL PUTLST(ICORE(I000),1,NUMSYG2,2,IRREP,LISTG2)
CSSS          CALL Checksum(SPCASE,ICORE(I000), NUMSYG*DISSYG)
         ENDIF
        ENDIF
200    CONTINUE   
C
      ELSEIF(SPCASE.EQ.'ABAB'.OR.SPCASE.EQ.'BABA')THEN
C
C DO SPIN CASES ABAB AND BABA:
C
C MBPT(4) :      H(MeJb) =    SUM n,F T1(Mn,Fe) T1(Jn,Fb)
C
C  STORAGE  Em, Bj
C
       IF(SPCASE.EQ.'ABAB')THEN
        LISTG=58
        IF(MBPT4) THEN
         ISAME=.TRUE.
         FACT=ONEM
         LIST1=39
         LIST2=39
        ELSE IF(CC) THEN
         LIST1=139
         LIST2=39
         FACT=ONEM
         ISAME=.FALSE.
        ENDIF
       ELSEIF(SPCASE.EQ.'BABA')THEN
        LISTG=59
        IF(MBPT4) THEN
         ISAME=.TRUE.
         FACT=ONEM
         LIST1=38
         LIST2=38
        ELSE IF(CC) THEN
         FACT=ONEM
         ISAME=.FALSE. 
         LIST1=138
         LIST2=38
        ENDIF
       ENDIF

       DO 300 IRREP=1,NIRREP 
        DSSYT1=IRPDPD(IRREP,ISYTYP(1,LIST1))
        DSSYT2=IRPDPD(IRREP,ISYTYP(1,LIST2))
        NMSYT1=IRPDPD(IRREP,ISYTYP(2,LIST1))
        NMSYT2=IRPDPD(IRREP,ISYTYP(2,LIST2))
        DISSYG=IRPDPD(IRREP,ISYTYP(1,LISTG))
        NUMSYG=IRPDPD(IRREP,ISYTYP(2,LISTG))
        I000=1
        I010=I000+IINTFP*DISSYG*NUMSYG
        IF(ISAME) THEN
         I020=I010
        ELSE
         I020=I010+IINTFP*NMSYT1*DSSYT1
        ENDIF
        I030=I020+IINTFP*NMSYT2*DSSYT2
        IF(MAXCOR.LT.I030) CALL INSMEM('H4ALL ',I030,MAXCOR)
        CALL IZERO(ICORE(I000),DISSYG*NUMSYG*IINTFP)
        IF(bRedundant) THEN
           CALL GETLST(ICORE(I010),1,NMSYT1,1,IRREP,LIST1)
           IF(.NOT.ISAME)CALL GETLST(ICORE(I020),1,NMSYT2,1,IRREP,LIST2)
        ELSE
           CALL GETLST_NR(ICORE(I010),ICORE(I020),MAXCOR-I020, LIST1,
     &                   IRREP)
           IF(.NOT.ISAME) CALL GETLST_NR(ICORE(I020),ICORE(I030),
     &                      MAXCOR-I030, LIST2,IRREP)
        ENDIF
        CALL XGEMM('N','T',DISSYG,NUMSYG,NMSYT1,FACT,ICORE(I010),
     &             DSSYT1,ICORE(I020),DSSYT2,AZERO,ICORE(I000),DISSYG)
C
C SAVE H4 INTERMEDIATE ON DISK
C
        CALL PUTLST(ICORE(I000),1,NUMSYG,2,IRREP,LISTG)
CSSS        CALL Checksum(SPCASE,ICORE(I000), NUMSYG*DISSYG)
300    CONTINUE
      ENDIF
      RETURN
      END
