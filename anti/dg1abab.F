
C DRIVER FOR SORTING MO GAMMA ELEMENTS (SPIN CASE ABAB)

      SUBROUTINE DG1ABAB(ICORE,BUF1,BUF2,SCR1,SCR2,
     &                   MEMSZ,NUMAO,LIST1,LIST2,
     &                   IUHF,IRREPDO,ALASKA)
      IMPLICIT INTEGER (A-Z)
      LOGICAL ALASKA
      DIMENSION ICORE(MEMSZ)
      DOUBLE PRECISION BUF1(*),BUF2(*),SCR1(*),SCR2(*)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
 
#include "icdacc.com"
 
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON /SYMINF/ NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
C
      NNP1O2(I)=(I*(I+1))/2
C
C
C  ILNBUF - THE NUMBER OF INTEGRALS IN THE LARGEST RECORD ON THE GAMLAM
C           FILE. [The maximum number in a totally symmetric distribution].
C
C  LENINT - THE LENGTH OF A GAMMA ELEMENT AND ITS INDEX.
C
C  MEMINT - THE SIZE OF AVAILABLE MEMORY IN UNITS OF "INTEGRAL LENGTHS".
C           (HOW MANY INTEGRALS AND INDICES WHICH CAN BE HELD IN CORE
C           SIMULTANEOUSLY.)
C
C  NUMDIS - THE NUMBER OF DISTRIBUTIONS (NOCA*NVRTB OR NOCB*NVRTA).
C
C  DISSIZ - THE SIZE OF THE DISTRIBUTION (NVRTA*NVRTB ALWAYS).
C
C  NINCOR - THE NUMBER OF DISTRIBUTIONS WHICH CAN BE HELD IN CORE
C           SIMULTANEOUSLY.  (THE NUMBER IN A "BUCKET").
C
C  NBKINT - THE NUMBER OF INTEGRALS TO BE HELD IN AN INDIVIDUAL BUCKET
C           BUFFER. (FIXED).
C
C  MEMSIZ - THE AVAILABLE MEMORY, IN WORDS.
C
C INITIALIZE SOME THINGS
C
      MEMSIZ=MEMSZ
      CALL IZERO(ICORE,MEMSIZ)
      LENINT=1+IINTFP
      NBKINT=(32768-2*IINTLN)/(IINTLN*(1+IINTFP))
      NUMDIS=NNP1O2(NUMAO)
      DISSIZ=NUMDIS
C
C COMPUTE MAXIMUM DISTRIBUTION SIZE ON GAMLAM FILE WHICH WILL BE
C  READ INTO CORE.
C
C SRG/JDW. 12/14/95. Change dimension of BUF (ILNBUF) to avoid overwrite
C in SG1ABAB.
C
      MXLNT1=0
      DO  5 IRREP=1,NIRREP
       MXLNT1 = MAX(MXLNT1,IRPDPD(IRREP, 9))
       MXLNT1 = MAX(MXLNT1,IRPDPD(IRREP,10))
    5 CONTINUE
C
      ILNBUF=4*MXLNT1
      DO 10 ITYPE=1,22
       ILNBUF=MAX(ILNBUF,IRPDPD(1,ITYPE))
C      ILNBUF=MAX(ILNBUF,IRPDPD(IRREPDO,ITYPE))
10    CONTINUE
C
C  SUBTRACT AWAY THE SPACE NEEDED FOR INTEGRAL BUCKETS.
C
      MEMSIZ=MEMSIZ-LENINT*NBKINT
C
C  SUBTRACT AWAY SPACE NEEDED FOR SORT CHAIN VECTOR (UPPER LIMIT).
C
      MEMSIZ=MEMSIZ-NUMDIS
C
C  SUBTRACT SPACE FOR A SCRATCH ARRAY WHICH HOLDS ONE LOGICAL
C  RECORD FROM THE GAMLAM FILE
C
      MEMSIZ=MEMSIZ-ILNBUF*IINTFP
C
C DETERMINE HOW MANY DISTRIBUTIONS WHICH CAN FIT INTO THE CORE
C  SPACE THAT REMAINS.
C
      MEMINT=MEMSIZ/IINTFP
      NINCOR=MIN(NUMDIS,MEMINT/DISSIZ)
C
C NOW FIGURE OUT HOW MANY SORTFILE BUCKETS ARE NEEDED AND HOW BIG THEY
C   HAVE TO BE.
C
C  NBUCK  - THE NUMBER OF BUCKETS.
C
C  NDBCK  - THE NUMBER OF DISTRIBUTIONS PER BUCKET.
C
C  NBKINT - THE NUMBER OF INTEGRALS IN A BUCKET.
C
      IF(NINCOR.EQ.0)THEN
       WRITE(6,4000)NUMDIS*LENINT,MEMSIZ
4000   FORMAT(T3,'@DG1ABAB-F, Not enough core to hold one integral ',
     &        'distribution.',/,
     & T3,'       Space needed (words):   ',I10,/,
     & T3,'       Space available (words):',I10)
       CALL ERREX
      ENDIF
C
C FIGURE OUT HOW MANY BUCKETS ARE REQUIRED.
C
      NBUCK=NUMDIS/NINCOR
      IF(MOD(NUMDIS,NINCOR).NE.0)NBUCK=NBUCK+1
C
C NDBCK IS THE NUMBER OF DISTRIBUTIONS IN AN INDIVIDUAL BUCKET.
C
      NDBCK=NUMDIS/NBUCK
      IF(MOD(NUMDIS,NBUCK).NE.0)NDBCK=NDBCK+1

c YAU - old
cC NOW SET THE RECORD LENGTH FOR THE SORT FILE.
cC      IRECL=IINTLN*(NBKINT*(1+IINTFP)+2)
c      if (iintfp .eq. 1) then
c        IRECL=IINTLN*(NBKINT*(1+IINTFP)+2)
c      else
c        IRECL=idaccm*(NBKINT*(1+IINTFP)+2)
c      endif
c YAU - new
      IRECL=idaccm*(NBKINT*(1+IINTFP)+2)
c YAU - end

C NOW ALLOCATE CORE FOR THE SORT!  THIS WILL TYPICALLY BE MUCH LESS
C  THAN THE TOTAL AVAILABLE MEMORY.
C
      I000=1
      I010=NBKINT*IINTFP*NBUCK+I000
      I020=ILNBUF*IINTFP+I010
      I030=NBKINT*NBUCK+I020
      I040=NBUCK+I030
      I050=NBUCK+I040
      WRITE(6,*)' I050 Is ',I050,'  MEMSIZ IS ',MEMSIZ
      IF(I050.GT.MEMSIZ)THEN
       WRITE(6,5000)
5000   FORMAT(T3,'@DG1ABAB-F, Core screwup.')
       CALL ERREX
      ENDIF
      WRITE(6,1000)MEMSZ,MEMSIZ,DISSIZ*LENINT,NUMDIS,NINCOR,NBUCK,
     &        NDBCK,NBKINT,IRECL,I050
1000   FORMAT(T3,'@DG1ABAB-I, Information for gamma sort',/,
     &   '        Total available memory (words)         ',I10,'.',/,
     &   '        Available memory for buckets (words)   ',I10,'.',/,
     &   '        Distribution length (words)            ',I10,'.',/,
     &   '        Number of distributions                ',I10,'.',/,
     &   '        Number which can be held in core       ',I10,'.',/,
     &   '        Number of sortfile buckets             ',I10,'.',/,
     &   '        Number of distributions per bucket     ',I10,'.',/,
     &   '        Number of integrals per bucket         ',I10,'.',/,
     &   '        Sortfile record length (bytes)         ',I10,'.',/,
     &   '        Total utilized memory (words)          ',I10,'.')
      CALL SG1ABAB(ICORE(I000),ICORE(I010),ICORE(I020),ICORE(I030),
     &             ICORE(I040),NBUCK,NDBCK,
     &             NBKINT,NREC,IRECL,ILNBUF,
     &             BUF1,BUF2,SCR1,SCR2,IUHF,IRREPDO)
C
C MOVE CHAIN VECTOR TO BOTTOM OF CORE.
C
      CALL ICOPY(NBUCK,ICORE(I040),1,ICORE(I000),1)
C
      IADD=0
      IF(MOD(NBUCK,2).EQ.1) IADD=1
      I010=I000+NBUCK+IADD
      I020=I010+DISSIZ*NDBCK*IINTFP
      I030=I020+NBKINT*IINTFP
      I040=I030+NBKINT
      WRITE(6,200)I040,MEMSIZ
200   FORMAT(T3,'@DG1ABAB-I, Sort chain processing uses ',I10,
     &          ' out of ',I10,' words.')
      IF(I040.GT.MEMSIZ)THEN
       WRITE(6,300)I040,MEMSIZ
       CALL ERREX
300    FORMAT(T3,'@DG1ABAB-F, Core screwup. ',I10,' words needed.',
     &           I10,' words available.')
      ENDIF
      CALL CG1ABAB(ICORE(I010),ICORE(I020),ICORE(I030),ICORE(I000),
     &             DISSIZ,NDBCK,NBKINT,NBUCK,IRECL,LIST1,LIST2,
     &             IRREPDO,ALASKA)
      RETURN
      END
