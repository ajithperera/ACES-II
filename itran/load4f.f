      SUBROUTINE LOAD4F(CMO,W,W2,BUF,IBUF,ISYMAO,NBAS,
     &                  NSTART,NEND,IOFFAO,IOF4,ISIZE3,
     &                  ISIZE2,NSIZE,ILNBUF,ISPIN,LUINT,
     &                  LAST,IOFFSET)
C
C THIS ROUTINE LOADS AO INTEGRALS FROM
C THE INTEGRAL FILE IJKL AND TRANSFORMS THE FIRST
C INDEX.
C
CEND
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL LAST
      INTEGER DIRPRD,AND,OR
C
      DIMENSION IBUF(ILNBUF),BUF(ILNBUF),W(1),W2(1),CMO(1)
      DIMENSION NBAS(8),IOFFAO(8),IOF4(8,8)
      DIMENSION ISIZE3(8,8),ISIZE2(8,8,8),NSTART(8),NEND(8)
      DIMENSION ISYMAO(1) 
C
      COMMON/SYMINF/NDUMMY,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON/FLAGS/IFLAGS(100)
      COMMON/FLAGS2/IFLAGS2(500)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/AOOFST/INDOCC(8,2)
      COMMON/VTINFO/NPASS1,NPASS2,NPASS3,NPASS4,
     &              NLOAD1,NLOAD2,NLOAD3,NLOAD4,
     &              NWRIT1,NWRIT2,NWRIT3,NWRIT4,
     &              NWRIT1A,NWRIT2A,NWRIT3A,NWRIT4A,
     &              NWRIT1B,NWRIT2B,NWRIT3B,NWRIT4B
C
      DATA HALF/0.5D0/
C
      IUPKI(IX)=AND(IX,IALONE)
      IUPKJ(IX)=AND(ISHFT(IX,-IBITWD),IALONE)
      IUPKK(IX)=AND(ISHFT(IX,-2*IBITWD),IALONE)
      IUPKL(IX)=AND(ISHFT(IX,-3*IBITWD),IALONE)
      INDXT(I,J)=J+(I*(I-1))/2
      INDXF(I,J,N)=I+N*(J-1)
C
      CALL ZERO(W,NSIZE)
C
      NPASS4=NPASS4+1
C
C READ IN INTEGRALS
C
      NAOBUF=0
      NAOINT=0
1     READ(LUINT) BUF,IBUF,NUT
      NAOBUF=NAOBUF+1
      DO 10 INT=1,NUT
       X=BUF(INT)
       ITMP=IBUF(INT)
C
C  X VALUE, IX,JX,KX,LX INDICES  
C
       IX=IUPKI(ITMP)
       JX=IUPKJ(ITMP)
       KX=IUPKK(ITMP)
       LX=IUPKL(ITMP)
C
C GET IRREP OF INTEGRAL
C
       IRREPX1=ISYMAO(IX)
       IRREPX2=ISYMAO(JX)
       IRREPX3=ISYMAO(KX)
       IRREPX4=ISYMAO(LX)
C
       IRREP1=MAX(IRREPX1,IRREPX2,IRREPX3,IRREPX4)
C
       IF(IRREP1.EQ.IRREPX1) THEN
        IRREP2=IRREPX2
        IXX=IX
        JXX=JX
        IF(IRREPX3.GT.IRREPX4) THEN
         IRREP3=IRREPX3
         IRREP4=IRREPX4
         KXX=KX
         LXX=LX
        ELSE
         IRREP3=IRREPX4
         IRREP4=IRREPX3
         KXX=LX
         LXX=KX
        ENDIF
       ELSE IF(IRREP1.EQ.IRREPX2) THEN
        IRREP2=IRREPX1
        IXX=JX
        JXX=IX
        IF(IRREPX3.GT.IRREPX4) THEN
         IRREP3=IRREPX3
         IRREP4=IRREPX4
         KXX=KX
         LXX=LX
        ELSE
         IRREP3=IRREPX4
         IRREP4=IRREPX3
         KXX=LX
         LXX=KX
        ENDIF
       ELSE IF(IRREP1.EQ.IRREPX3) THEN
        IRREP2=IRREPX4
        IXX=KX
        JXX=LX
        IF(IRREPX1.GT.IRREPX2) THEN
         IRREP3=IRREPX1
         IRREP4=IRREPX2
         KXX=IX
         LXX=JX
        ELSE
         IRREP3=IRREPX2
         IRREP4=IRREPX1
         KXX=JX
         LXX=IX
        ENDIF
       ELSE IF(IRREP1.EQ.IRREPX4) THEN
        IRREP2=IRREPX3
        IXX=LX
        JXX=KX
        IF(IRREPX1.GT.IRREPX2) THEN
         IRREP3=IRREPX1
         IRREP4=IRREPX2
         KXX=IX
         LXX=JX
        ELSE
         IRREP3=IRREPX2
         IRREP4=IRREPX1
         KXX=JX
         LXX=IX
        ENDIF
       ENDIF
C
C  OFFSET WITHIN BASIS FUNCTIONS
C
       IOFF1=IOFFAO(IRREP1)
       IOFF2=IOFFAO(IRREP2)
       IOFF3=IOFFAO(IRREP3)
       IOFF4=IOFFAO(IRREP4)
C
C  INDICES WITHIN IRREP
C
       I=IXX-IOFF1
       J=JXX-IOFF2
       K=KXX-IOFF3
       L=LXX-IOFF4
C
C  OFFSET FOR CMO WITHIN IRREP1
C
       IOFFC1=INDOCC(IRREP1,ISPIN)
C
C  NUMBER OF OCCUPIED ORBITALS WITHIN IRREPX1 AND IRREPX2
C
       NSTARTX1=NSTART(IRREP1)
       NENDX1=NEND(IRREP1)
C
C  NUMBER OF BASIS FUNCTIONS WITHIN IRREPX 
C
       NBASX1=NBAS(IRREP1)
       NBASX2=NBAS(IRREP2)
       NBASX4=NBAS(IRREP4)
C
C  OFFSET WITHIN W
C
       IOFFW41=IOF4(IRREP1,IRREP2)
C
       ISIZE31=ISIZE3(IRREP1,IRREP2)
C
C THERE ARE A TOTAL OF EIGHT CONTRIBUTIONSa
C
C   (IJ|KL) (JI|KL) (IJ|LK) (JI|LK)
C   (KL|IJ) (KL|JI) (LK|IJ) (LK|JI)
C
C HOWEVER, WE NEED ONLY FOUR SINCE WE STORE THE AS
C
C   NU, SIGMA >= RHO,  I   
C
C FOURTH ELEMENT:     TRANSFORM INDEX I TO MO BASIS
C
        IND=INDXF(L,K,NBASX4)+ISIZE2(IRREP2,IRREP3,IRREP4)
        DO 9007 IMO=NSTARTX1,NENDX1
         W2(IMO)=CMO(IOFFC1+I-1+(IMO-1)*NBASX1)*X
9007    CONTINUE 
C
C INCREMENT L(JX,LX,KX;I)
C
*VOCL LOOP,NOVREC
CDIR$ IVDEP
        DO 9008 IMO=NSTARTX1,NENDX1
         IADR=IOFFW41+J+NBASX2*(IND-1)+ISIZE31*(IMO-NSTARTX1)
         W(IADR)=W(IADR)+W2(IMO)
9008    CONTINUE
10    CONTINUE
C
      
      IF(NUT.EQ.ILNBUF) THEN
       NAOINT=NAOINT+NUT
       GO TO 1
      ENDIF
      IF(NUT.EQ.-1) NUT=0
C
      NAOINT=NAOINT+NUT
      IF(LAST) THEN
C
CJDW 2/1/95. Delete integral file if possible.
C
       IF(IFLAGS(18).GE.3.OR.IFLAGS(26).EQ.1.OR.IFLAGS(93).EQ.2.OR.
     &   (ISPIN.EQ.1.AND.IFLAGS(11).GT.0)   .OR.IFLAGS2(103).EQ.1)THEN
        CLOSE(UNIT=LUINT,STATUS='KEEP')
       ELSE
        CLOSE(UNIT=LUINT,STATUS='DELETE')
       ENDIF
C
      ELSE
       REWIND(LUINT)
       CALL LOCATE(LUINT,'TWOELSUP')
      ENDIF
c      WRITE(6,1002)NAOINT
      NLOAD4=NAOINT
1002  FORMAT(T3,'@LOAD4F-I, ',I8,' integrals read in from ',
     &          'file IJKL')
C      
      RETURN
900   WRITE(6,1000)
1000  FORMAT(T3,'@LOAD4F-F, Unexpected end-of-file on integral file.')
      CALL ERREX
      RETURN
901   WRITE(6,1000)
1001  FORMAT(T3,'@LOAD4F-F, I/O error on unit ',I5,'.')
      CALL ERREX
      RETURN
      END
