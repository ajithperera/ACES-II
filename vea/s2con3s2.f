      SUBROUTINE S2CON3S2(ICORE,MAXCOR,IUHF, ISIDE, ISPIN)
C
C   THIS SUBROUTINE CALCULATES THE CONTRIBUTION OF S2 TO
C   S2 INVOLVING THE THREE-PARTICLE EFFECTIVE INTEGRALS W.
C   THESE CONTRIBUTIONS ARE EVALUATED IN TWO STEPS.
C
C CONTRACTIONS :
C
C     Q(K,P) = SUM  [(2<MK|CD> - <MK|DC>) S(CD,MP)] [SPIN ADAPTED RHF]
C              MCD
C
C     Z(AB,IP) = - SUM [Q(K,P) T2(AB,IK) ]
C                   K
C
C   IT IS SEEN THAT KIRREP = SIRREP.
CEND
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION ONE,ONEM,ZILCH
C
      DIMENSION ICORE(MAXCOR)
      DIMENSION LISTW0(2,2), NM(8), NK(8)
      LOGICAL PRINT
C
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON /SYM/ POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON /SINFO/ NS(8), SIRREP
      COMMON/SLISTS/LS1IN, LS1OUT, LS2IN(2,2), LS2OUT(2,2)
C
      DATA ONE  /1.0/
      DATA ZILCH/0.0/
      DATA ONEM/-1.0/
C
C     16 : V(Ab,Ij) =  W(Ij, Ab) ordered as Ab;Ij
C     46 : T(Ij; Ab) ordered as Ab;Ij
C
      LISTW0(1,1) = 14
      LISTW0(1,2) = 16
      LISTW0(2,1) = 16
      LISTW0(2,2) = 15
C
C  THE SECOND SPINLABEL OF LISTW0 EQUALS ISPIN, THE FIRST LABEL DETERMINES
C  THE SPIN-TYPE OF THE S-VECTOR (IMIXSPIN)
C  LISTT0 = 30 + LISTW0
C  LIST 16 (46) CONTAINS INTEGRALS V(Ab, Ij), WHICH MEANS THAT THE ORDERING IS
C  CONVENIENT FOR ISPIN = 2, BUT FOR ISPIN = 1 BOTH THE ROW AND COLUMNS HAVE TO
C  BE SUBJECTED TO SYMTR.
C
       LENTAR= NS(SIRREP) * POP(SIRREP,ISPIN)
       I000=1
       I010=I000+LENTAR*IINTFP
       CALL ZERO(ICORE(I000),LENTAR)
C
       DO 50 IMIXSPIN = 1, 1+IUHF
          LISTW = LISTW0(IMIXSPIN, ISPIN+1-IUHF) + (ISIDE - 1) * 30
          LISTS2IN = LS2IN(ISPIN, IMIXSPIN+1-IUHF)
          MSPIN = IMIXSPIN
          IF (((ISPIN .EQ. 2) .AND.
     $       (MSPIN .EQ.1)) .OR. (IUHF.EQ.0)) THEN
             CASE = 1
          ELSEIF (ISPIN.EQ.MSPIN) THEN
             CASE = 2
          ELSE
             CASE  = 3
          ENDIF
C
C LOOP OVER IRREPS OF RHS OF S VECTOR <MK|DC>) S(CD,MP)
C
       DO 100 XIRREP=1,NIRREP
        MIRREP=DIRPRD(XIRREP,SIRREP)
        IRREPW=XIRREP
        DISSYW=IRPDPD(IRREPW,ISYTYP(1,LISTW)) 
        NUMDSW=POP(SIRREP,ISPIN) * POP(MIRREP,MSPIN)
        IF (CASE .EQ. 2) THEN
           NUMDSW = IRPDPD(XIRREP, ISPIN+20)
C
C THE DIMENSION AFTER EXPANSION OF THE ARRAY
C
        ENDIF
        DISSYS=IRPDPD(XIRREP,ISYTYP(1,LISTS2IN))
        NUMDSS=POP(MIRREP,MSPIN) * NS(SIRREP)
        MAXW=MAX(NUMDSW,DISSYW)
        I020=I010+IINTFP*DISSYW*NUMDSW
        I030=I020+IINTFP*MAX(DISSYS*NUMDSS,3*MAXW)
        IF(I030.GT.MAXCOR)THEN
C
C OUT-OF-CORE ALGORITHM
C
         WRITE(6,*)' out-of-core AB not coded, s2con3s2'
         WRITE(6,1000) I030, MAXCOR
 1000    FORMAT('  REQUIRED MEMORY :', I12, '  AVAILABLE : ', I12)
         call errex
C
        ENDIF
C
C
C DO IN-CORE ALGORITHM
C
C
C  TREAT IMIXSPIN = 2, ISPIN =1 AS SPECIAL CASE (CASE=3)
C        IMIXSPIN = ISPIN, UHF  AS SPECIAL CASE (CASE=2)
C
       IF (CASE.EQ.1) THEN
C
C READ W INTO 
C     
C        W(ab, mk) =  2 W(ab, mk) - W(ba, mk)   [ RHF ]
C        ONLY THE KIRREP=SIRREP, AND MIRREP INTEGRALS ARE NEEDED.
C        THEREFORE CALULATE OFFSET
C
           NFIRST = 1
           DO 110 IRREPK = 1, SIRREP - 1
              IRREPM = DIRPRD(IRREPK, XIRREP)
              NFIRST = NFIRST + POP(IRREPK,ISPIN)*POP(IRREPM,MSPIN)
 110          CONTINUE
         CALL GETLST(ICORE(I010),NFIRST,NUMDSW,1,IRREPW,LISTW)
         IF (IUHF.EQ.0) THEN
            ITMP1=I020
            ITMP2=ITMP1+IINTFP*MAXW
            ITMP3=ITMP2+IINTFP*MAXW
            CALL SPINAD3(IRREPW,VRT(1,1),DISSYW,NUMDSW,
     &                  ICORE(I010),ICORE(ITMP1),ICORE(ITMP2))
         ENDIF
C
      ELSE IF (CASE.EQ.2) THEN
         NUMDSW = IRPDPD(IRREPW, ISYTYP(2,LISTW))
         CALL GETLST(ICORE(I010), 1, NUMDSW, 1, IRREPW,LISTW)
         CALL SYMEXP(IRREPW, POP(1, ISPIN), DISSYW, ICORE(I010))
           NFIRST = 0
           DO 112 IRREPK = 1, SIRREP - 1
              IRREPM = DIRPRD(IRREPK, XIRREP)
              NFIRST = NFIRST + POP(IRREPK,ISPIN)*POP(IRREPM,MSPIN)
 112       CONTINUE
           I010 = I010 + NFIRST * IINTFP * DISSYW
           NUMDSW = POP(SIRREP,ISPIN) * POP(MIRREP, MSPIN)
        ELSE         
C
C
C TREAT SPECIAL CASE ISPIN =1, IMIXSPIN = 2, UHF CASE
C
C   W(Ab|Km) SHOULD BE READ IN AND PERMUTED INTO  W(bA|mK).
C
C READ W INTO 
C     
C        W(Ab, Km) 
C        ONLY THE KIRREP=SIRREP, AND MIRREP INTEGRALS ARE NEEDED.
C        THEREFORE CALULATE OFFSET
C
           NFIRST = 1
           DO 120 IRREPM = 1, MIRREP - 1
              IRREPK = DIRPRD(IRREPM, XIRREP)
              NFIRST = NFIRST + POP(IRREPK,ISPIN)*POP(IRREPM,MSPIN)
 120          CONTINUE
         CALL GETLST(ICORE(I010),NFIRST,NUMDSW,1,IRREPW,LISTW)
C
C  NOW PERMUTE W(Ab|Km) INTO W(bA|mK), ROW-INDICES FIRST
C
         NUMW = POP(MIRREP,MSPIN) * POP(SIRREP, ISPIN)
         MAXW = MAX(NUMW, DISSYW)
         I030 = I020 + MAXW * IINTFP
         I040 = I030 + MAXW * IINTFP
         I050 = I040 + MAXW * IINTFP
         CALL SYMTR3(IRREPW, VRT(1, ISPIN), VRT(1,MSPIN), DISSYW, NUMW,
     $      ICORE(I010), ICORE(I020), ICORE(I030), ICORE(I040))
C
C  TO PERMUTE COLUMN-INDICES WE NEED POPULATION VECTORS
C
         CALL IZERO(NM, 8)
         CALL IZERO(NK,8)
         NK(SIRREP) = POP(SIRREP, ISPIN)
         NM(MIRREP) = POP(MIRREP, MSPIN)
         CALL SYMTR1(IRREPW, NK, NM, DISSYW, ICORE(I010), ICORE(I020),
     $      ICORE(I030), ICORE(I040))
      ENDIF
C
C READ S2 VECTOR INTO 
C
C           S(ABM,P) 
C
      CALL GETLST(ICORE(I020),1,NUMDSS,1,XIRREP,LISTS2IN)
C
C PERFORM MATRIX MULTIPLICATION
C
C                              +          
C         Q(K,P) = SUM W(ABM,K) * S(ABM,P)
C                  ABM
C  
      NROW=POP(SIRREP,ISPIN)
      NCOL=NS(SIRREP)
      NSUM=DISSYW*POP(MIRREP,MSPIN)
      PRINT =.false.      
      IF (PRINT) THEN
         WRITE(6,*) 'W-INTEGRALS S2CON3S2'
         CALL OUTPUT(ICORE(I010), 1, NSUM, 1, NROW, NSUM, NROW, 1)
      ENDIF      
      CALL XGEMM('T','N',NROW,NCOL,NSUM,ONE,ICORE(I010),NSUM,
     &               ICORE(I020),NSUM,ONE,ICORE(I000),NROW)
 100  CONTINUE
 50   CONTINUE
      IF (PRINT) THEN
         WRITE(6,*)' Q-INTERMEDIATES IN S2CON3S2'
         CALL OUTPUT(ICORE(I000), 1, NROW, 1, NCOL, NROW, NCOL, 1)
      ENDIF
C
C NOW CONTRACT Q WITH T
C
      DO 75 IMIXSPIN = 1, 1+IUHF
       LISTT = LISTW0(IMIXSPIN, ISPIN+1-IUHF) + (2-ISIDE) * 30
       MSPIN = IMIXSPIN
       LISTS2EX = LS2OUT(ISPIN, IMIXSPIN+1-IUHF)
       IF (((ISPIN .EQ. 2) .AND.
     $    (MSPIN .EQ.1)) .OR. (IUHF.EQ.0)) THEN
          CASE = 1
       ELSEIF (ISPIN.EQ.MSPIN) THEN
          CASE = 2
       ELSE
          CASE  = 3
       ENDIF
C
       DO 200 XIRREP = 1, NIRREP
        MIRREP=DIRPRD(XIRREP,SIRREP)
        IRREPT=XIRREP
        DISSYT=IRPDPD(IRREPT,ISYTYP(1,LISTT)) 
        NUMDST=POP(SIRREP,ISPIN) * POP(MIRREP,MSPIN)
        IF (CASE.EQ.2) THEN
           NUMDST = IRPDPD(IRREPT, 20+ISPIN)
        ENDIF
        MAXT = MAX(DISSYT, NUMDST)
        DISSYS=IRPDPD(XIRREP,ISYTYP(1,LISTS2EX))
        NUMDSS=POP(MIRREP,MSPIN) * NS(SIRREP)
        IF (NUMDST * NUMDSS .GT. 0) THEN
        I020=I010+IINTFP*DISSYT*NUMDST          
        I030 = I020+MAX(DISSYS*NUMDSS, 3*MAXT)*IINTFP
C
         IF (I030.GT.MAXCOR) THEN
            WRITE(6,*) 'OUT OF CORE ALGORITHM NEEDED'
            CALL ERREX
         ENDIF
C 
       IF (CASE.EQ.1) THEN
C
C        ONLY THE KIRREP=SIRREP, AND MIRREP COEFFICIENTS ARE NEEDED.
C        THEREFORE CALULATE OFFSET
C
           NFIRST = 1
           DO 210 IRREPK = 1, SIRREP -1
              IRREPM = DIRPRD(IRREPK, XIRREP)
              NFIRST = NFIRST + POP(IRREPK,ISPIN)*POP(IRREPM,MSPIN)
 210          CONTINUE
         CALL GETLST(ICORE(I010),NFIRST,NUMDST,1,IRREPT,LISTT)
C
         ELSE IF (CASE.EQ.2) THEN
            NUMDST = IRPDPD(IRREPT, ISYTYP(2,LISTT))
            CALL GETLST(ICORE(I010), 1, NUMDST, 1, IRREPT,LISTT)
            CALL SYMEXP(IRREPT, POP(1, ISPIN), DISSYT, ICORE(I010))
            NFIRST = 0
            DO 115 IRREPK = 1, SIRREP - 1
               IRREPM = DIRPRD(IRREPK, XIRREP)
               NFIRST = NFIRST + POP(IRREPK,ISPIN)*POP(IRREPM,MSPIN)
 115        CONTINUE
            I010 = I010 + NFIRST * IINTFP * DISSYT
            NUMDST = POP(SIRREP,ISPIN) * POP(MIRREP, MSPIN)
         ELSE         
C
C
C TREAT SPECIAL CASE ISPIN =1, IMIXSPIN = 2, UHF CASE
C
C   T(Ab|Km) SHOULD BE READ IN AND PERMUTED INTO  T(bA|mK).
C
C READ T INTO 
C     
C        T(Ab, Km) 
C        ONLY THE KIRREP=SIRREP, AND MIRREP INTEGRALS ARE NEEDED.
C        THEREFORE CALULATE OFFSET
C
           NFIRST = 1
           DO 220 IRREPM = 1, MIRREP - 1
              IRREPK = DIRPRD(IRREPM, XIRREP)
              NFIRST = NFIRST + POP(IRREPK,ISPIN)*POP(IRREPM,MSPIN)
 220          CONTINUE
         CALL GETLST(ICORE(I010),NFIRST,NUMDST,1,IRREPT,LISTT)
C
C  NOW PERMUTE T(Ab|Km) INTO T(bA|mK), ROW-INDICES FIRST
C
         NUMT = POP(MIRREP,MSPIN) * POP(SIRREP, ISPIN)
         MAXW = MAX(NUMT, DISSYT)
         I030 = I020 + MAXW * IINTFP
         I040 = I030 + MAXW * IINTFP
         I050 = I040 + MAXW * IINTFP
         CALL SYMTR3(IRREPT, VRT(1, ISPIN), VRT(1,MSPIN), DISSYT, NUMT,
     $      ICORE(I010), ICORE(I020), ICORE(I030), ICORE(I040))
C
C  TO PERMUTE COLUMN-INDICES WE NEED POPULATION VECTORS
C
         CALL IZERO(NM, 8)
         CALL IZERO(NK,8)
         NK(SIRREP) = POP(SIRREP, ISPIN)
         NM(MIRREP) = POP(MIRREP, MSPIN)
         CALL SYMTR1(IRREPT, NK, NM, DISSYT, ICORE(I010), ICORE(I020),
     $      ICORE(I030), ICORE(I040))
         ENDIF
C            
         CALL GETLST(ICORE(I020),1,NUMDSS,1,XIRREP,LISTS2EX)
C
C NOW PERFORM MULTIPLICATION
C
C    Z(ABI,P) = - T2(ABI,K) Q(K,P)
C
         NROW = DISSYT * POP(MIRREP,MSPIN)
         NCOL = NS(SIRREP)
         NSUM = POP(SIRREP,ISPIN)
         IF (PRINT) THEN
            WRITE(6,*) 'T-COEFFICIENTS S2CON3S2'
            CALL OUTPUT(ICORE(I010), 1, NROW, 1, NSUM, NROW, NSUM, 1)
         ENDIF
         CALL XGEMM('N', 'N', NROW, NCOL, NSUM, ONEM, ICORE(I010),
     $      NROW, ICORE(I000), NSUM, ONE, ICORE(I020), NROW)
          CALL PUTLST(ICORE(I020),1,NUMDSS,1,XIRREP,LISTS2EX)
C
       ENDIF
 200   CONTINUE
C
 75   CONTINUE
C
      RETURN
      END
