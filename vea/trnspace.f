      SUBROUTINE TRNSPACE(LENGTH,NDIMNEW,NDIMOLD,SCR,TRAN,
     &                    MAXCOR,IRREPX,ISIDE,LIST,INORM,
     &                    MAXORD,IOLDEST,PRINT,IUHF,ICALC)
C
C PERFORMS A LINEAR TRANSFORMATION OF THE DAVIDSON EXPANSION
C SPACE:
C
C            NEWBASIS(I) = SUM OLDBASIS(J) * TRAN(J,I)
C                           J
CEND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL INORM,PRINT
      DIMENSION SCR(MAXCOR),TRAN(NDIMOLD,NDIMNEW)
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/LISTDAV/LISTC, LISTHC, LISTH0
C
      DATA ONE,ONEM,ZILCH /1.0D0,-1.0D0,0.0D0/
C
      IGET(I)=1+MOD(IOLDEST+MAXORD-I,MAXORD+1)
C
C FIRST SEE IF WE CAN HOLD ALL NEW EXPANSION VECTORS IN CORE.
C
      NSIZENEW=LENGTH*NDIMNEW
      I000=1
      IF(MAXCOR.GE.NSIZENEW+LENGTH)THEN
C
       WRITE(6,1000)
C
C READ IN AS MANY OLD VECTORS AS POSSIBLE INTO THE MATRIX 
C   OLDBASIS(X,*)
C
       CALL ZERO(SCR,NSIZENEW)
       I010=I000+NSIZENEW
       I020=I010+NSIZENEW
       MXCOR=MAXCOR-I010+1
       NINCOR=MIN(NDIMOLD,MXCOR/LENGTH)
       NLEFT=NDIMOLD
       NFIRST=1
       IOFFE=1
1      NREAD=MIN(NLEFT,NINCOR)
       IOFFOLD=I010
       DO 10 I=1,NREAD
        CALL GETLST(SCR(IOFFOLD),IGET(NFIRST-1+I),1,1,ISIDE,LIST)
        IOFFOLD=IOFFOLD+LENGTH
10     CONTINUE
       CALL XGEMM('N','N',LENGTH,NDIMNEW,NREAD,ONE,SCR(I010),LENGTH,
     &            TRAN(IOFFE,1),NDIMOLD,ONE,SCR(I000),LENGTH) 
       NFIRST=NFIRST+NREAD
       IOFFE=IOFFE+NREAD
       NLEFT=NLEFT-NREAD
       IF(NLEFT.NE.0)GOTO 1
C
       IOFFNEW=I000
       DO 11 I=1,NDIMNEW
C
C RENORMALIZE AND CLEAN UP NOISE
C
        IF(INORM)THEN
         IF(IUHF.EQ.0)THEN
          CALL SCOPY(LENGTH,SCR(IOFFNEW),1,SCR(I010),1)
          CALL SPNTSING(LENGTH,SCR(I010),SCR(I020),MAXCOR-I000+1,
     $       IRREPX, ICALC)
          Z=SQRT(SDOT(LENGTH,SCR(IOFFNEW),1,SCR(I010),1))
         ELSE
          Z=SQRT(SDOT(LENGTH,SCR(IOFFNEW),1,SCR(IOFFNEW),1))
         ENDIF
         CALL SSCAL(LENGTH,ONE/Z,SCR(IOFFNEW),1)
        ENDIF
        CALL PUTLST(SCR(IOFFNEW),NDIMNEW-I+1,1,1,ISIDE,LIST)
        IOFFNEW=IOFFNEW+LENGTH
11     CONTINUE
C
C OUT-OF-CORE ALGORITHM
C
      ELSE 
       WRITE(6,1001)
C
C LOOP OVER VECTORS IN NEW BASIS
C
       DO 12 INEW=1,NDIMNEW
        IOFFNEW=I000
        CALL ZERO(SCR(IOFFNEW),LENGTH)
        I010=I000+LENGTH
        I020=I010+LENGTH
        MXCOR=MAXCOR-I010+1
C
C CALCULATE CONTRIBUTIONS FROM AS MANY OLD EXPANSION VECTORS
C AS POSSIBLE
C
        NINCOR=MIN(NDIMOLD,MXCOR/LENGTH)
        IF(MXCOR.LT.0.OR.NINCOR.LE.2)THEN
         WRITE(6,1002)
         CALL INSMEM('TRNSPACE',MXCOR,2*LENGTH)
         CALL ERREX
        ENDIF
        NLEFT=NDIMOLD
        NFIRST=1
        IOFFE=1
2       NREAD=MIN(NLEFT,NINCOR)
        IOFFOLD=I010
        DO 13 I=1,NREAD
         CALL GETLST(SCR(IOFFOLD),IGET(NFIRST+I-1),1,1,ISIDE,LIST)
         IOFFOLD=IOFFOLD+LENGTH
13      CONTINUE
        CALL XGEMM('N','N',LENGTH,1,NREAD,ONE,SCR(I010),LENGTH,
     &             TRAN(IOFFE,INEW),NDIMOLD,ONE,SCR(I000),LENGTH)
        NFIRST=NFIRST+NREAD
        IOFFE=IOFFE+NREAD
        NLEFT=NLEFT-NREAD
        IF(NLEFT.NE.0)GOTO 2
        IF(INORM)THEN
         IF(IUHF.EQ.0)THEN
          CALL SCOPY(LENGTH,SCR(I000),1,SCR(I010),1)
          CALL SPNTSING(LENGTH,SCR(I010),SCR(I020),MAXCOR-I010+1,
     $       IRREPX, ICALC)
          Z=SQRT(SDOT(LENGTH,SCR(I000),1,SCR(I010),1))
         ELSE  
          Z=SQRT(SDOT(LENGTH,SCR(I000),1,SCR(I000),1))
         ENDIF
         CALL SSCAL(LENGTH,ONE/Z,SCR(I000),1)
        ENDIF
        CALL PUTLST(SCR(I000),6+NDIMNEW-INEW+1,1,1,1,LISTH0)
12     CONTINUE
C 
       DO 14 INEW=1,NDIMNEW
        CALL GETLST(SCR,6+NDIMNEW-INEW+1,1,1,1,LISTH0)
        CALL PUTLST(SCR,NDIMNEW-INEW+1,1,1,ISIDE,LIST)
14     CONTINUE
C
      ENDIF
C
      RETURN
1000  FORMAT(T3,'@TRNSPACE-F, Using in-core truncation algorithm.')
1001  FORMAT(T3,'@TRNSPACE-F, Using out-of-core truncation algorithm.')
1002  FORMAT(T3,'@TRNSPACE-F, Insuffient core for truncation of ',
     &          'expansion space.')
      END
