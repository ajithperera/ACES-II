      SUBROUTINE S1PPPHS2(ICORE,MAXCOR,IUHF,ISIDE, ISPIN)
C
C   THIS SUBROUTINE CALCULATES THE CONTRIBUTION OF S1 TO
C   S2 INVOLVING THE PPPH BLOCK OF EFFECTIVE INTEGRALS W.
C
C CONTRACTION :
C
C     Z(Ab,Mp) = SUM  <Ab|Mc> s1(c,p)  [SPIN ADAPTED RHF]
C                 c
CEND
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION ONE,ONEM,ZILCH, FACTOR
      logical print
C
      DIMENSION ICORE(MAXCOR),NC(8),NM(8)
      DIMENSION LISTW0(2,2)
C
C  LISTW0 IS PARAMETRIZED AS (IVRTSPIN=ISPIN, IMIXSPIN)
C
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON /SYM/ POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON /SINFO/ NS(8), SIRREP
      COMMON/SLISTS/LS1IN, LS1OUT, LS2IN(2,2), LS2OUT(2,2)
C
      DATA ONE  /1.0/
      DATA ZILCH/0.0/
      DATA ONEM/-1.0/
C     
C    LISTS FOR RHF CASE:
C
C     30: AbCi [V -> W(Ci, Ab)], ordered according to Ab;Ci (iside = 2)
C     130: AbCi, Wintegrals, ordered according to Ab; Ci  (iside = 1)
C
      LISTW0(1,1) = 27
      LISTW0(1,2) = 30
      LISTW0(2,1) = 29
      LISTW0(2,2) = 28
C
C  ALL LISTS ARE ORDERED AB, CI, EXCEPT LIST 29: AB, IC -> SPECIAL TREATMENT
C  FIRST INDEX: A,C : IVRTSPIN, SECOND INDEX B,I: IMIXSPIN
C
      LISTS1IN = LS1IN
C
C READ IN S1(C,P) COEFFICIENTS
C
      I000 = 1
      I010 = I000 + VRT(SIRREP,ISPIN) * NS(SIRREP) * IINTFP
C
C GET S1 COEFFIENTS
C
      CALL GETLST(ICORE(I000),1,1,1,ISPIN,LISTS1IN)
C
      DO 50 IMIXSPIN = 1, 1+IUHF
         MSPIN = IMIXSPIN
         CSPIN = ISPIN
         LISTS2EX = LS2OUT(ISPIN, IMIXSPIN+1-IUHF)
         LISTW = LISTW0(ISPIN, IMIXSPIN+1-IUHF) + (2 - ISIDE) * 100
C
C LOOP OVER IRREPS OF RHS OF W VECTOR
C
       DO 100 MIRREP=1,NIRREP
        XIRREP=DIRPRD(MIRREP,SIRREP)
        IRREPW=XIRREP
        DISSYW=IRPDPD(IRREPW,ISYTYP(1,LISTW)) 
        NUMDSW=VRT(SIRREP,CSPIN) * POP(MIRREP,MSPIN)
        DISSYS=IRPDPD(XIRREP,ISYTYP(1,LISTS2EX))
        NUMDSS=POP(MIRREP,MSPIN) * NS(SIRREP)
        MAXW=MAX(NUMDSW,DISSYW)
        I020=I010+IINTFP*DISSYW*NUMDSW
        I030=I020+IINTFP*MAX(DISSYS*NUMDSS,3*MAXW)
        IF(I030.GT.MAXCOR)THEN
C
C OUT-OF-CORE ALGORITHM
C
         WRITE(6,*)' out-of-core AB not coded, s1ppphs2'
         WRITE(6,1000) I030, MAXCOR
 1000    FORMAT('  REQUIRED MEMORY :', I12, '  AVAILABLE : ', I12)
         call errex
C
        ENDIF
C
C
C DO IN-CORE ALGORITHM
C
C
C READ W 
C     
C  SPECIAL TREATMENT OF LISTS 29, 129
C
        IF (MOD(LISTW,100).EQ.29) THEN
C
C        W(ABM,C), ALREADY IN PROPER ORDER
C
C        ONLY THE INTEGRALS CIRREP=SIRREP, MIRREP ARE NEEDED
C        THEREFORE CALCULATE OFFSET.
C
           NFIRST = 1
           DO 110 CIRREP = 1, (SIRREP -1)
              IRREPM = DIRPRD(CIRREP, XIRREP)
              NFIRST = NFIRST + VRT(CIRREP,CSPIN)*POP(IRREPM,MSPIN)
 110          CONTINUE
         CALL GETLST(ICORE(I010),NFIRST,NUMDSW,1,IRREPW,LISTW)
         FACTOR = ONE
C     
         ELSE
C
C        READ W INTO W(ABCM) 
C        AND TRANSPOSE BOTH BRA AND KET INDICES TO YIELD W(BAM, C)
C        ONLY THE INTEGRALS CIRREP=SIRREP, MIRREP ARE NEEDED
C        THEREFORE CALCULATE OFFSET.
C
           NFIRST = 1
           DO 115 IRREPM = 1, (MIRREP -1)
              CIRREP = DIRPRD(IRREPM, XIRREP)
              NFIRST = NFIRST + VRT(CIRREP,CSPIN)*POP(IRREPM,MSPIN)
 115       CONTINUE
         CALL GETLST(ICORE(I010),NFIRST,NUMDSW,1,IRREPW,LISTW)
          ITMP1=I020
          ITMP2=ITMP1+IINTFP*MAXW
          ITMP3=ITMP2+IINTFP*MAXW
          ITMP4=ITMP3+IINTFP*MAXW
C
C WE ONLY HAVE 1 PARTICULAR SYMMETRY TYPE OF THE C AND M INDICES, AND
C THIS SHOULD BE PASSED TO SYMTR1 WHEN CALCULATING W(AB;CM) -> W(AB;MC)
C
          CALL IZERO(NC,8)
          CALL IZERO(NM,8)
          NC(SIRREP) =VRT(SIRREP,CSPIN)
          NM(MIRREP)=POP(MIRREP,MSPIN)
          CALL SYMTR1(IRREPW,NC,NM,DISSYW,ICORE(I010),
     &                ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
C 
C ALSO CARRY OUT THE TRANSPOSE OF A AND B W(AB, MC) -> W(BA,MC)
C IF ISPIN = MSPIN THIS AMOUNTS TO A MINUS SIGN
C
          IF ((IUHF.EQ.0) .OR. (ISPIN.NE.MSPIN)) THEN
             FACTOR = ONE
             CALL SYMTR3(IRREPW, VRT(1,ISPIN), VRT(1,MSPIN), DISSYW,
     $          NUMDSW, ICORE(I010),ICORE(ITMP1), ICORE(ITMP2),
     $          ICORE(ITMP3))
          ELSE
             FACTOR = ONEM
          ENDIF
       ENDIF
C
C READ S2 VECTOR TO BE UPDATED
C
         CALL GETLST(ICORE(I020),1,NUMDSS,1,XIRREP,LISTS2EX)
C
C PERFORM MATRIX MULTIPLICATION
C
C         
C         Z(BAM,P) = SUM W(BAM,C) * S(C,P)
C                     C
C  
          NROW=DISSYW*POP(MIRREP,MSPIN)
          NCOL=NS(SIRREP)
          NSUM=VRT(SIRREP,CSPIN)
         print = .false.
         if ((print) .and.( (ncol*nsum*nrow).gt.0)) then
            write(6,*)' output s before multiplication, irrep', xirrep
            write(6,*)' iside, ispin, mspin ', iside, ispin, mspin
            write(6,*)' listw, lists2ex', listw, lists2ex
            call output(icore(i020), 1, nrow, 1, ncol,
     $         nrow, ncol,1)
            write(6,*)' input integrals'
            call output(icore(i010), 1,nrow, 1, nsum, nrow, nsum, 1)
         endif
          CALL XGEMM('N','N',NROW,NCOL,NSUM,FACTOR,ICORE(I010),NROW,
     &               ICORE(I000),NSUM,ONE,ICORE(I020),NROW)
          call checksum("s1-s2  :",icore(i020),numdss*dissys)
          CALL PUTLST(ICORE(I020),1,NUMDSS,1,XIRREP,LISTS2EX)
 100   CONTINUE
 50   CONTINUE
C
      RETURN
      END
