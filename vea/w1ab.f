      SUBROUTINE W1AB(W,Z,MAXSIZE,T1A,T1B,FACT,ADD,VRT1,VRT2,POP1,
     &                POP2,DISSYZ,DISSYWA,DISSYWB,NUMSYZ,NUMSYWA,
     &                NUMSYWB,LISTWA,LISTWB,LISTZ,IRREP,IUHF,TMP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL ADD
      INTEGER DISSYZ,DISSYWA,DISSYWB,DISMAX,DISWRITE,DISLEFT,DIRPRD,
     &        POP1,POP2,VRT1,VRT2
      DIMENSION Z(DISSYZ,1),W(DISSYWA,1),T1A(1),T1B(1),TMP(1)
      DIMENSION POP1(8),POP2(8),VRT1(8),VRT2(8) 
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),
     &                DIRPRD(8,8)
C
      DATA AZERO,ONE,HALF/0.0D0,1.0D0,0.5D0/
C
C GET INTEGRALS <Ef//Am> FROM LISTWA, WE NEED THEM ANYWAY
C
       CALL GETLST(W,1,NUMSYWA,2,IRREP,LISTWA)
C
C DECIDE ABOUT ALGORITHM
C
       IF(MAXSIZE.GE.DISSYZ*NUMSYZ) THEN
C
C  FULL IN CORE
C
        CALL GETLST(Z,1,NUMSYZ,1,IRREP,LISTZ)
        CALL MTRAN2(Z,DISSYZ) 
        IF(IUHF.EQ.0) CALL SSCAL(NUMSYZ*DISSYZ,HALF,Z,1)
C
C PERFORM MULTIPLICATION
C
        JOFFW=1
        JOFFZ=1
        IOFF=1
C
        DO 90 IRREPJ=1,NIRREP
C
         NOCCJ=POP2(IRREPJ)
         NVRTJ=VRT2(IRREPJ)
C
         IRREPI=DIRPRD(IRREPJ,IRREP)
C
         NVRTI=VRT1(IRREPI)
C
         IF(MIN(NVRTI,NVRTJ,NOCCJ).NE.0) THEN
C
          CALL XGEMM('N','T',DISSYWA*NVRTI,NVRTJ,NOCCJ,FACT,W(1,JOFFW),
     &               DISSYWA*NVRTI,T1B(IOFF),NVRTJ,ONE,Z(1,JOFFZ),
     &               DISSYZ*NVRTI)
         ENDIF
C
C  UPDATE OFFSETS
C
         JOFFW=JOFFW+NVRTI*NOCCJ
         JOFFZ=JOFFZ+NVRTJ*NVRTI
         IOFF=IOFF+NOCCJ*NVRTJ
C
90     CONTINUE
C
C IN RHF, THE SECOND TERM IS THE TRANSPOSED OF THE FIRST
C
       IF(IUHF.EQ.0) THEN
        CALL SYMRHF(IRREP,VRT1,VRT1,DISSYZ,Z,TMP,TMP(1+DISSYZ),
     &              TMP(1+2*DISSYZ))
        CALL MTRAN2(Z,DISSYZ)
        CALL PUTLST(Z,1,NUMSYZ,1,IRREP,LISTZ)
       ELSE
C
C  UHF, THE SECOND TERM MUST BE CALCULATED EXPLICITELY
C
        CALL SYMTR1(IRREP,VRT1,VRT2,DISSYZ,Z,TMP,TMP(1+DISSYZ),
     &              TMP(1+2*DISSYZ))
C
C  GET INTEGRALS <Ef/Ma> FROM LISTWB
C
        CALL GETLST(W,1,NUMSYWB,2,IRREP,LISTWB)
        CALL SYMTR1(IRREP,POP1,VRT2,DISSYWB,W,TMP,TMP(1+DISSYWB),
     &             TMP(1+2*DISSYWB))
C
        IOFF=1
        JOFFW=1
        JOFFZ=1
        DO 190 IRREPI=1,NIRREP
C
         NOCCI=POP1(IRREPI)
         NVRTI=VRT1(IRREPI)
C
         IRREPJ=DIRPRD(IRREP,IRREPI)
C 
         NVRTJ=VRT2(IRREPJ)
C
         IF(MIN(NOCCI,NVRTI,NVRTJ).NE.0) THEN
C
          CALL XGEMM('N','T',DISSYWB*NVRTJ,NVRTI,NOCCI,FACT,W(1,JOFFW),
     &               DISSYWB*NVRTJ,T1A(IOFF),NVRTI,ONE,Z(1,JOFFZ),
     &               DISSYZ*NVRTJ)
         ENDIF
C
C  UPDATE OFFSETS
C
         JOFFW=JOFFW+NVRTJ*NOCCI
         JOFFZ=JOFFZ+NVRTJ*NVRTI
         IOFF=IOFF+NOCCI*NVRTI
190     CONTINUE
        CALL SYMTR1(IRREP,VRT2,VRT1,DISSYZ,Z,TMP,TMP(1+DISSYZ),
     &              TMP(1+2*DISSYZ))
        CALL MTRAN2(Z,DISSYZ)
        CALL PUTLST(Z,1,NUMSYZ,1,IRREP,LISTZ)
       ENDIF
      ELSE
C         write(6,*) ' out-of-core w1ab'
C
C  WE HAVE TO DO IT OUT OF CORE
C
C  DETERMINE FIRST THE NUMBER OF DISTRIBUTIONS WHICH FIT INTO CORE
C
       DISMAX=MAXSIZE/(MAX(2*DISSYZ,DISSYZ+MAX(NUMSYWA,NUMSYWB))) 
       IF(DISMAX.EQ.0) STOP 'W1AB'
C
C  SET OFFSET FOR TARGET LIST
C
       IOFFSET=1
C
C  SET OFFSET FOR TOP HALF OF THE Z ARRAY
C
       IOFFW=1+DISMAX*DISSYZ 
C
C  SET NUMBER OF DISTRIBUTIONS TO BE CALCULATED
C
       DISLEFT=NUMSYZ
C
10     CONTINUE
C
C  DETERMINE NUMBER OF DISTRIBUTIONS TO CALCULATE DURING THIS PASS
C
        DISWRITE=MIN(DISLEFT,DISMAX)
        DISLEFT=DISLEFT-DISWRITE
C
C  INITIALIZE TARGET ARRAY WITH INTEGRALS
C
        CALL GETLST(Z(IOFFW,1),IOFFSET,DISWRITE,1,IRREP,LISTZ)
        CALL TRANSP(Z(IOFFW,1),Z,DISWRITE,DISSYZ)
        IF(IUHF.EQ.0) CALL SSCAL(DISWRITE*DISSYZ,HALF,Z,1)
C
C  COPY INTEGRALS TO THE NEW LOCATION
C
        IOFFW2=0
        DO 180 INUM=1,NUMSYWA
c YAU : old
c        CALL ICOPY(IINTFP*DISWRITE,W(IOFFSET,INUM),1,Z(IOFFW+IOFFW2,1),1)
c YAU : new
         CALL DCOPY(DISWRITE,W(IOFFSET,INUM),1,Z(IOFFW+IOFFW2,1),1)
c YAU : end
         IOFFW2=IOFFW2+DISWRITE
180     CONTINUE 
C
C  PERFORM MULTIPLICATION
C
        JOFFW=IOFFW
        JOFFZ=1
        IOFF=1
        DO 290 IRREPJ=1,NIRREP
         NOCCJ=POP2(IRREPJ)
         NVRTJ=VRT2(IRREPJ)
         IRREPI=DIRPRD(IRREP,IRREPJ)
         NVRTI=VRT1(IRREPI)
C
         IF(MIN(NVRTI,NOCCJ,NVRTJ).NE.0) THEN
C
          CALL XGEMM('N','T',DISWRITE*NVRTI,NVRTJ,NOCCJ,FACT,
     &               Z(JOFFW,1),DISWRITE*NVRTI,T1B(IOFF),NVRTJ,
     &               ONE,Z(JOFFZ,1),DISWRITE*NVRTI)
         ENDIF
C
C  UPDATE OFFSETS
C
         JOFFW=JOFFW+DISWRITE*NVRTI*NOCCJ
         JOFFZ=JOFFZ+DISWRITE*NVRTI*NVRTJ
         IOFF=IOFF+NOCCJ*NVRTJ
290     CONTINUE
C
        CALL TRANSP(Z,Z(IOFFW,1),DISSYZ,DISWRITE)
        CALL PUTLST(Z(IOFFW,1),IOFFSET,DISWRITE,1,IRREP,LISTZ)
C
C  UPDATE IOFFSET
C
        IOFFSET=IOFFSET+DISWRITE
C
C  IF NOT ALL TARGET DISTRIBUTIONS HAVE BEEN FORMED, GO BACK TO 10
C
       IF(DISLEFT.NE.0) GO TO 10
C
       IF(IUHF.EQ.0) THEN
C
C  IN RHF THE SECOND CONTRIBUTION IS THE TRANSPOSED OF THE FIRST
C  DO IT IN AN OUT CORE VERSION OF SYMRHF
C
        CALL SYMRHF2(IRREP,VRT1,VRT1,DISSYZ,Z,Z(IOFFW,1),TMP,
     &               TMP(1+DISSYZ),LISTZ) 
    
C
       ELSE
C
C  SECOND PART FOR UHF
C
C  GET FIRST INTEGRALS 
C
        CALL GETLST(W,1,NUMSYWB,2,IRREP,LISTWB)
C 
        CALL SYMTR1(IRREP,POP1,VRT2,DISSYWB,W,TMP,TMP(1+DISSYWB),
     &              TMP(1+2*DISSYWB))
C
C  SET OFFSET FOR TARGET LIST
C
        IOFFSET=1
C
C  SET NUMBER OF DISTRIBUTIONS TO BE CALCULATED
C
        DISLEFT=NUMSYZ
C
20      CONTINUE 
C 
C  DETERMINE NUMBER OF DISTRIBUTIONS TO BE CALCULATED DURING THIS PASS
C
         DISWRITE=MIN(DISLEFT,DISMAX)
         DISLEFT=DISLEFT-DISWRITE
C
C  INITIALIZE THE TARGET ARRAY
C
         CALL GETLST(Z(IOFFW,1),IOFFSET,DISWRITE,1,IRREP,LISTZ)
         CALL TRANSP(Z(IOFFW,1),Z,DISWRITE,DISSYZ)
         CALL SYMTR1(IRREP,VRT1,VRT2,DISWRITE,Z,TMP,TMP(1+DISWRITE),
     &               TMP(1+2*DISWRITE))
C
C COPY INTEGRALS TO THE NEW LOCATION
C
         IOFFW2=0
         DO 280 INUM=1,NUMSYWB
c YAU : old
c         CALL ICOPY(IINTFP*DISWRITE,W(IOFFSET,INUM),1,Z(IOFFW+IOFFW2,1),1)
c YAU : new
          CALL DCOPY(DISWRITE,W(IOFFSET,INUM),1,Z(IOFFW+IOFFW2,1),1)
c YAU : end
          IOFFW2=IOFFW2+DISWRITE
280      CONTINUE 
C
C PERFORM MULTIPLICATION
C
         JOFFW=IOFFW
         JOFFZ=1
         IOFF=1
         DO 390 IRREPJ=1,NIRREP
          NOCCJ=POP1(IRREPJ)
          NVRTJ=VRT1(IRREPJ)
          IRREPI=DIRPRD(IRREP,IRREPJ)
          NVRTI=VRT2(IRREPI)
C
          IF(MIN(NVRTI,NVRTJ,NOCCJ).NE.0) THEN
C
           CALL XGEMM('N','T',DISWRITE*NVRTI,NVRTJ,NOCCJ,FACT,
     &                Z(JOFFW,1),DISWRITE*NVRTI,T1A(IOFF),NVRTJ,
     &                ONE,Z(JOFFZ,1),DISWRITE*NVRTI)
          ENDIF
C
C  UPDATE OFFSETS
C
          JOFFW=JOFFW+DISWRITE*NVRTI*NOCCJ
          JOFFZ=JOFFZ+DISWRITE*NVRTI*NVRTJ
          IOFF=IOFF+NOCCJ*NVRTJ
390      CONTINUE
C
         CALL SYMTR1(IRREP,VRT2,VRT1,DISWRITE,Z,TMP,TMP(1+DISWRITE),
     &               TMP(1+2*DISWRITE))
         CALL TRANSP(Z,Z(IOFFW,1),DISSYZ,DISWRITE)
         CALL PUTLST(Z(IOFFW,1),IOFFSET,DISWRITE,1,IRREP,LISTZ)
C
C  UPDATE IOFFSET
C
         IOFFSET=IOFFSET+DISWRITE
C
C  IF NOT ALL TARGET DISTRIBUTIONS HAVE BEEN FORMED, GO BACK TO 10
C
        IF(DISLEFT.NE.0)GO TO 20
C
       ENDIF
      ENDIF  
      RETURN
      END
