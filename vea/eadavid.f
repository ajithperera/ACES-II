      SUBROUTINE EADAVID(BUF,BUF3,SCR,MAXCOR,CONVRG,
     &                    NROOT,ISIDE,ISPIN,IUHF,ITER)
C
C DAVIDSON EXTRAPOLATION ROUTINE FOR UNSYMMETRIC MATRICES.  THIS
C APPROACH FOLLOWS THAT OF HIRAO AND NAKATSUJI (J. COMP. PHYS. 45, 246).
C MODIFICATION OF NEXTDAV IN EE-EOM PROGRAM
C THE VECTORS STORED ON DISK ARE AS FOLLOWS:
C
C LISTC  470  - OLD C VECTORS, ONE VECTOR PER LOGICAL RECORD
C LISTHC 471 - OLD HC VECTORS, ONE VECTOR PER LOGICAL RECORD
C LISTH0 472 - DIAGONAL PART OF H, STORED ON ONE LOGICAL RECORD
C
C THESE LISTS ARE USED BY HARD NUMBERS IN CERTAIN PROCEDURES 
C HENCE THEY SHOULD NOT BE MODIFIED.
CEND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER SIRREP, DIRPRD, SPINCORE, VRT, STMODE, STCALC
      DOUBLE PRECISION TIN, TOUT,TIMDUM
      DOUBLE PRECISION TSSTGEN, TEADAVID, TEADIR
      LOGICAL CONVRG, LEFTHAND, EXCICORE, PRINTV, DEGENRCY, ALLOWED
      LOGICAL LOCK,EMINFOL,EVECFOL,PRINT,PRINT2, SINGONLY,
     $    DROPCORE, ADDST, NEWSTART, WRONGL, PRINTTRN
C
      PARAMETER (MAXORD=100)
      PARAMETER (MAXROOT=100)
C
      DIMENSION BUF(MAXORD*(2*MAXORD+3)+5), SCR(MAXCOR)
      DIMENSION BUF3(MAXORD*MAXORD),sjunk(100)
C
      COMMON/LISTDAV/LISTC, LISTHC, LISTH0
      COMMON/EXTINF/NDIMR,IOLDEST
      COMMON/EXTINF2/ROOT
      COMMON/EXTINF3/IROOT,LOCROOT,ITROOT
      COMMON/ROOTS/EIGVAL(100,8,3), OSCSTR(100,8,3)
      COMMON/EXTRAP/MAXEXP,NREDUCE,NTOL,NSIZEC
      COMMON/SYMPOP/IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON/SYM/POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/RMAT/ R(10000), P(10000)
      COMMON/FLAGS/IFLAGS(100)
      COMMON/CNVRGE/EMINFOL,EVECFOL
      COMMON /SINFO/ NS(8), SIRREP
      COMMON/STINFO/ITOTALS, STMODE, LISTST, STCALC, NSIZEST
      COMMON/SLISTS/LS1IN, LS1OUT, LS2IN(2,2), LS2OUT(2,2)
      COMMON/EACALC/LEFTHAND, EXCICORE, SINGONLY, DROPCORE
      COMMON/DIPSYM/IRREPDIP(3)
      COMMON/COREINFO/IREPCORE, SPINCORE, IORBCORE, IORBOCC
      COMMON /SYMINF/ NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON /TIMSUB/ TSSTGEN, TEADAVID, TEADIR
      COMMON /TIMEINFO/ TIMEIN, TIMENOW, TIMETOT, TIMENEW
C
      DATA ONE,ONEM,ZILCH,TWO /1.0D0,-1.0D0,0.0D0,2.0D0/
      DATA FACT /27.2113957D0/
      SAVE LOCK, ISTRATEG
C
      INDXF(I,J,N)=I+(J-1)*N
      IGET(I)=1+MOD(IOLDEST+MAXORD-I,MAXORD+1)
C
      CALL TIMER(1)
      IRREPX = SIRREP
C
      ADDST = .FALSE.
      IF (EXCICORE) THEN
         ADDST = (STMODE .NE. 0) .AND. (ISPIN.EQ.SPINCORE)
      ENDIF
      NEWSTART = .FALSE.
C
C  INDICATES IF ITERATIVE SUBSPACE SHOULD BE TRUNCATED TO THE
C  ALREADY FOUND EIGENVECTORS ONLY. (USED ONLY IF ITERATIONS
C  SEEM TO GO ASTRAY)
C
      WRONGL = .FALSE.
C
C  IF CONVERGED LEFT HAND EIGENVALUE DOES NOT EQUAL CONVERGED RIGHT
C  HAND EIGENVALUE WRONGL = .TRUE. AND A POSSIBLE TRANSITIONMOMENT
C  IS PUT TO 1.0E20
C
      ALLOWED = .TRUE.
      IF (EXCICORE) THEN
         IRREPT = DIRPRD(SIRREP, IREPCORE)
         ALLOWED = .FALSE.
         DO 7 IXYZ = 1, 3
            ALLOWED = ((IRREPT .EQ. IRREPDIP(IXYZ)) .OR. ALLOWED)
 7       CONTINUE
         ALLOWED = ALLOWED .AND. ((ITOTALS.EQ.0) .OR.
     $      (STMODE .NE. 2))
      ENDIF
      NSPECIAL = 18
      IF (LEFTHAND .AND. ALLOWED) THEN
         NSPECIAL = 18
      ENDIF
C
      PRINTV = .TRUE.
      PRINTTRN = .FALSE.
      PRINT2 = .FALSE.
      PRINT  = .FALSE.
C
      IF (SINGONLY) THEN
         EXCPTHRS = 0.25
      ELSE
         EXCPTHRS = 0.90
      ENDIF
      THRESH = -100.0
C
C   EA ABOVE THRESH ARE SEARCHED FOR, THIS IN CASE OF CORE-EXCITATIONS.
C   THRESH SHOULD BE REDUNDANT ONCE EXCP IS IMPLEMENTED.
C
      DEGTOL=10.0D0**(-NTOL)
      ZFACT =ONE/SQRT(TWO)
      IF(NDIMR.EQ.1)THEN
         IOLDEST=1
         LOCK=.FALSE.
      ENDIF
      IONE=1
      ICALC = 2
C
C  ICALC = 2 REFERS TO EA-EOM CALCULATIONS. IT IS NEEDED
C  TO DEFINE THE SPINADAPTATION IN SPNTSING WHICH OCCURS IN
C  A NUMBER OF PROCEDURES, WHICH ARE IDENTICAL TO THE EE-EOM CODE
C
C MOVE MOST RECENT H*C VECTOR TO MOST CURRENT LOCATION.  DO SAME
C FOR C (NECESSARY IF THIS IS THE FIRST ITERATION).
C
      I000 = 1
      I010 = I000 + NSIZEC
      I020 = I010 + NSIZEC
      CALL LOADS(SCR(I000),NSIZEC,ISPIN, IUHF, LS1IN, LS2IN,.FALSE.,
     $   SCR(I010),MAXCOR-I010+1)
      if (print2) then
         write(6,*) ' current C-vector, before projecting'
         call output(scr(i000),1,1,1,nsizec,1,nsizec,1)
      endif
C
      CALL PUTLST(SCR(I000),IOLDEST,1,1,ISIDE,LISTC)
C
      CALL LOADS(SCR(I000),NSIZEC,ISPIN, IUHF, LS1OUT, LS2OUT,.FALSE.,
     $   SCR(I020),MAXCOR-I020+1)
      if (print2) then
         write(6,*) ' current HC-vector, before projecting'
         call output(scr(i000),1,1,1,nsizec,1,nsizec,1)
      endif
C
      IF (EXCICORE) THEN
C
C PROJECT OUT THE COMPONENTS THAT CORRESPOND TO SPIN-FLIP EXCITATIONS
C
         CALL GETLST(SCR(I010),6,1,1,1,LISTH0)
         CALL VECPRD(SCR(I000),SCR(I010),SCR(I000),NSIZEC)
      if (print2) then
         write(6,*) ' current HC-vector, after projecting'
         call output(scr(i000),1,1,1,nsizec,1,nsizec,1)
      endif
      ENDIF
C
      CALL PUTLST(SCR,IOLDEST,1,1,ISIDE,LISTHC)
C
      IOLDEST=1+MOD(IOLDEST,MAXORD+1)
C
C AUGMENT EXISTING SUBSPACE MATRIX AND OVERLAP MATRIX OF PROJECTED VECTORS
C
      CALL AUGMENTR(SCR, MAXCOR, ISIDE, IUHF, ICALC)
C
C DIAGONALIZE SUBSPACE MATRIX AND DETERMINE NORMS OF PROJECTED EIGENVECTORS
C
      CALL DIAGR(BUF3, BUF, MAXORD, IEVAL, IEVEC, IEXCP,
     $   IEVALSEL,EXCPTHRS,PRINT)
C
C FOLLOW EIGENVECTOR ASSOCIATED WITH LOWEST UNCONVERGED EIGENVALUE
C
C      IF(NDIMR.NE.1)CALL GETREC(20,'JOBARC','LASTVCTR',100*IINTFP,SJUNK)
C
      IF (ISIDE.EQ.2) THEN
         ROOTR = EIGVAL(IROOT+1,IRREPX,ISPIN+1-ITOTALS)
         CALL FNDLEFT(NDIMR,ROOTR,BUF(IEVAL),
     $      EIGVAL(1,IRREPX,ISPIN+1-ITOTALS)
     $      ,SCR,IROOT, Z, ILOC, 1.0D-3, THRESH)
C
C LOCK ON ROOT IF RELATIVE CHANGE IN EIGENVALUE IS LESS THAN TOLERANCE
C
            IF(ROOT.NE.ZILCH)THEN
               XTEST=ABS((BUF(ILOC)-ROOT)/ROOT)
            ELSE
               XTEST=ABS(BUF(ILOC)-ROOT)
            ENDIF
            IF(ABS(XTEST).LT.1.D-3.AND.ITER.NE.1)THEN
               LOCK=.TRUE.
            ENDIF
      ELSE
C
         IF(.NOT.LOCK)THEN
            IF(EMINFOL .OR. (NDIMR .EQ. 1))THEN
               CALL FNDMINE(NDIMR,BUF(IEVALSEL),
     $            EIGVAL(1,IRREPX,ISPIN+1-ITOTALS),
     $            SCR, IROOT,Z,ILOC,1.D-3, THRESH)
            ELSEIF(EVECFOL.AND.NDIMR.NE.1)THEN
               CALL FNDMAXS(NDIMR,SJUNK,BUF(IEVEC),NDIMR,
     &            SCR,OVRLAP,ILOC)
            ENDIF
C
C LOCK ON ROOT IF RELATIVE CHANGE IN EIGENVALUE IS LESS THAN TOLERANCE
C
            IF(ROOT.NE.ZILCH)THEN
               XTEST=ABS((BUF(ILOC)-ROOT)/ROOT)
            ELSE
               XTEST=ABS(BUF(ILOC)-ROOT)
            ENDIF
            IF(ABS(XTEST).LT.1.D-3.AND.ITER.NE.1)THEN
               LOCK=.TRUE.
               WRITE(6,*)' L-O-C-K-I-N-G O-N R-O-O-T '
            ENDIF
         ELSE
C
C LOCK = TRUE
C
            CALL FNDCLOSE(NDIMR, BUF(IEVALSEL), ROOT, XCLOSE, ILOC)
         ENDIF
      ENDIF
      IF(ROOT.NE.ZILCH)THEN
         XTEST=ABS((BUF(ILOC)-ROOT)/ROOT)
      ELSE
         XTEST=ABS(BUF(ILOC)-ROOT)
      ENDIF
      IF((ABS(XTEST).GT.5.D-2) .AND. LOCK) THEN
         WRITE(6,*) ' UNLOCKING ROOT, NOT STABLE YET '
         LOCK=.FALSE.
      ENDIF
C
      IF(NDIMR.EQ.1)THEN
         CALL ZERO(SJUNK,NDIMR+1)
         ILOC=1
         CALL SCOPY(NDIMR,BUF(IEVEC+(ILOC-1)*NDIMR),1,SJUNK(2),1)
C     CALL PUTREC(20,'JOBARC','LASTVCTR',100*IINTFP,SJUNK)
      ENDIF
C
      IBUFLC=IEVEC-1+INDXF(1,ILOC,NDIMR)
      ROOT=BUF(ILOC)
      EXCPOVRL = BUF(IEXCP+ILOC-1)
C
C  POSITION OF SOUGHT FOR EIGENVECTOR IN BUF
C
      OVRLAP=SDOT(NDIMR,SJUNK,1,BUF(IBUFLC),1)
C
      CALL FNDCLOSE(NDIMR, BUF, ZILCH, XZERO, IDUM)
      IF(ABS(XZERO).LT.1.0D-5)THEN
         WRITE(6,*)' SUBSPACE EIGENVALUES CLOSE TO ZERO !!'
      ENDIF
C
      CALL ZERO(SJUNK,NDIMR+1)
      CALL SCOPY(NDIMR,BUF(IBUFLC),1,SJUNK(2),1)
C     CALL PUTREC(20,'JOBARC','LASTVCTR',100*IINTFP,SJUNK)
C
C CALCULATE RESIDUAL : [H C(new) - E C(new)]
C
      CALL RESVEC(SCR, MAXCOR, BUF, MAXORD, ISIDE, IBUFLC)
C
      I000 = 1
      I010 = I000 + NSIZEC
      I020 = I010 + NSIZEC
C
      IF (EXCICORE) THEN
C
C PROJECT OUT THE COMPONENTS THAT CORRESPOND TO SPIN-FLIP EXCITATIONS
C    (SHOULD NOT BE NECESSARY)
C
         CALL GETLST(SCR(I010),6,1,1,1,LISTH0)
         CALL VECPRD(SCR(I000),SCR(I010),SCR(I000),NSIZEC)
      ENDIF
C
C  FIND THE LARGEST COMPONENT IN THE ERROR VECTOR (ON SCR(I000))
C
      CALL FNDMAXD(NSIZEC, SCR(I000), DIFF, IOLD, RMS)
C
      IF((DIFF.GT.DEGTOL) .and. (iter .lt. 29)) THEN
         CONVRG=.FALSE.
C
C FIND NEW TRIAL VECTOR BY APPLYING THE DAVIDSON CORRECTION. SAVE THE 
C ERROR VECTOR IN CASE DAVIDSON CORRECTION LEADS TO LINEAR DEPENDENCIES.
C
         CALL PUTLST(SCR(I000), 7, 1, 1, 1, LISTH0)
         write(6,*)
         Print*, "New vectors created for the next iteration?-1"
         write(6,"(6(1x,F10.5))") (scr(i000+i-1),i=1,nsizec)
         if (iuhf.eq.0) call check_ab2aa(scr(i000),nsizec,
     &                    scr(i020),maxcor-i020,1)
C
         CALL GSORTHOG(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &      SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     &      RESID,ICALC) 
         IF (ABS(1.0D0-RESID) .GT. 1.0D-10) THEN
            WRITE(6,'(A,E12.6)')' TROUBLES ANTICIPATED ',
     $         (1.0D0 - RESID)
         ENDIF
         write(6,*)
         Print*, "New vectors created for the next iteration?-21"
         write(6,"(6(1x,F10.5))") (scr(i000+i-1),i=1,nsizec)
         if (iuhf.eq.0) call check_ab2aa(scr(i000),nsizec,
     &                    scr(i020),maxcor-i020,1)
C
         IF (MOD(ITER, NSPECIAL) .NE. 0) THEN
C            
            call getlst(scr(i000),7,1,1,1,listh0)
            CALL GETLST(SCR(I010),1,1,1,1,LISTH0)
            write(6,*)
            Print*, "New vectors created for the next iteration?-20"
            write(6,"(6(1x,F10.5))") (scr(i010+i-1),i=1,nsizec)
            if (iuhf.eq.0) call check_ab2aa(scr(i010),nsizec,
     &                     scr(i020),maxcor-i020,1)
            CALL VECDIV2(ROOT,SCR(I000),SCR(I010),SCR(I000),NSIZEC)
            write(6,*)
            Print*, "New vectors created for the next iteration?-22"
            write(6,"(6(1x,F10.5))") (scr(i000+i-1),i=1,nsizec)
            if (iuhf.eq.0) call check_ab2aa(scr(i000),nsizec,
     &                     scr(i020),maxcor-i020,1)
C
C SCHMIDT ORTHOGONALIZE NEW BASIS VECTOR TO EXISTING SPACE.
C
            CALL GSORTHOG(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &         SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     &         RESID,ICALC) 
C
         ELSE
            WRITE(6,*) ' ITERATION VECTOR BASED ON UNSCALED RESIDUE'
         ENDIF
C
      WRITE(6,5000)ITER,NDIMR,ROOT,DIFF,RMS,IOLD
C
      IF (RESID .GT. 0.05) THEN
         ISTRATEG = 0
      ELSE
        WRITE(6,'(1X,A,E12.3)')' LINEAR DEPENDANCY DETECTED: ', RESID
C
        IF (ISTRATEG .EQ. 0) THEN
           WRITE(6,*) ' ONE MORE ITERATION IN USUAL WAY'
           ISTRATEG = ISTRATEG + 1
           ELSEIF (ISTRATEG .EQ. 1) THEN
              CALL GETLST(SCR(I000), 7, 1, 1, 1, LISTH0)
              CALL GSORTHOG(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &           SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     &           RESID,ICALC) 
           WRITE(6,'(1X,A,E12.3)') ' TRIAL BASED ON UNSCALED RESIDUE',
     $           RESID
              ISTRATEG = ISTRATEG + 1
           ELSEIF (ISTRATEG .EQ. 3) THEN
              CALL DUALRES(SCR, MAXCOR, IRREPX, ISIDE,
     $           IUHF, ISPIN)
              CALL GSORTHOG(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &           SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     $           RESID,ICALC) 
          WRITE(6,'(1X,A,E12.3)') ' NEW TRIAL BASED ON DUAL RESIDUAL ',
     $           RESID
              ISTRATEG = ISTRATEG+1
           ELSEIF (ISTRATEG .EQ. 2) THEN
              CALL DUALRES(SCR, MAXCOR, IRREPX, ISIDE,
     $           IUHF, ISPIN)
              CALL GETLST(SCR(I010),1,1,1,1,LISTH0)
              CALL VECDIV2(ROOT,SCR(I000),SCR(I010),
     $           SCR(I000),NSIZEC)
              CALL GSORTHOG(IRREPX,NSIZEC,NDIMR,SCR(I000),
     $           SCR(I010),SCR(I020),ISIDE,LISTC,IUHF.EQ.0,
     $           IOLDEST,MAXORD,RESID,ICALC)
         WRITE(6,'(1X,A,E12.3)') 'TRIAL BASED ON SCALED DUAL RESIDUAL ',
     $           RESID
              ISTRATEG = ISTRATEG + 1
           ENDIF
        ENDIF
        IF (ISTRATEG .GT. 1) ISTRATEG = 0
C
C  NEW ITERATION VECTOR CONSTRUCTED, CONVRG = .FALSE. HAS BEEN 
C  DEALT WITH.
C
C  NEXT CONSIDER CONVRG = .TRUE.
C
      ELSE
C
         if ((iter .eq. 29) .and. (diff .gt. degtol)) then
            write(6,*) ' iter =29: Fake convergence '
            IF (DIFF .GT. 1.0E-2) THEN
               NEWSTART = .TRUE.
               write(6,*) ' DAVIDSON PROCEDURE IS RESTARTED'
            ENDIF
         endif
C         WRITE(6,5000)ITER,NDIMR,ROOT,ABS(OVRLAP),DIFF, IOLD
         WRITE(6,5000)ITER,NDIMR,ROOT,DIFF, RMS, IOLD
         CONVRG=.TRUE.
         IROOT=IROOT+1
C
         IF (ISIDE.EQ.1) THEN
C
C WRITE OUT SOME INFO ON ROOT FOUND
C     
            write(6,1300)
            WRITE(6,*)' CONVERGED EIGENVALUE:  ',root,' A.U.'
            WRITE(6,*)'                        ',root*fact,' eV'
            EIGVAL(IROOT,IRREPX,ISPIN+1-ITOTALS)=ROOT
            CALL GETREC(20,'JOBARC','TOTENERG',IINTFP,ECC)
            WRITE(6,99)ECC+ROOT
 99    FORMAT('  TOTAL EA-EOM-CCSD ELECTRONIC ENERGY',F15.8,' A.U.')
            CALL PUTREC(20,'JOBARC','TOTENER2',IINTFP,ECC+ROOT)
C
C CHECK ON POSSIBLE DEGENERACY
C
            IF (IROOT.EQ.1) THEN
               DEGENRCY = .FALSE.
            ELSE
               CALL FNDCLOSE(IROOT-1,EIGVAL(1,IRREPX,ISPIN+1-ITOTALS),
     $            ROOT,TEST,ITEST)
               IF (ABS(ROOT - TEST) .LT. DEGTOL) THEN
            WRITE(6,*) ' CURRENT ROOT IS DEGENERATE WITH ROOT ',ITEST
                  OSCSTR(IROOT, IRREPX,ISPIN+1-ITOTALS) = 1.0D30
                  DEGENRCY = .TRUE.
               ELSE
                  DEGENRCY = .FALSE.
               ENDIF
            ENDIF
C
         ELSE
            IF (ABS(EIGVAL(IROOT,IRREPX,ISPIN+1-ITOTALS) - ROOT)
     $         .GT. 5.0D-3) THEN
               WRITE(6,*)' WARNING !!! LEFT AND RIGHT ROOT',
     $            ' ARE NOT EQUAL !'
               WRONGL = .TRUE.
            ENDIF
         ENDIF
C
C PUT CONVERGED VECTOR ON LISTH0
C
         CALL FORMS(NSIZEC,NDIMR,SCR(I000),SCR(I010),BUF(IBUFLC),
     &      ISIDE,LISTC,IOLDEST,MAXORD)
         CALL NORMVEC(SCR(I000), NSIZEC, SCR(I010), MAXCOR-I010+1,
     $      IUHF, ICALC, SIRREP)
C     
         IF (PRINTV) THEN
            WRITE(6,1300)
            CALL PUTS(SCR(I000), NSIZEC, ISPIN, IUHF, LS1OUT, LS2OUT)
            WRITE(6,*)' EIGENVECTOR COMPONENTS IROOT =', IROOT
            CALL PRMAINS(IUHF, ISPIN, SCR(I010), MAXCOR-I010+1,"EA")
         ENDIF
C
         IF(LEFTHAND)THEN
            IF (.NOT. ALLOWED) THEN
               WRITE(6,1300)
               WRITE(6,*) ' TRANSITION IS NOT ALLOWED '
               OSCSTR(IROOT, SIRREP, ISPIN+1-ITOTALS) = 0.0D0
            ELSE IF (NEWSTART) THEN
               WRITE(6,1300)
               WRITE(6,*) ' TRANSITION MOMENT IS NOT CALCULATED',
     $            ' BECAUSE'
               WRITE(6,*) ' OF POOR QUALITY CURRENT EIGENVECTOR'
               OSCSTR(IROOT, SIRREP, ISPIN+1-ITOTALS) = 1.0D20
            ELSE
               IF(ISIDE.EQ.1)THEN
                  IF(PRINT)THEN
                     CALL BLKCPY2(R,MAXORD,MAXORD,BUF3,
     $                  NDIMR,NDIMR,1,1)
                     WRITE(6,1106)
 1106                FORMAT(T3,'@NEXTDAV-I, righthand subspace H: ')
                     CALL OUTPUT(BUF3,1,NDIMR,1,NDIMR,NDIMR,NDIMR,1)
                  ENDIF
                  CALL PUTLST(SCR(I000),1+ISIDE,1,1,1,LISTH0)
                  CALL PUTREC(20,'JOBARC','RIGHTDIM',IONE,NDIMR)
                  CALL PUTREC(20,'JOBARC','RIGHTOLD',IONE,IOLDEST)
               ELSEIF (ISIDE.EQ.2) THEN
                  IF(PRINT)THEN
                     CALL BLKCPY2(R,MAXORD,MAXORD,BUF3,
     $                  NDIMR,NDIMR,1,1)
                     WRITE(6,1107)
 1107                FORMAT(T3,'@NEXTDAV-I, lefthand subspace H: ')
                     CALL OUTPUT(BUF3,1,NDIMR,1,NDIMR,NDIMR,NDIMR,1)
                  ENDIF
                  CALL PUTLST(SCR(I000),1+ISIDE,1,1,1,LISTH0)
                  WRITE(6,1300)
                  CALL NORML(SCR(I010), MAXCOR-I010+1,IUHF,ISPIN)
C   Transition moments !!!
                  CALL PUTREC(20,'JOBARC','LEFTDIM',IONE,NDIMR)
                  CALL PUTREC(20,'JOBARC','LEFTOLD',IONE,IOLDEST)
                  ITROOT=ITROOT+1
               ENDIF
            ENDIF
         ENDIF
C
         IF (LEFTHAND.AND.ALLOWED.AND.(ISIDE.EQ.1).AND.
     $      (.NOT.DEGENRCY) .AND. (.NOT. NEWSTART)) THEN
C
            CALL INITLEFT(BUF, BUF3, SCR, MAXCOR, IUHF.EQ.0,
     $         SIRREP, ICALC)
            LOCK = .FALSE.
            IROOT=IROOT-1
            ISIDE=2     
            IF (IROOT .EQ. 0) THEN
               CALL ZERO(R,MAXORD*MAXORD)
               NDIMR = 0
               WRITE(6,1300)
            WRITE(6,'(1X,A,E12.5)') ' STARTING LEFT HAND VECTOR',
     $            ROOT               
               WRITE(6,1300)
            ELSE
C
C RESTORE EXISTING LEFT VECTOR EXPANSION SPACE FOR NEXT ROOT
C
               CALL GETREC(20,'JOBARC','LEFTDIM',IONE,NDIMR)
               CALL GETREC(20,'JOBARC','LEFTOLD',IONE,IOLDEST)
C
C INSERT
               CALL REFORM(R,P,SCR(I010),NDIMR,NSIZEC,IRREPX,
     $            MAXCOR-I010+1, ISIDE,IUHF,ICALC)
               IF (NDIMR .EQ. MAXEXP) THEN
               CALL DIAGR(BUF3, BUF, MAXORD,IEVAL,IEVEC,IEXCP,
     $               IEVALSEL,EXCPTHRS,PRINT2)
               ENDIF
               IF(PRINT)THEN
                  CALL BLKCPY2(R,MAXORD,MAXORD,BUF3,NDIMR,NDIMR,1,1)
                  WRITE(6,1108)
 1108     FORMAT(T3,'@NEXTDAV-I, recovered lefthand subspace H: ')
                  CALL OUTPUT(BUF3,1,NDIMR,1,NDIMR,NDIMR,NDIMR,1)
               ENDIF
C
C  FINISH STARTING VECTOR FOR LEFTHAND
C
               CALL GSORTHOG(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     $            SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     $            RESID,ICALC) 
               WRITE(6,1300)
        WRITE(6,'(1X,A,2E12.5)') ' STARTING LEFT HAND VECTOR',
     $            ROOT,RESID
               WRITE(6,1300)
               IF (RESID .LT. 0.1) THEN
       WRITE(6,'(1X,A,E12.3)') 'LIN. DEP. IN INITIAL LEFT HAND '
               CALL DIAGR(BUF3, BUF, MAXORD, IEVAL, IEVEC, IEXCP,
     $                 IEVALSEL,EXCPTHRS,.false.)
               ROOTR = EIGVAL(IROOT+1,IRREPX,ISPIN+1-ITOTALS)
               CALL FNDLEFT(NDIMR,ROOTR,BUF(IEVALSEL),
     $            EIGVAL(1,IRREPX,ISPIN+1-ITOTALS),
     $            SCR,IROOT, Z, ILOC, 1.0D-3, THRESH)
               ROOT=BUF(ILOC)
               IBUFLC=IEVEC-1+INDXF(1,ILOC,NDIMR)
               CALL RESVEC(SCR, MAXCOR, BUF, MAXORD, ISIDE, IBUFLC)
               IF (EXCICORE) THEN
C
C PROJECT OUT THE COMPONENTS THAT CORRESPOND TO SPIN-FLIP EXCITATIONS
C    (SHOULD NOT BE NECESSARY)
C
                  CALL GETLST(SCR(I010),6,1,1,1,LISTH0)
                  CALL VECPRD(SCR(I000),SCR(I010),SCR(I000),NSIZEC)
               ENDIF
               CALL GETLST(SCR(I010),1,1,1,1,LISTH0)
               CALL VECDIV2(ROOT,SCR(I000),SCR(I010),SCR(I000),NSIZEC)
               CALL GSORTHOG(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &            SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     &            RESID,ICALC)
         WRITE(6,'(1X,A,2E12.5)') ' NEW GUESS: ROOT, RESID', ROOT,RESID
               ENDIF
            ENDIF
C
         ELSEIF (IROOT .LT. NROOT) THEN
C
C ADD NEW VECTOR TO SPACE
C
            LOCK=.FALSE.
            IF (ISIDE.EQ.2) THEN
               ISIDE = 1
C
C RESTORE EXISTING RIGHT VECTOR EXPANSION SPACE FOR NEXT ROOT
C
               CALL GETREC(20,'JOBARC','RIGHTDIM',IONE,NDIMR)
               CALL GETREC(20,'JOBARC','RIGHTOLD',IONE,IOLDEST)
               CALL REFORM(R,P,SCR,NDIMR,NSIZEC,IRREPX,MAXCOR,
     $            ISIDE,IUHF,ICALC)
               IF ((NDIMR .EQ. MAXEXP) .OR. (NEWSTART)) THEN
               CALL DIAGR(BUF3, BUF, MAXORD,IEVAL,IEVEC,IEXCP,
     $               IEVALSEL,EXCPTHRS,print)
               ENDIF
               IF(PRINT)THEN
                  CALL BLKCPY2(R,MAXORD,MAXORD,BUF3,NDIMR,NDIMR,1,1)
                  WRITE(6,1105)
 1105       FORMAT(T3,'@NEXTDAV-I, recovered righthand subspace H: ')
                  CALL OUTPUT(BUF3,1,NDIMR,1,NDIMR,NDIMR,NDIMR,1)
               ENDIF
            ENDIF
C
C LOAD GUESS FOR NEXT VECTOR
C
C  THE INITIAL GUESS IS BASED ON THE DIAGONAL ELEMENTS OF H0
C
            I000 = 1
            I010 = I000 + NSIZEC
            I020 = I010 + NSIZEC
            CALL GETLST(SCR(I000), 4,1,1,1, LISTH0)
            CALL FNDMINE(NSIZEC, SCR(I000),
     $         EIGVAL(1, IRREPX,ISPIN+1-ITOTALS),
     $         SCR(I010),0, ROOT, ILOC, 1.D-4, THRESH)
            SCR(ILOC) = 1.0D30
            CALL PUTLST(SCR(I000), 4, 1,1,1, LISTH0)        
            CALL ZERO(SCR,NSIZEC)
            SCR(ILOC) = ONE
            CALL NORMVEC(SCR(I000), NSIZEC, SCR(I010), MAXCOR-I010+1,
     $         IUHF, ICALC, SIRREP)
C
C  THIS GUESS MAY ALSO BE USED FOR LEFTHAND, AND IS PUT ON 
C  COLUMN 3 OF LISTH0
C
        CALL PUTLST(SCR(I000),3,1,1,1,LISTH0)
C
            WRITE(6,1300)
C
C  ORTHOGONALIZE GUESS TO ALL PRECEDING VECTORS
C
            CALL GSORTHOG(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &         SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     $         RESID,ICALC)
C     
            WRITE(6,'(1X,A,2E12.6,I6)')' GUESS FOR NEXT EIGENVALUE ',
     $         ROOT, RESID, ILOC
            WRITE(6,1300)
C
            IF ((RESID .LT. 1.E-1)) THEN
        WRITE(6,'(1X,A,E12.3)')' LIN. DEP. FOR INITIAL ESTIMATE '
C     
C  Find best new eigenvector in existing space
C
            IF (LEFTHAND) THEN
              CALL DIAGR(BUF3,BUF,MAXORD,IEVAL,IEVEC,IEXCP,
     $            IEVALSEL,EXCPTHRS,PRINT2)
            ENDIF
            CALL FNDMINE(NDIMR,BUF(IEVALSEL),
     $         EIGVAL(1,IRREPX,ISPIN+1-ITOTALS),
     $         SCR, IROOT,Z,ILOC,1.D-3, THRESH)
            ROOT=BUF(ILOC)
            IBUFLC=IEVEC-1+INDXF(1,ILOC,NDIMR)
            CALL RESVEC(SCR, MAXCOR, BUF, MAXORD, ISIDE, IBUFLC)
            IF (EXCICORE) THEN
C
C PROJECT OUT THE COMPONENTS THAT CORRESPOND TO SPIN-FLIP EXCITATIONS
C
               CALL GETLST(SCR(I010),6,1,1,1,LISTH0)
               CALL VECPRD(SCR(I000),SCR(I010),SCR(I000),NSIZEC)
            ENDIF
            CALL GETLST(SCR(I010),1,1,1,1,LISTH0)
            CALL VECDIV2(ROOT,SCR(I000),SCR(I010),SCR(I000),NSIZEC)
            CALL GSORTHOG(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &         SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     &         RESID,ICALC)
            WRITE(6,'(1X,A,2E12.5)') ' NEW GUESS: ROOT, RESID',
     $         ROOT, RESID
         ENDIF
C
         ENDIF
      ENDIF
C
      CALL PUTS(SCR(I000),NSIZEC,ISPIN, IUHF, LS1IN, LS2IN)
      Print*, "New vectors created for the next iteration?-3"
      write(6,"(6(1x,F10.5))") (scr(i000+i-1),i=1,nsizec)
      Call Check_eavecs(Iuhf,Ispin,scr,Maxcor,Ls1in,Ls2in)
      if (iuhf.eq.0) call check_ab2aa(scr(i000),nsizec,
     &                    scr(i020),maxcor-i020,1)
C
C TRUNCATE EXPANSION SPACE IF WE HAVE REACHED THAT POINT
C
      IF ((NDIMR.EQ.MAXEXP) .OR. NEWSTART) THEN
         CALL ZERO(R,MAXORD*MAXORD)
         write(6,1300)
         write(6,*) ' maximum expansion space reached: truncate !'
         if (NREDUCE.EQ.0) then
            CALL FORMS(NSIZEC,NDIMR,SCR(I000),SCR(I020),BUF(IBUFLC),
     &         ISIDE,LISTC,IOLDEST,MAXORD)
            CALL NORMVEC(SCR(I000), NSIZEC, SCR(I010), MAXCOR-I010+1,
     $         IUHF, ICALC, SIRREP)
            CALL PUTS(SCR(I000),NSIZEC,ISPIN, IUHF, LS1IN, LS2IN)
            NDIMR = 0
            IOLDEST = 1
         else
            I000 = 1
            I010 = I000 + NREDUCE
            I020 = I010 + NSIZEC * NREDUCE
            IF (SINGONLY) THEN
               IE = IEVAL
            ELSE
               IE = IEVALSEL
            ENDIF
            IF (NEWSTART) THEN
               WRITE(6,*) ' NEW STARTING OF DAVIDSON PROCEDURE'
               WRITE(6,*) ' ONLY CONVERGED EIGENVECTORS ARE RETAINED',
     $            IROOT
               IF (ISIDE .EQ. 1) THEN
                  NDIMIN = IROOT + 1
               ELSE
                  NDIMIN = IROOT + 2
               ENDIF
            ELSE
               NDIMIN = NREDUCE
            ENDIF
            NDIMNEW = NDIMIN
C
C  IN PRINCIPLE NDIMNEW WILL EQUAL NDIMIN, HOWEVER IF TOO FEW
C  REAL EIGENVALUES ARE AVAILABLE THEN NDIMNEW WILL BE
C  EQUAL TO THE NUMBER OF REAL EIGENVALUES.
C
            CALL TRUNCATE(BUF(IE),BUF(IEVEC),SCR(I000),SCR(I010),
     $         SCR(I020),MAXCOR-I020+1,NSIZEC,NDIMR,NDIMNEW,.FALSE.,
     $         IRREPX,ISIDE,ISPIN, IUHF, ICALC)
            IF (NDIMNEW .NE. NDIMIN) THEN
               WRITE(6,*) ' THE SPACE IS TRUNCATED FURTHER BECAUSE NOT',
     $        ' ENOUGH REAL EIGENVALUES WERE FOUND', NDIMIN, NDIMNEW
            ENDIF
            IOLDEST=NDIMNEW+1
            CALL REFORM(R,P,SCR,NDIMNEW,NSIZEC,IRREPX,
     $         MAXCOR,ISIDE,IUHF,ICALC)
         ENDIF
         NDIMR=NDIMNEW
         CALL DIAGR(BUF3, BUF, MAXORD, IEVAL, IEVEC, IEXCP,
     $      IEVALSEL,EXCPTHRS,PRINT2)
         if (printtrn) then
         write(6,1300)
         WRITE(6,*)' EIGENVALUES AFTER TRUNCATION'
         CALL OUTPUT(BUF(IEVAL),1,1,1,NDIMR,1,NDIMR,1)
         write(6,1300)
         WRITE(6,*)' OVERLAPS WITH EXCITATION PATTERN AFTER TRUNCATION'
         CALL OUTPUT(BUF(IEXCP),1,1,1,NDIMR,1,NDIMR,1)
         write(6,1300)
         endif
      ENDIF
C
C MOVE R AND P MATRICES
C
      DO 50 I=NDIMR,1,-1
         DO 51 J=NDIMR,1,-1
            R(INDXF(I+1,J+1,MAXORD))=R(INDXF(I,J,MAXORD))
            P(INDXF(I+1,J+1,MAXORD))=P(INDXF(I,J,MAXORD))
 51      CONTINUE
 50   CONTINUE
C     
      CALL TIMER(1)      
      TEADAVID = TEADAVID + TIMENEW
      RETURN
 1300 FORMAT(/)
 5001 FORMAT(T4,I4,T13,I4,T21,"Root",T36,"Max",T49,"RMS",4X,I8)
 5000 FORMAT(T4,I4,T13,I4,T21,D14.7,T36,D13.6,T49,D13.6,4X,I8)
C 5000 FORMAT(T4,I4,T13,I4,T21,D14.7,T36,D13.6,T36,D13.64X,I8)
      END
