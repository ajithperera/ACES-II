
C  THIS ROUTINE PERFORMS THE SORT OF THE GAMMA AMPLITUDES FOR CC/MBPT
C  GRADIENT CALCULATIONS. THE GAMMAS ARE REQUIRED TO BE IN THE SAME
C  ORDER AS THE CORRESPONDING INTEGRASL DERIVATIVES ARE CALCULATED,
C  THAT MEANS ESSENTIALLY IN A ORDERING WHICH IS CANONICAL WITH 
C  RESPECT TO THE SHELLS.
C
C  THIS ROUTINE IS BASED ON A PREVIOUSLY WRITTEN SORT FOR MBPT
C  GRADIENTS BY J.GAUSS IN COLOGNE 
C
C  AS A NEW FEATURE THIS SORT CONTAINS ALSO AN INCORE OPTION THUS
C  AVOIDING TO WRITE A SORT FILE
C 
C  CODED NOV/90/JG

      SUBROUTINE GAMSRT(IBUF,BUF,LBUF,BUF1,IBUF2,BUF2,SORT,LSORT,
     &                  IBUCK,BUCK,LBUCK,NNIJ,IJADD,ISHLD,
     &                  NSTSH,NENDSH)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER AND,OR,XOR
      CHARACTER*80 FNAME
#include "baslims.par"
#include "mxcent.par"
      PARAMETER(IBIT08=255)
      PARAMETER(MXBTCH=1000)
 
#include "icdacc.com"
 
      LOGICAL INCORE
      LOGICAL BIGVEC,SEGMEN
      LOGICAL PEQQ,REQS,PQEQRS
      INTEGER P,Q,R,S,PQ,RS,PQRS
      INTEGER DIRPRD,TYPE
C
      COMMON /BLOCKS/CENTSH(MXSHEL,3),
     &               MAXSHL,BIGVEC,SEGMEN,
     &               NHKTSH(MXSHEL),KHKTSH(MXSHEL),MHKTSH(MXSHEL),
     &               ISTBSH(MXSHEL),NUCOSH(MXSHEL),NORBSH(MXSHEL),
     &               NSTRSH(MXSHEL),NCNTSH(MXSHEL),NSETSH(MXSHEL),
     &               JSTRSH(MXSHEL,MXAOVC),
     &               NPRIMS(MXSHEL,MXAOVC),
     &               NCONTS(MXSHEL,MXAOVC),
     &               IORBSH(MXSHEL,MXAOVC),
     &               IORBSB(MXCORB),NRCSH(MXSHEL)
      COMMON /PINCOM/IPIND(MXCORB),IBLOCK(MXCORB),INDGEN(MXCORB)
      COMMON /SYMMET/FMULT(0:7),PT(0:7),
     &               MAXLOP,MAXLOT,MULT(0:7),ISYTYP(3),
     &               ITYPE(8,36),NPARSU(8),NPAR(8),NAOS(8),
     &               NPARNU(8,8),IPTSYM(MXCORB,0:7),
     &               IPTCNT(3*MXCENT,0:7),NCRREP(0:7),
     &               IPTCOR(MXCENT*3),NAXREP(0:7),IPTAX(3),
     &               IPTXYZ(3,0:7)
      COMMON /PTRFIL/JOBIN,JOBOUT,LUMC,LUSCR,LUDA,LUPSO,LUPAO
C
C  COMMON /MACHSP/ CONTAINS MACHINE DEPENDENT STUFF
C
      COMMON /MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
C
C  COMMON /BASSYM/ CONTAINS SYMMETRY INFORMATION OF BASIS SET
C
      COMMON/BASSYM/NBAS(8),NBASIS,NBASSQ,NBASTT
C
C  COMMON/SYMINF/ CONTAINS NUMBER OF IRREPS
C
      COMMON/SYMINF/MSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
C
      COMMON/IPRI/IPRINT
C
C  ARRAY WHICH KEEPS LOOP INFORMATION 
C
       DIMENSION TYPE(4,42,4),NTYPE(4),IOFFL(8),IDID(8)
C
C  BUFFER FOR READING IN GAMMAS
C
      DIMENSION IBUF(1), BUF(1), BUF1(1),  IBUF2(1), BUF2(1)
C
C  SORT ... ARRAY FOR CXHAINING IN THE SORTED GAMMAS
C
      DIMENSION SORT(1)
C
C  SCRATCH ARRAYS FOR BUCKETS BUFFER VALUES AND INDICES
C
      DIMENSION BUCK(1),IBUCK(1)
C
C  INDEXING ARRAYS FOR ABSOLUTE ADRESS OF GAMMA
C
      DIMENSION IJADD(1),NNIJ(1),ISHLD(1),NSTSH(8,1),NENDSH(8,1)
C
C  COMMON /BATCH/ CONTAINS THE FOLLOWING SORT INFORMATION
C
C      NBATCH : NUMBER OF STRIPES OF THE GAMMAS
C      LBUC : BUFFER LENGTH OF EACH RECORD IN THE SORT FILE
C      LBUC2 : NUMBER OF GAMMA ELEMENTS IN EACH RECORD OF THE SORT FILE
C      LASTAD : ARRAY CONTAINING THE NUMBER OF THE LAST RECORD WRITTEN
C               FOR THIS STRIPE
C      ICOUNT : COUNTER OF THE NUMBER OF ELEMENTS IN THE BUFFER FOR
C               EACH STRIPE
C      ISTART : OFFSET FOR BUCKETS IN MEMORY
C      NAD : OFFSET OF THE TOTAL ADRESS FOR THIS STRIPE
C      NSTART : FIRST SHELL COMBINATION CONSIDERED IN THIS STRIPE
C      NEND : LAST SHELL COMBINATION  CONSIDERED IN THIS STRIPE
C
      COMMON/BATCH/NBATCH,LBUC,LBUC2,LASTAD(MXBTCH),
     &             ICOUNT(MXBTCH),ISTART(MXBTCH),
     &             NAD(MXBTCH),NSTART(MXBTCH),NEND(MXBTCH) 
C
C STATEMENT FUNCTIONS FOR PACKING, UNPACKING AND ADDRESSING 
C
      IBTAND(I,J) = AND(I,J)
      IBTSHL(I,J) = ISHFT(I,J)
      IBTSHR(I,J) = ISHFT(I,-J)
      IPART(I,J) = IBTAND(IBTSHR(I,8*(J-1)),IBIT08)
      ISHLL(I)   = IBTAND(I,IBIT08)
      ICONTR(I)  = IBTAND(IBTSHR(I,8),IBIT08)
      IANG(I)    = IBTAND(IBTSHR(I,16),IBIT08)
      JRREP(I)   = IBTAND(IBTSHR(I,24),IBIT08)
C
C  THE ADRESS OF ANY GAMMA ELEMENT IS DETERMINED AS
C 
C  THERE ARE THREE CATEGORIES WHICH DETERMINE THE ADRESS OF A SINGLE 
C  GAMMA ELEMENT :
C
C  1) THE POSITION IN THE LIST OF CONTRACTIONS OF THE FOUR BASIS FUNCTIONS
C  2) THE IRREDUCIBLE REPRESENTATION OF THE FOUR BASIS FUNCTIONS
C  3) THE ANGULAT MOMENTUM OF THE FOUR BASIS FUNCTIONS
C
C THE FIRST LEVEL IS COMPLETELY DETERMINED BY 1). P IS FASTEST RUNNING,
C FOLLOWED BY Q, R, AND S.
C THE SECOND LEVEL IS DETERMINED BY THE IRREPS
C WHILE THE THIRD LEVEL IS DETERMINED BY THE ANGULAR MOMEMTUM.
C
C THE ORDERING IS THEREFORE THE FOLLOWING
C
C  1px,1px,1px,1px; 2px,1px,1px,1px; .....    Npx, Npx, Npx, Npx  (all irrep 1)
C
C  ....                                                           (other irreps)
C
C  1py,1px,1px,1px;   ....                                        (all irrep1)
C
C ....
C
      ICR(I,J,K,L)  = NRCP*(NRCQ*(NRCR*(L-1)+K-1)+J-1)+I
      IAR(I,J,K,L)  = KHKTP*(KHKTQ*(KHKTR*(L-1)+K-1)+J-1)+I
      IRR(I,J,K,L)  = MULP*(MULQ*(MULR*(L)+K)+J)+I+1
      IADDRS(I,J,K) = NRCTOT*(MULTOT*(K-1)+J-1)+I
C
C  REWIND THE FILES
C
      REWIND LUPAO
C
C  FILL FIRST TYPE
C
C  MAXTYPE GIVES THE MAXIMUM NUMBER OF DIFFERENT SYMMETRY TYPES
C
      MAXTYPE=4
      IF(NIRREP.EQ.2) MAXTYPE=3
      IF(NIRREP.EQ.1) MAXTYPE=1
C
C  FILL THE TABLE FOR THE AAAA SYMMETRY TYPE
C  (ALWAYS THERE)
C
      DO 11 IRREP=1,NIRREP
       TYPE(1,IRREP,1)=IRREP
       TYPE(1,IRREP,2)=IRREP
       TYPE(1,IRREP,3)=IRREP
       TYPE(1,IRREP,4)=IRREP
11    CONTINUE
      NTYPE(1)=NIRREP
C
      IF(MAXTYPE.GE.2) THEN
C
C  FILL TABLE FOR THE AABB AND ABAB SYMMETRY TYPE
C
       IND=0
       DO 12 IRREP1=2,NIRREP
       DO 12 IRREP2=1,IRREP1-1
        IND=IND+1
        TYPE(2,IND,1)=IRREP2
        TYPE(2,IND,2)=IRREP2
        TYPE(2,IND,3)=IRREP1
        TYPE(2,IND,4)=IRREP1
12     CONTINUE
       NTYPE(2)=IND
C 
       IND=0
       DO 13 IRREP=2,NIRREP
       DO 13 IRREP1=1,NIRREP
        IRREP2=DIRPRD(IRREP,IRREP1)
        IF(IRREP2.GT.IRREP1) THEN
         IND=IND+1
         TYPE(3,IND,1)=IRREP1
         TYPE(3,IND,2)=IRREP2
         TYPE(3,IND,3)=IRREP1
         TYPE(3,IND,4)=IRREP2
        ENDIF
13     CONTINUE
       NTYPE(3)=IND
C
       IF(MAXTYPE.EQ.4) THEN
C
C  FILL TABLE FOR THE ABCD SYMMETRY TYPE
C
        IND=0
        DO 313 IRREP=2,NIRREP
         DO 314 IRREP1=1,NIRREP
          IRREP2=DIRPRD(IRREP,IRREP1)
          IF(IRREP2.LT.IRREP1)GOTO 314
          IBOT=MAX(IRREP1,IRREP2)+1
          CALL IZERO(IDID,8)
          DO 315 ITMP=IBOT,NIRREP
           IRREP4=DIRPRD(ITMP,IRREP)
           IRREP3=MIN(ITMP,IRREP4)
           IRREP4=MAX(ITMP,IRREP4)
           IF(MAX(IDID(IRREP4),IDID(IRREP3)).NE.0)GOTO 315
           IDID(IRREP3)=1
           IDID(IRREP4)=1
           IND=IND+1
           TYPE(4,IND,1)=IRREP3
           TYPE(4,IND,2)=IRREP4
           TYPE(4,IND,3)=IRREP1
           TYPE(4,IND,4)=IRREP2
315       CONTINUE
314      CONTINUE
313     CONTINUE
        NTYPE(4)=IND
       ENDIF
C
      ENDIF
C
C  FILL IOFFL
C
      IOFFL(1)=0
      DO 14 IRREP=1,NIRREP-1
       IOFFL(IRREP+1)=IOFFL(IRREP)+NBAS(IRREP)
14    CONTINUE
C
C  FILL FIRST IJAD,NNIJ, NAD ISHLAD
C
      DO 4 P=1,MAXSHL
       NSETP=NSETSH(P)
       NCRP=0
       DO 3 IP=1,NSETP
        NCRP=NCRP+NCONTS(P,IP)
3      CONTINUE
       NRCSH(P)=NCRP
4     CONTINUE
C
      K=0
      NIJADD=0
      NIJADD2=0
      IJADD(1)=0
      DO 1 P=1,MAXSHL
       IRANGE=KHKTSH(P)*MULT(ISTBSH(P))*NRCSH(P)
       DO 2 Q=1,P
        K=K+1
        NIJ=IRANGE*KHKTSH(Q)*MULT(ISTBSH(Q))*NRCSH(Q)
        NIJ2=IRANGE*KHKTSH(Q)*NRCSH(Q)
        NNIJ(K)=NIJ
        NIJADD=NIJADD+NIJ
        NIJADD2=NIJADD2+NIJ2
        IJADD(K+1)=NIJADD2
c        IJADD(K)=NIJADD
2      CONTINUE
1     CONTINUE
C
c      ISHLD(1)=0
c      K=1
c      DO 5 P=1,MAXSHL
c       DO 5 Q=1,P
c        K=K+1
c        ISHLD(K)=ISHLD(K-1)+NNIJ(K-1)*IJADD(K)
c5      CONTINUE
C
C  FILL NENDSH AND NSTSH
C
      CALL IZERO(NENDSH,8*MAXSHL)
      CALL IZERO(NSTSH,8*MAXSHL)
C
      IOFF=0
      DO 7 IRREP=1,NIRREP
       DO 6 I=IOFF+1,IOFF+NBAS(IRREP)
        LAB=INDGEN(I)
        P=ISHLL(LAB) 
        NENDSH(IRREP,P)=I
6      CONTINUE
       NSTSH(IRREP,1)=IOFF+1
       DO 8 ISHELL=1,MAXSHL
        IF(NENDSH(IRREP,ISHELL).LT.NSTSH(IRREP,ISHELL)) THEN
         NENDSH(IRREP,ISHELL)=NSTSH(IRREP,ISHELL)-1
        ENDIF
        IF(ISHELL.NE.MAXSHL) THEN
         NSTSH(IRREP,ISHELL+1)=NENDSH(IRREP,ISHELL)+1
        ENDIF
8      CONTINUE
       IOFF=IOFF+NBAS(IRREP)
7     CONTINUE
 
C
C  DETERMINE SORT RANGES
C
C  IPQRS : COUNTER FOR ALL SHELL COMBINATIONS
C  NDM2F : TOTAL NUMBER OF GAMMAS
C  NDM2 : NUMBER OF GAMMAS IN THE CURRENT STRIPE
C  IBATCH : COUNTER FOR THE STRIPES
C  NOLD : STARTING SHELL COMBINATION OF THE CURRENT STRIPE
C  NADRES : OFFSET FOR THE CURRENT BATCH
C  LBUC : MAXIMUM LENGTH OF A BUCKET
C
      IPQRS=0
      NDM2F=0
      NDM2=0
      IBATCH=0
      NOLD=1
      NADRES=0
      LBUC=10238
      NREC=1  
C
C  LOOP OVER ALL SHELL COMBINATION P >= Q, R >= S [PQ] >= [RS]
C
      DO 10 P = 1,MAXSHL
       KHKTP = KHKTSH(P)
       MULP  = MULT(ISTBSH(P))
c       NSETP = NSETSH(P)
       NRCP  = NRCSH(P)
       NUMP=KHKTP*MULP*NRCP
       DO 20 Q = 1,P
        KHKTQ = KHKTSH(Q)
        MULQ  = MULT(ISTBSH(Q))
c        NSETQ = NSETSH(Q)
        NRCQ  = NRCSH(Q)
        NUMPQ=NUMP*KHKTQ*MULQ*NRCQ
        DO 30 R = 1,P
         KHKTR = KHKTSH(R)
         MULR  = MULT(ISTBSH(R))
c         NSETR = NSETSH(R)
         NRCR  = NRCSH(R)
         NUMPQR=NUMPQ*KHKTR*MULR*NRCR
         MXS   = R
         IF (P .EQ. R) MXS = Q
         DO 40 S = 1,MXS
          KHKTS = KHKTSH(S)
          MULS  = MULT(ISTBSH(S))
c          NSETS = NSETSH(S)
          NRCS  = NRCSH(S)
C
C INCREMENT IPQRS
C
          IPQRS = IPQRS + 1
C
C  NUM IS HERE THE SIZE OF THE BLOCK OF TWO-PARTICLE DENSITY MATRIX
C  REQUIRED FOR THIS SHELL COMBINATION
C
c          NUM=NUMPQR*KHKTS*MULS*NRCS
          NUM=NUMPQR*KHKTS*NRCS
C
C  INCREMENT NDM2F
C
          NDM2F=NDM2F+NUM
C 
C  CHECK IF THIS BLOCK CAN BE INCLUDED IN THE CURRENT BIN
C  OR IF A NEW STRIPE HAS TO BE DEFINED
C          
          IF((NDM2+NUM).LE.LSORT) THEN
C
C  IT CAN BE INCLUDED IN THE CURRENT STRIPE
C  UPDATE ONLY NDM2
C
           NDM2=NDM2+NUM
C
          ELSE
C
C INCREMENT IBATCH AND DEFINE NEW STRIPE
C
           IBATCH=IBATCH+1
           NSTART(IBATCH)=NOLD
           NEND(IBATCH)=IPQRS-1
           NOLD=IPQRS   
           NAD(IBATCH)=NADRES
           NADRES=NDM2F-NUM
           NDM2=NUM
C
          ENDIF
                   
40       CONTINUE
30      CONTINUE
20     CONTINUE
10    CONTINUE
C
      NBATCH=IBATCH+1
      IF(NBATCH.GT.MXBTCH) THEN      
       WRITE(*,*)'  The sort requires too many bins !'
       WRITE(*,*)'  Allowed are ',MXBTCH,' but ',NBATCH,' are required.'
       CALL ERREX
      ENDIF
      NSTART(NBATCH)=NOLD
      NEND(NBATCH)=IPQRS
      NAD(NBATCH)=NADRES
C
C  RESET MAXIMUM SORT AREA
C
      LSORT=MIN(LSORT,NDM2F)
C
C  LBUCK : LENGTH OF ARRAYS BUCK AND IBUCK
C  LBUC2 : MAXIMUM POSSIBLE LENGTH OF BUCKETS 
C
      LBUC2=LBUCK/NBATCH
C
C  LBUC2 : LENGTH OF BUCKETS AFTER ALL CHECKS
C
      LBUC2=MIN0(LBUC2,LBUC,NDM2F)
C
C   LBUC : LENGTH OF A RECORD IN INTEGERS
C
      LBUC=(1+IINTFP)*LBUC2+2
C
C  CHECK IF WE CAN DO THE SORT IN CORE
C
      INCORE=NBATCH.EQ.1
C
C  WRITE SORT INFORMATION
C
      

      if(iprint.ne.0) then
       write(*,*) '  Sort of Gammas required for CC/MBPT gradients.'
       write(*,*)'  Sort information :'
       write(*,*)'  Total number of Gammas :',NDM2F
      endif
      IF(INCORE) THEN 
cmn       write(*,*) '  Sort performed in core.'
      ELSE
       if(iprint.ne.0) then
        write(*,*) '  Sort performed out of core.' 
        write(*,*) '  Number of batches            :',NBATCH
        write(*,*) '  Maximum length of each batch :',LSORT
        write(*,*) '  Record length of Sort file   :',LBUC
       endif
      ENDIF
      IF(INCORE) THEN
C
C  TREAT FIRST THE CASE AAAA ( ALL ORBITALS BELONG TO THE SAME
C  IRREP)
C
       CALL GAAAA1(NIRREP,NBAS,IOFFL,MULT,NRCSH,KHKTSH,INDGEN,
     &             ISTBSH,ISHLD,NNIJ,IJADD,NSTSH,NENDSH,
     &             BUF,BUF1,SORT)
C
C  FOR NIRREP GT 1, WE HAVE NOW TO DEAL WITH THE OTHER CASES AS WELL
C
       IF(NIRREP.GT.1) THEN
C
       CALL GAABB1(NIRREP,NTYPE(2),TYPE,NBAS,IOFFL,
     &              MULT,NRCSH,KHKTSH,INDGEN,ISTBSH,ISHLD,NNIJ,IJADD,
     &              NSTSH,NENDSH,BUF,BUF1,SORT) 
C
        CALL GABAB1(NIRREP,NTYPE(3),TYPE,NBAS,IOFFL,
     &              MULT,NRCSH,KHKTSH,INDGEN,ISTBSH,
     &              ISHLD,NNIJ,IJADD,
     &              NSTSH,NENDSH,BUF,SORT) 
        IF(NIRREP.GT.2) THEN
C
        CALL GABCD1(NIRREP,NTYPE(4),TYPE,NBAS,IOFFL,
     &              MULT,NRCSH,KHKTSH,INDGEN,ISTBSH,
     &              ISHLD,NNIJ,IJADD,
     &              NSTSH,NENDSH,BUF,SORT) 
C
        ENDIF 
C
       ENDIF
C
      CALL ACES_IO_REMOVE(50,'MOINTS')
C
         IOFF=1
         JPQRS=0
         DO 9120 P=1,MAXSHL
          KHKTP=KHKTSH(P)
          MULP=MULT(ISTBSH(P))
          NRCP=NRCSH(P)
          DO 9120 Q=1,P
           KHKTQ=KHKTSH(Q)
           MULQ=MULT(ISTBSH(Q))
           NRCQ=NRCSH(Q)
           DO 9120 R=1,P
            KHKTR=KHKTSH(R)
            MULR=MULT(ISTBSH(R))
            NRCR=NRCSH(R)
            MXS=R
            IF(P.EQ.R) MXS=Q
            DO 9120 S=1,MXS
             JPQRS=JPQRS+1
             KHKTS=KHKTSH(S)
c             MULS=MULT(ISTBSH(S))
             NRCS=NRCSH(S) 
             NUM=NRCP*NRCQ*NRCR*NRCS*KHKTP*KHKTQ*KHKTR*KHKTS
c     &           *MULP*MULQ*MULR*MULS
     &           *MULP*MULQ*MULR
             IST=IOFF
             IOFF=IOFF+NUM
             NBL=NUM
             IEND=IST-1+MAX(4,NBL)
             IFIN=IST-1+NBL
             WRITE(LUPAO) NBL, (SORT(J), J = IST,IEND)

C            IF(IPRINT.GT.30) THEN
C            WRITE(*,'(A,I5,i3,i3,i3,i3,/,(4X,1P,5E12.4))')
C     1     'SO 2 MATRIX BLOCK FOR SHELL Quadruplett', jpqrs,p,q,r,s,
C     2      (Sort(J),J=IST,IFIN)
C            END IF
9120     CONTINUE
C
      ELSE
C
C  OPEN SORT FILE, IRECL IS IN BYTE, IINTLN RETURNS THE NUMBER 
C  OF BYTES PER INTEGER WORD (8 ON CRAY, 4 ON FPS) 
C
c YAU - old
C Nevin
c      if(iintfp.eq.1)then
c        IRECL=IINTLN*LBUC
c      else
c        irecl=idaccm*lbuc
c      endif
c YAU - new
      irecl=idaccm*lbuc
c YAU - end

      CALL GFNAME('GAOSRT  ',FNAME,ILENGTH)
      OPEN(UNIT=LUDA,FILE=FNAME(1:ILENGTH),FORM='UNFORMATTED',
     &     STATUS='UNKNOWN',ACCESS='DIRECT',RECL=IRECL)
C
C  THE SORT RANGE IS NOW DEFINED, READ NOW UNSORTED GAMMAS
C 
      DO 185 IBATCH = 1,NBATCH
       ICOUNT(IBATCH)=0
       LASTAD(IBATCH)=-1
185   CONTINUE
      ISTART(1)=0
      DO 186 IBATCH=1,NBATCH
       ISTART(IBATCH)=(IBATCH-1)*LBUC2
186   CONTINUE
C
C  TREAT FIRST THE CASE AAAA ( ALL ORBITALS BELONG TO THE SAME
C  IRREP)
C
       CALL GAAAA2(NIRREP,NBAS,IOFFL,MULT,NRCSH,KHKTSH,INDGEN,
     &             ISTBSH,ISHLD,NNIJ,IJADD,NSTSH,NENDSH,
     &             BUF,BUF1,BUCK,IBUCK,NREC)
C
C  FOR NIRREP GT 1, WE HAVE NOW TO DEAL WITH THE OTHER CASES AS WELL
C
       IF(NIRREP.GT.1) THEN
C
        CALL GAABB2(NIRREP,NTYPE(2),TYPE,NBAS,IOFFL,
     &              MULT,NRCSH,KHKTSH,INDGEN,ISTBSH,ISHLD,NNIJ,IJADD,
     &              NSTSH,NENDSH,BUF,BUF1,BUCK,IBUCK,NREC)
C
        CALL GABAB2(NIRREP,NTYPE(3),TYPE,NBAS,IOFFL,
     &              MULT,NRCSH,KHKTSH,INDGEN,ISTBSH,
     &              ISHLD,NNIJ,IJADD,
     &              NSTSH,NENDSH,BUF,BUCK,IBUCK,NREC)
        IF(NIRREP.GT.2) THEN
C
        CALL GABCD2(NIRREP,NTYPE(4),TYPE,NBAS,IOFFL,
     &              MULT,NRCSH,KHKTSH,INDGEN,ISTBSH,
     &              ISHLD,NNIJ,IJADD,
     &              NSTSH,NENDSH,BUF,BUCK,IBUCK,NREC)
C
        ENDIF 
C
       ENDIF
C
C  LOOP OVER ALL BIN-BUFFERS AND WRITE THEM TO DISK
C
      DO 75 IBATCH = 1,NBATCH
       JCOUNT = ICOUNT(IBATCH)
       IF (JCOUNT .GT. 0) THEN
        CALL WRTSRT(LUDA,BUCK(ISTART(IBATCH)+1),IBUCK(ISTART(IBATCH)+1),
     &             LASTAD(IBATCH),ICOUNT(IBATCH),LBUC2,NREC)
       ENDIF
75    CONTINUE  
      NREC=NREC-1
      LENGTH=NREC*LBUC
      write(*,*) NREC,' records have been written to the Sort file.'
      write(*,*) ' Total length of Sort file :',LENGTH,' words.'
C
C  SORT FILE IS NOW COMPLETE
C
C  DELETE FIRST THE AO-GAMMA FILE ( ACTUALLY THE MOINTS FILE)
C
      CALL ACES_IO_REMOVE(50,'MOINTS')
C
C  READ BACK CHAINS AND WRITE SORTED GAMMAS
C  LOOP NOW OVER ALL BINS, CHAIN IN AND WRITE THEN THE SORTED FILE BACK 
C  TO DISK
C
      DO 80 IBATCH=1,NBATCH
       IF (LASTAD(IBATCH).EQ.-1) GOTO 80
C
C  ZERO THE SORT AREA
C
         CALL ZERO(SORT,LSORT)
C
C  REENTRY POINT FOR CHAINING IN
C
   85    CONTINUE
C
C READ RECORD
C
         CALL RDSRT(LUDA,BUF2,IBUF2,JCOUNT,LBUC2,LASTAD(IBATCH))
C
C  LOOP OVER ALL ELEMENTS IN THIS RECORD AND
C  PLACE THEM IN THE SORT AREA
C
*VOCL LOOP,NOVREC
CDIR$ IVDEP
         DO 90 I = 1,JCOUNT
            SORT(IBUF2(I))=BUF2(I)
   90    CONTINUE
C
C IF (.NOT.LAST RECORD) RETURN TO 85
C
         IF (LASTAD(IBATCH) .NE. -1) GOTO 85
C
C ARRAYS ARE SET UP - WRITE OUT TO SEQUENTIAL FILE
C
         IOFF=1
         JPQRS=0
         KSTART=NSTART(IBATCH)
         KEND=NEND(IBATCH)
         DO 120 P=1,MAXSHL
          KHKTP=KHKTSH(P)
          MULP=MULT(ISTBSH(P))
          NRCP=NRCSH(P)
          DO 120 Q=1,P
           KHKTQ=KHKTSH(Q)
           MULQ=MULT(ISTBSH(Q))
           NRCQ=NRCSH(Q)
           DO 120 R=1,P
            KHKTR=KHKTSH(R)
            MULR=MULT(ISTBSH(R))
            NRCR=NRCSH(R)
            MXS=R
            IF(P.EQ.R) MXS=Q
            DO 120 S=1,MXS
             JPQRS=JPQRS+1
             IF(JPQRS.GT.KEND) GO TO 121
             IF(JPQRS.LT.KSTART) GO TO 120
             KHKTS=KHKTSH(S)
             MULS=MULT(ISTBSH(S))
             NRCS=NRCSH(S) 
             NUM=NRCP*NRCQ*NRCR*NRCS*KHKTP*KHKTQ*KHKTR*KHKTS
c     &           *MULP*MULQ*MULR*MULS
     &           *MULP*MULQ*MULR
             IST=IOFF
             IOFF=IOFF+NUM
             NBL=NUM
             IEND=IST-1+MAX(4,NBL)
             IFIN=IST-1+NBL
             WRITE(LUPAO) NBL, (SORT(J), J = IST,IEND)
c            IF(IPRINT.GT.30) THEN
c            WRITE(*,'(A,I10,/,(4X,1P,5E12.4))')
c     1     'SO 2 MATRIX BLOCK FOR SHELL Quadruplett', jpqrs,
c     2      (Sort(J),J=IST,IFIN)
C            END IF
120     CONTINUE
121    CONTINUE
C
80    CONTINUE
C
      ENDIF
C
C  RETURN
C
      RETURN
      END
