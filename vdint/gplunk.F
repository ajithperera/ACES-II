      SUBROUTINE GPLUNK(SO,REORD,BUCK,IBUCK,IBKSIZ,NINBCK,
     &                 ISOR,ISOS,ISOT,
     &                 NORBA,NORBB,NORBC,NORBD,
     &                 NOABCD,ICGTOA,ICGTOB,ICGTOC,ICGTOD,
     &                 DIAGAB,DIAGCD,
     &                 SHAEQB,SHCEQD,SHAEQC,SHBEQD,
     &                 TCONAB,TCONCD,
     &                 KHKTA,KHKTB,KHKTC,KHKTD,
     &                 NHKTA,NHKTB,NHKTC,NHKTD,
     &                 MULA,MULB,MULC,MULD,
     &                 THRESH,SYMFAC,IPRINT,WORK1,LWORK1,
     &                 NBASIS,NUMBUF,NIR)
C
C WRITE GIAO INTEGRALS TO SORT FILE
C
C  NOTE THAT THERE ARE FOUR EACH QUADRUPLE A,B,C,D TWO GIAO
C  INTEGRALS
C
C    1)   d <AC|BD> / d B     WITH A,C COMPLEX CONJUGATE         
C
C    2)   d <AD|BC> / d B     WITH A,D COMPLEX CONJUGATE
C
C  SINCE THE PERTURBATION IS IMAGINARY THERE ARE LESS
C  SYMMETRY RELATIONS THAN USUAL.
C
CEND
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER AND,OR,XOR
      LOGICAL TWOCEN,THRCEN,FOUCEN,DERONE,DERTWO
      LOGICAL NODER,DIAGAB,DIAGCD,SHABAB,SHAEQC,SHBEQD,
     &        SHAEQB,SHCEQD,
     &        BIGVEC,DCMPAB,DCMPCD,TCONAB,TCONCD,NOPMAT,NODV
      LOGICAL CANON
      LOGICAL EXIST
      LOGICAL CHAB,CHAB1,CHCD,CHCD1
      LOGICAL IFIRST,IALL,XCOMP,YCOMP,ZCOMP 
      INTEGER DIRPRD,REORD
      CHARACTER*8 NAME
C
      PARAMETER (LUCMD = 5, LUPRI = 6)
#include "baslims.par"
#include "mxcent.par"
C
      DIMENSION ICGTOA(MXAOVC), ICGTOB(MXAOVC),
     &          ICGTOC(MXAOVC), ICGTOD(MXAOVC)
C
      DIMENSION SO(1),REORD(NBASIS,NIR+1)
      DIMENSION BUCK(IBKSIZ,NUMBUF),IBUCK(IBKSIZ,NUMBUF)
      DIMENSION NINBCK(NUMBUF)
C
      COMMON/BFILE/IUNIT(24),NAME(24),EXIST(12)
      COMMON/INTADR/IWKAO,IWKSO,IWKHHS,IWK1HH,IWK1HC,IWKLST
      COMMON/SYMMET/FMULT(0:7),PT(0:7),MAXLOP,MAXLOT,MULT(0:7),
     &              ISYTYP(3),ITYPE(8,36),NPARSU(8),NPAR(8),NAOS(8),
     &              NPARNU(8,8),IPTSYM(MXCORB,0:7),IPTCNT(3*MXCENT,0:7),
     &              NCRREP(0:7),IPTCOR(MXCENT*3),NAXREP(0:7),IPTAX(3),
     &              IPTXYZ(3,0:7)
      COMMON/EXPCOM/SIGNXYZ(12),NCENT1,NCENT2,NCENT3,NCENT4,
     &              ISON(4),DERONE,DERTWO,TWOCEN,THRCEN,FOUCEN,
     &              NINTYP,NCCINT
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8) 
      COMMON/PERT/NTPERT,NPERT(8),IPERT(8),IXPERT,IYPERT,IZPERT,
     &            IXYPERT(3)
      COMMON/GOFF/IGOFF
      COMMON/TREATP/IFIRST,IALL,XCOMP,YCOMP,ZCOMP,IBF,IBL
C
      DATA FOURTH,HALF,ONE,TWO,FOUR,ZERADD,AZERO /0.25D0,0.5D0,1.0D0,
     &     2.0D0,4.0D0,1.D-16,0.D0/
      DATA THRSH/1.D-09/
C
      IBTAND(I,J) = AND(I,J)
      IBTOR(I,J)  = OR(I,J)
      IBTXOR(I,J) = XOR(I,J)
C
      ITRI(I,J) = MAX(I,J)*(MAX(I,J) - 1)/2 + MIN(I,J)
      IPACK(I,J,K,L)=OR(OR(OR(I,ISHFT(J,IBITWD)),ISHFT(K,2*IBITWD)),
     &                   ISHFT(L,3*IBITWD))
C
      IAOFF=1
      NCCINT2=NCCINT*IGOFF
C
C  LOOP OVER SHELL COMPONENTS 
C
c      write(*,*) diagab,diagcd,tconab,tconcd
      DO 100 ICOMPA=1,KHKTA
       ITYNA=ITYPE(NHKTA,ICOMPA)
       KHKTBB=KHKTB
       IF(DIAGAB) KHKTBB=ICOMPA
       DO 200 ICOMPB = 1,KHKTBB
        ITYNB=ITYPE(NHKTB,ICOMPB)
        CHAB=SHAEQB.AND.(ICOMPA.EQ.ICOMPB)
        DO 300 ICOMPC=1,KHKTC
         ITYNC=ITYPE(NHKTC,ICOMPC)
         KHKTDD=KHKTD
         IF(DIAGCD) KHKTDD=ICOMPC
         DO 400 ICOMPD=1,KHKTDD
          ITYND=ITYPE(NHKTD,ICOMPD)
          CHCD=SHCEQD.AND.(ICOMPC.EQ.ICOMPD) 
C
C  LOOP OVER IRREPS
C
          DO 110 IREPA=0,MAXLOP
          IF(IBTAND(MULA,IBTXOR(IREPA,ITYNA)).NE.0) GO TO 110
          DO 210 IREPB=0,MAXLOP
          IF(IBTAND(MULB,IBTXOR(IREPB,ITYNB)).NE.0) GO TO 210
          IREPAB=IBTXOR(IREPA,IREPB)
          DO 310 IREPC=0,MAXLOP
          IF(IBTAND(MULC,IBTXOR(IREPC,ITYNC)).NE.0) GO TO 310
          IREPABC=IBTXOR(IREPAB,IREPC)
          IREPAC=IBTXOR(IREPA,IREPC)
          IREPBC=IBTXOR(IREPB,IREPC)
          DO 410 IREPD=0,MAXLOP
          IF(IBTAND(MULD,IBTXOR(IREPD,ITYND)).NE.0) GO TO 410
          IREPCD=IBTXOR(IREPC,IREPD)
          IREPAD=IBTXOR(IREPA,IREPD)
          IREPBD=IBTXOR(IREPB,IREPD)
          IREPX=IBTXOR(IREPABC,IREPD)
C
          IAOADR=IAOFF
C
C DETERMINE TYPE OF BUCKET
C
          IF(IREPX.EQ.0) THEN
C
C TOTAL SYMMETRIC PERTURBATION
C
           IF(IREPAB.EQ.0) THEN 
            IF(IREPAC.EQ.0) THEN
C  IIII
             IBTYPE=1
            ELSE
C  IIJJ
             IBTYPE=2
            ENDIF
           ELSE IF(IREPAC.EQ.0.OR.IREPAD.EQ.0) THEN
C  IJIJ
            IBTYPE=3
           ELSE
C  IJKL
            IBTYPE=4
           ENDIF
          ELSE
C
C  OTHER PERTURBATIONS
C
           IF(IREPAB.EQ.0) THEN
            IF(IREPAC.EQ.0.OR.IREPAD.EQ.0) THEN
C IIIJ
             IBTYPE=1
            ELSE
C IIJK
             IBTYPE=2
            ENDIF
           ELSE IF(IREPCD.EQ.0) THEN
            IF(IREPAC.EQ.0.OR.IREPBC.EQ.0) THEN
C IIIJ
             IBTYPE=1
            ELSE
C IIJK
             IBTYPE=2
            ENDIF
           ELSE IF(IREPAC.EQ.0.OR.IREPAD.EQ.0.OR.IREPBC.EQ.0.OR.
     &             IREPBD.EQ.0) THEN
C IJIK
            IBTYPE=3
           ELSE
C IJKL
            IBTYPE=4
           ENDIF
          ENDIF  
C
C  LOOP OVER CONTRACTED FUNCTIONS
C
          DO 500 IORBA=1,NORBA
           INDXA=ICGTOA(IORBA)+IORBA+(ICOMPA-1)*NORBA
           INDXA1=REORD(INDXA,IREPA+1)
           NORBBB=NORBB
           IF (TCONAB) NORBBB=IORBA
           DO 600 IORBB=1,NORBBB
            INDXB=ICGTOB(IORBB)+IORBB+(ICOMPB-1)*NORBB
            INDXB1=REORD(INDXB,IREPB+1)
            CHAB1=CHAB
            IF(TCONAB) CHAB1=CHAB.AND.(IORBA.EQ.IORBB)
            DO 700 IORBC=1,NORBC
             INDXC=ICGTOC(IORBC)+IORBC+(ICOMPC-1)*NORBC
             INDXC1=REORD(INDXC,IREPC+1)
             NORBDD=NORBD
             IF(TCONCD) NORBDD=IORBC
             DO 800 IORBD=1,NORBDD
              INDXD=ICGTOD(IORBD)+IORBD+(ICOMPD-1)*NORBD
              INDXD1=REORD(INDXD,IREPD+1)
              CHCD1=CHCD
              IF(TCONCD) CHCD1=CHCD.AND.(IORBC.EQ.IORBD)
              INT1=IAOADR+(IBF-1)*NCCINT2
              INT2=INT1+3*NCCINT2
C
C MAKE SURE THAT ONLY INTEGRALS ACCORDING TO CANONICAL
C ORDERING ARE WRITTEN OUT
C THAT MEANS :  
C
C     SHELLA >= SHELLB,   SHELLC >= SHELLD
C     [SHELLA,SHELLB] >=  [SHELLC,SHELLD]
C
C   THIS MEANS :    INDXA >= INDXB
C                   INDXC >= INDXD
C
C                  FOR SHELLA = SHELLC   INDXA >= INDXC
C                  FOR INDXA = INDXC     INDXC >= INDXD
C
C  THE SECOND INTEGRAL IS ONLY WRITTEN OUT IN CASES
C  WHERE A NE B AND C NE D
C
C  CODED JG DEC/91
C
              CANON=.TRUE.
              IF(SHAEQC.AND.SHBEQD) THEN
               CANON=INDXA1.GE.INDXC1
               IF(INDXA1.EQ.INDXC1) CANON=INDXB1.GE.INDXD1
              ENDIF
              IF(CHAB1.AND.(INDXA1.LT.INDXB1)) CANON=.FALSE.
              IF(CHCD1.AND.(INDXC1.LT.INDXD1)) CANON=.FALSE.
              IF(CANON) THEN
              DO 900 I=IBF,IBL
C
C CHECK WHETHER IREPA X IREPB X IREPC X IREPD = IREPX
C
               IF(IXYPERT(I)-1.NE.IREPX) GO TO 890
C
               IBTYP=I+(IBTYPE-1)*3               
               VALUE=SO(INT1)
               IF(ABS(VALUE).LT.THRSH) GO TO 890
C
C PUT THIS INTEGRAL INTO A BUCKET
C
               NINBCK(IBTYP)=NINBCK(IBTYP)+1
               BUCK(NINBCK(IBTYP),IBTYP)=VALUE
               IBUCK(NINBCK(IBTYP),IBTYP)=
     &               IPACK(INDXA1,INDXB1,INDXC1,INDXD1)
c                write(*,2234) I,IBTYP,value,indxa1,indxb1,
c     &                               indxc1,indxd1
2234            format(' pert',i2,i3,' value ',f10.7,4i4)
               IF(NINBCK(IBTYP).EQ.IBKSIZ)THEN
                CALL WRSEQ(IUNIT(IBTYP),BUCK(1,IBTYP),
     &                     IBUCK(1,IBTYP),
     &                     NINBCK(IBTYP),IBKSIZ)
                NINBCK(IBTYP)=0
               ENDIF
C
890            CONTINUE
               INT1=INT1+NCCINT2
900           CONTINUE 
              IF((INDXA1.NE.INDXB1).AND.(INDXC1.NE.INDXD1))THEN
               DO 910 I=IBF,IBL
C
C CHECK WHETHER IREPA X IREPB X IREPC X IREPD = IREPX
C
               IF(IXYPERT(I)-1.NE.IREPX) GO TO 891
C
                IBTYP=I+(IBTYPE-1)*3               
                VALUE=SO(INT2)
                IF(ABS(VALUE).LT.THRSH) GO TO 891
C
C PUT THIS INTEGRAL INTO A BUCKET
C
                NINBCK(IBTYP)=NINBCK(IBTYP)+1
                BUCK(NINBCK(IBTYP),IBTYP)=VALUE
                IBUCK(NINBCK(IBTYP),IBTYP)=
     &                     IPACK(INDXA1,INDXB1,INDXD1,INDXC1)
c                write(*,2234) I,IBTYP,value,indxa1,indxb1,
c     &                                indxd1,indxc1
                IF(NINBCK(IBTYP).EQ.IBKSIZ)THEN
                 CALL WRSEQ(IUNIT(IBTYP),BUCK(1,IBTYP),
     &                      IBUCK(1,IBTYP),
     &                      NINBCK(IBTYP),IBKSIZ)
                 NINBCK(IBTYP)=0
                ENDIF
C
891             CONTINUE
                INT2=INT2+NCCINT2
910            CONTINUE
              ENDIF
              ENDIF
              IAOADR=IAOADR+1
800          CONTINUE
700         CONTINUE
600        CONTINUE
500       CONTINUE
          IAOFF=IAOFF+NOABCD
410      CONTINUE
310      CONTINUE
210      CONTINUE
110      CONTINUE
400      CONTINUE
300     CONTINUE
200    CONTINUE
100   CONTINUE
40    CONTINUE
30    CONTINUE
20    CONTINUE
10    CONTINUE
      RETURN
      END
