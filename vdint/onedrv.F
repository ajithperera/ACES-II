      SUBROUTINE ONEDRV(PROPTY,MAXDIF,FOCK,IDATOM,IDCOOR,
     &                  DIFINT,NODC,NODV,DIFDIP,LMAX,WORK1,
     &                  LWORK1,ENERKE,GRADKE,HESSKE,ENERNA,
     &                  GRADNA,HESSNA,GRADFS,HESFS2,DIPME,DIPMN,
     &                  DDIPE,DDIPN,QUADME,QUADMN,DQUADE,
     &                  DDQUADN,NCOORD,DOSCF)
C
C     THIS PROGRAM CALCULATES OVERLAP AND ONE-ELECTRON HAMILTONIAN
C     MATRIX ELEMENTS AND THE FIRST AND SECOND DERIVATIVES OF THESE
C     ELEMENTS USING THE MCMURCHIE/DAVIDSON SCHEME.  SEE L. E. MCMURCHIE
C     & E. R. DAVIDSON, J. COMP. PHYS. 26 (1978) 218, AND ALSO V. R.
C     SAUNDERS IN "METHODS IN COMPUTATIONAL MOLECULAR PHYSICS", REIDEL
C     1983.
C
C     VARIOUS EXTENSIONS (J. GAUSS) :
C
C     A) INCLUSION OF QUADRUPOLE INTEGRALS (4/91, QTP)
C     B) FC INTEGRALS (4/93 KARLSRUHE)
C     C) SD INTEGRALS (4/93 KARLSRUHE)
C     D) ECP DERIVATIVE INTEGRALS (-3/93) BY C. HUBER, KARLSRUHE
C
C     FOR OTHER AVAILABLE ONE-ELECTRON INTEGRALS, SEE NMR1DR
C
CEND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER AND,OR,XOR
      LOGICAL LAEQB,LDIAG,ONECEN,FOCK,DIFINT,NODC,NODV,
     &        SECDER,DIFDIP,DIFQUA,PROPTY,FULMAT,DOSCF
      LOGICAL SCF,NONHF,ELECT,MAGNET,GEOM,MAGNET2,GIAO
      LOGICAL TRAINV,IDFGH
      LOGICAL DCORD, DCORGD, NOORBT, DOPERT
      LOGICAL YESNO
      LOGICAL SHARE
      LOGICAL JSO,JFC,JSD,CCSDEH
      CHARACTER NAMEX*6
      CHARACTER*80 FNAME
C
#include "mxcent.par"
#include "baslims.par"
      PARAMETER (LUCMD = 5, LUPRI = 6)
      PARAMETER (AZERO = 0.00 D00, ONE = 1.00 D00,
     &           THREE = 3.00 D00, THIRD = ONE/THREE)
      PARAMETER (PI = 3.14159 26535 89793 D00)
#include "lwork.par"
      PARAMETER (LWKRLM = LWORK3 - 8020)
      PARAMETER (MXQN=8, MXAQN=MXQN*(MXQN+1)/2,
     &           MXAQNS=MXAQN*MXAQN*MXCONT*MXCONT)
C
CCH---------------------------------------------------------------------
C     PARAMETER FOR ECPGRAD
CCH---------------------------------------------------------------------
      PARAMETER (MXENTG = 10)
C --- MXENTG IS THE NUMBER OF DIFFERENT FUNCTIONS FOR LMAX (F-TYPE)
CCH---------------------------------------------------------------------
cYAU      DIMENSION DCRTOX(MXENTG,MXENTG,MXCENT,MXCONT,MXCONT)
cYAU      DIMENSION DCRTOY(MXENTG,MXENTG,MXCENT,MXCONT,MXCONT)
cYAU      DIMENSION DCRTOZ(MXENTG,MXENTG,MXCENT,MXCONT,MXCONT)
cYAU      DIMENSION DCRTBX(MXENTG,MXENTG,MXCENT,MXCONT,MXCONT)
cYAU      DIMENSION DCRTBY(MXENTG,MXENTG,MXCENT,MXCONT,MXCONT)
cYAU      DIMENSION DCRTBZ(MXENTG,MXENTG,MXCENT,MXCONT,MXCONT)
CCH---------------------------------------------------------------------
      DIMENSION GRADKE(NCOORD),HESSKE(NCOORD,NCOORD),
     &          GRADNA(NCOORD),HESSNA(NCOORD,NCOORD),
     &          GRADFS(NCOORD),HESFS2(NCOORD,NCOORD),
     &          DIPME(3),DDIPE(3,NCOORD),QUADME(6),
     &          DQUADE(6,NCOORD),DIPMN(3),DDIPN(3,NCOORD),
     &          QUADMN(6),DQUADN(6),ECP_Grad(MXCOOR)
      DIMENSION KSDAO(8,3),KFDAO(8)
      DIMENSION FACINT(MXCENT),
     &          CORCX(MXCENT), CORCY(MXCENT), CORCZ(MXCENT)
      DIMENSION WORK1(LWORK1)
      DIMENSION MULTAT(MXCENT)
CCH---------------------------------------------------------------------
C     COMMON FOR ECPGRAD
CCH---------------------------------------------------------------------
      COMMON /ECPFAC/ FACECP(MXCENT)
CCH---------------------------------------------------------------------
C
      COMMON /CWORK3/ WK3LOW, SHGTF, AHGTF((MXCENT+1)*(2*MXQN+1)**3)
CSSS                  RLMCOF(LWKRLM), WK3HGH
      COMMON /ADER/ ADER0 (MXAQNS)
      COMMON /POINTER/IS0000, IS000X, IS000Y, IS000Z,
     &                IS00XX, IS00XY, IS00XZ, IS00YY,
     &                IS00YZ, IS00ZZ, IT0000, IT000X,
     &                IT000Y, IT000Z, IT00XX, IT00XY,
     &                IT00XZ, IT00YY, IT00YZ, IT00ZZ,
     &                ID0000, ID000X, ID000Y, ID000Z,
     &                ID00XX, ID00XY, ID00XZ, ID00YX,
     &                ID00YY, ID00YZ, ID00ZX, ID00ZY,
     &                ID00ZZ,
     &                IA0000, IA0X00, IA0Y00, IA0Z00,
     &                IAXX00, IAXY00, IAXZ00, IAYY00,
     &                IAYZ00, IAZZ00, IA000X, IA000Y,
     &                IA000Z, IA00XX, IA00XY, IA00XZ,
     &                IA00YY, IA00YZ, IA00ZZ, IA0X0X,
     &                IA0X0Y, IA0X0Z, IA0Y0X, IA0Y0Y,
     &                IA0Y0Z, IA0Z0X, IA0Z0Y, IA0Z0Z
      COMMON /POINT2/ IQ00XX, IQ00XY, IQ00XZ, IQ00YY,
     &                IQ00YZ, IQ00ZZ
      COMMON /SCRPOIN/ISCR1(20),ISCR2(28)
      COMMON/DENPOIN/KDEN,KFOC
#include "odcs.com"
      COMMON /LMNS/ LVALUA(MXAQN), MVALUA(MXAQN), NVALUA(MXAQN),
     &              LVALUB(MXAQN), MVALUB(MXAQN), NVALUB(MXAQN)
      COMMON/CCOM/THRS,NHTYP,IBX
      COMMON /NUCLEIi/ NOORBT(MXCENT),
     &                NUCIND, NUCDEP, NUCPRE(MXCENT), NUCNUM(MXCENT,8),
     &                NUCDEG(MXCENT), ISTBNU(MXCENT), NDCORD,
     &                NDCOOR(MXCOOR), NTRACO, NROTCO, ITRACO(3),
     &                IROTCO(3),
     &                NATOMS, NFLOAT,
     &                IPTGDV(3*MXCENT),
     &                NGDVEC(8), IGDVEC(8)
      COMMON /NUCLEI/ CHARGE(MXCENT), CORD(MXCENT,3),
     &                DCORD(MXCENT,3),DCORGD(MXCENT,3),
     &                DOPERT(0:3*MXCENT)
      COMMON /NUCLEC/ NAMEX(MXCOOR)
      COMMON /FLAGS/  IFLAGS(100)
      COMMON /PRIMIT/ PRIEXP(MXPRIM), PRICCF(MXPRIM,MXAOVC),
     &                PRICRX(MXPRIM), PRICRY(MXPRIM), PRICRZ(MXPRIM)
      COMMON /SHELLSi/ KMAX,
     &                NHKT(MXSHEL),   KHKT(MXSHEL), MHKT(MXSHEL),
     &                ISTBAO(MXSHEL), NUCO(MXSHEL), JSTRT(MXSHEL),
     &                NSTRT(MXSHEL),  MST(MXSHEL),  NCENT(MXSHEL),
     &                NRCO(MXSHEL), NUMCF(MXSHEL),
     &                NBCH(MXSHEL),   KSTRT(MXSHEL)
      COMMON /SHELLS/ CENT(MXSHEL,3), SHARE(MXSHEL)
      COMMON /SYMMET/ FMULT(0:7), PT(0:7),
     &                MAXLOP, MAXLOT, MULT(0:7), ISYTYP(3),
     &                ITYPE(8,36), NPARSU(8), NPAR(8), NAOS(8),
     &                NPARNU(8,8), IPTSYM(MXCORB,0:7),
     &                IPTCNT(3*MXCENT,0:7), NCRREP(0:7),
     &                IPTCOR(MXCENT*3), NAXREP(0:7), IPTAX(3),
     &                IPTXYZ(3,0:7)
      COMMON /SYMIND/ INDFA(8,10), INDFB(8,10), ISOFRA(8), ISOFRB(8)
      COMMON /HRUNIT/ LUONEL, LUINTA, LUSUPM, LUDASP, LUSOL
      COMMON /CENTC/ SIGNCX(MXCENT), SIGNCY(MXCENT), SIGNCZ(MXCENT),
     &               NCENTC(MXCENT), JSYMC(MXCENT),  JCENTC(MXCENT),
     &               ICXVEC(MXCENT), ICYVEC(MXCENT), ICZVEC(MXCENT)
      COMMON/METHOD/IUHF,SCF,NONHF
      COMMON/PROP/ELECT,MAGNET,GEOM,MAGNET2,GIAO 
      COMMON/BASSYM/NBAS(8),NBASIS,NBASSQ,NBASTT
      COMMON/BASSPH/NBAS5(8),NBASIS5,NBASSQ5,NBASTT5
      COMMON /LSYM/ NLENQ(8),NLENT(8)
      COMMON /LSYMSPH/ NLENQ5(8),NLENT5(8)
      COMMON /GENCON/NRCA,NRCB,CONTA(MXCONT),CONTB(MXCONT)
      COMMON /INVAR/TRAINV
      COMMON /PERT/NTPERT,NPERT(8),IPERT(8),IXPERT,IYPERT,IZPERT,
     &             IYZPERT,IXZPERT,IXYPERT,ITRANSX,ITRANSY,ITRANSZ,
     &             NUCIND1
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/IPRI/IPRINT
      COMMON/DFGH/IDFGH
      COMMON/JNMR/JSO,JFC,JSD
      COMMON/EH/CCSDEH
CCH---------------------------------------------------------------------
C     COMMON FOR ECPGRAD
CCH---------------------------------------------------------------------
      COMMON /ECP   / IECP
CCH---------------------------------------------------------------------
C
      IBTAND(I,J) = AND(I,J)
      IBTOR(I,J)  = OR(I,J)
      IBTXOR(I,J) = XOR(I,J)
C
C SET DERIVATIVE LEVEL FOR SD INTEGRAL EVALUATION
C
      IF(IFLAGS(2).GT.2) INCREML=47
      IF(JSD) MAXDIF=2
      DIFQUA=.FALSE.
      SECDER = MAXDIF .EQ. 2
      TOLS   = THRS*THRS
      TOLOG  = - LOG(TOLS)
CAP      IPRINT = 40
C
      NNBASX = NBASIS*(NBASIS + 1)/2
C
C  COMPUTE NUCLEAR CONTRIBUTIONS
C
      IF (PROPTY) THEN
       CALL DIPNUC(DIFDIP,DIPMN,DDIPN,NCOORD)
       CALL QUANUC(DIFQUA,QUADMN,DQUADN,NCOORD)
C
C  SET GRADIENT AND HESSIAN ELEMENTS EQUAL TO ZERO
C
       ENERKE = AZERO
       ENERNA = AZERO
       CALL ZERO(GRADKE(1),NCOORD)
       CALL ZERO(GRADNA(1),NCOORD)
       CALL ZERO(GRADFS(1),NCOORD)
       IF (SECDER) THEN
        CALL ZERO(HESSKE,NCOORD*NCOORD)
        CALL ZERO(HESSNA,NCOORD*NCOORD)
        CALL ZERO(HESFS2,NCOORD*NCOORD)
       END IF
       CALL ZERO(DIPME,3)
       CALL ZERO(QUADME,6)
       IF (DIFDIP) THEN
        CALL ZERO(DDIPE(1,1),3*NCOORD)
       ENDIF
       IF(DIFQUA) THEN
        CALL ZERO(DQUADE(1,1),3*NCOORD)
       END IF
C
C SET UP TOTAL DENSITY AND FOCK MATRICES IN AO BASIS
C
       KDEN=1
       KFOC=KDEN+NBASIS*(NBASIS+1)/2
       KSTART=KFOC+NBASIS*(NBASIS+1)/2
       KCMO=KSTART 
       KFT=KCMO+NBASIS*NBASIS
       KDV=KFT+NBASIS*NBASIS
C
       KDSO=KDV+NBASIS*NBASIS
       KFSO=KDSO+NBASIS*NBASIS
C
C ALLOCATE FURTHER MEMORY FOR DSOFSO
C
       KSCR=KFSO+NBASIS*NBASIS
       KEND=KSCR+2*NBASIS*NBASIS
C
       IF(CCSDEH) THEN
        mxcor=(lwork1-kscr+1)*iintfp
        call dmpden(work1(kscr),mxcor,iuhf)
       ENDIF
C
C CALCULATE TOTAL DENSITY MATRIX IN PRIMITIVE AO-BASIS
C
       CALL DSOFSO(WORK1(KCMO),WORK1(KFT),WORK1(KDV),
     &             WORK1(KDSO),WORK1(KDSO),WORK1(KFSO),
     &             WORK1(KSCR),.FALSE.,DOSCF)
       CALL DSYM1(WORK1(KDEN),WORK1(KDEN),WORK1(KFOC),
     &            WORK1(KDSO),WORK1(KDSO),WORK1(KFSO),
     &            NBASIS,.FALSE.)
      ENDIF
      IF(CCSDEH) THEN
C
C  MEMORY FOR DIPOLE INTEGRALS IN CCSD-EH CALCULATIONS
C
       KDPXAO=KSTART
       KDPYAO=KDPXAO+NLENT(IXPERT)
       KDPZAO=KDPYAO+NLENT(IYPERT)
       KQXXAO=KDPZAO+NLENT(IZPERT)
       KQXYAO=KQXXAO+NLENT(1)
       KQXZAO=KQXYAO+NLENT(IXYPERT)
       KQYYAO=KQXZAO+NLENT(IXZPERT)
       KQYZAO=KQYYAO+NLENT(1)
       KQZZAO=KQYZAO+NLENT(IYZPERT)
       KSTART=KQZZAO+NLENT(1)      
C
C ZERO OUT THE MEMORY FOR ALL THESE DERIVATIVES
C
       CALL ZERO(WORK1(KDPXAO),KSTART-KDPXAO)
C
      ENDIF
C
      IF(FOCK.AND.(.NOT.JFC).AND.(.NOT.JSD))THEN
C
C  MEMORY FOR DIPOLE INTEGRALS
C
       KDPXAO=KSTART 
       KDPYAO=KDPXAO + NLENT(IXPERT)
       KDPZAO=KDPYAO + NLENT(IYPERT)
C
C  MEMORY FOR OVERLAP DERIVATIVE INTEGRALS
C
       KSDAO(1,1)=KDPZAO+NLENT(IZPERT)
       DO 11 IRREP=1,MAXLOP
        KSDAO(IRREP+1,1)=KSDAO(IRREP,1)+NLENT(IRREP)*NPERT(IRREP)
11     CONTINUE
C
C CORE MEMORY FOR FOCK MATRIX DERIVATIVES
C
       KFDAO(1)=KSDAO(MAXLOP+1,1)+NLENT(MAXLOP+1)*NPERT(MAXLOP+1)
       DO 14 IRREP=1,MAXLOP
        KFDAO(IRREP+1)=KFDAO(IRREP)+NLENT(IRREP)
     &                   *NPERT(IRREP)
14     CONTINUE
       KSTART=KFDAO(MAXLOP+1)+NLENT(MAXLOP+1)
     &                   *NPERT(MAXLOP+1)
C
C ZERO OUT THE MEMORY FOR ALL THESE DERIVATIVES
C
CJDW 11/7/95. Without these two write statements a C1 MBPT(2) VIB=EXACT
C             calculation on OH bombs on the OSC and SDSC Crays. It dies in
C             ZERO. With the write statements, it runs (and gives correct
C             results).
C
cYAU      write(6,*) ' @ONEDRV-I, maxlop, kdpxao,kstart '
cYAU      write(6,*) maxlop, kstart, kdpxao,lwork1
       CALL ZERO(WORK1(KDPXAO),KSTART-KDPXAO)
C
      ENDIF
C
C ALLOCATE MEMORY FOR CALCULATION OF JC AND/OR SD INTEGRALS
C
      IF(JFC.OR.JSD) THEN
       KFDAO(1)=1
       DO 12 IRREP=1,MAXLOP
        KFDAO(IRREP+1)=KFDAO(IRREP)+NLENT(IRREP)*NPERT(IRREP)
12     CONTINUE
       KSTART=KFDAO(MAXLOP+1)+NLENT(MAXLOP+1)
     &                   *NPERT(MAXLOP+1)
C
C ZERO OUT THE MEMORY FOR ALL THESE DERIVATIVES
C
       CALL ZERO(WORK1(KFDAO(1)),KSTART-KFDAO(1))
C
      ENDIF
C
C ALLOCATE MEMORY FOR ECP ARRAYS
C
      I_DCRTOX = KSTART
      I_DCRTOY = KSTART
      I_DCRTOZ = KSTART
      I_DCRTBX = KSTART
      I_DCRTBY = KSTART
      I_DCRTBZ = KSTART
      IF (IECP.EQ.1) THEN
c      o use the max dimensions for this system
         KHKTA = 0
         DO ISHELA = 1, KMAX
            KHKTA = MAX(KHKTA,KHKT(ISHELA))
         END DO
         N = KHKTA*KHKTA*NATOMS*MXCONT*MXCONT
         I_DCRTOY = I_DCRTOX + N
         I_DCRTOZ = I_DCRTOY + N
         I_DCRTBX = I_DCRTOZ + N
         I_DCRTBY = I_DCRTBX + N
         I_DCRTBZ = I_DCRTBY + N
         KSTART   = I_DCRTBZ + N
      END IF
C
C CHECK MEMORY
C
      IF (KSTART.GT.LWORK1) THEN
         print *, '@ONEDRV: Insufficient memory'
         print *, '         need ',kstart,' dbls'
         print *, '         have ',lwork1,' dbls'
         call errex
      END IF
C
#ifdef _DEBUG_LVLM1
      Write(6,*) "Entering the ECP_DGRAD"
#endif
      IF (IECP .EQ. 1) CALL ECP_DGRAD(Work1(KDSO), NBASIS, NCOORD,
     &                                NBAS, ECP_Grad)

      CALL IZERO(ISOFRA, 8)
C
C  LOOP OVER FIRST SHELL : ISHELA
C
      IDENA = 0
C
      DO 100 ISHELA = 1,KMAX
C
C NHKTA: ANGULAR MOMENTUM OF ISHELA 1=S, 2=P, ...
C
       NHKTA = NHKT(ISHELA)
C
C KHKTA: NUMBER OF DIFFERENT FUNCTIONS PER PRIMITIVE 1 FOR S, 3 FOR P, ...
C 
       KHKTA = KHKT(ISHELA)
C
C MHKTA:
C
       MHKTA = MHKT(ISHELA)
C
C ROUTINE LMNVAL DETERMINES THE VALUES: LVALUA,MVALUA, AND NVALUA
C WHICH GIVE THE EXPONENTS l,m,n FOR THE CARTESIAN GAUSSIANS
C
       CALL LMNVAL(NHKTA,MHKTA,LVALUA,MVALUA,NVALUA)
C
C NCENTA: NUMBER OF THE ATOM WHICH CORRESPONDS TO ISHELA
C         (WITHIN THE LIST OF NON-SYMMETRY EQUIVALENT ATOMS)
C
       NCENTA = NCENT(ISHELA)
C
C ICENTA: THE NUMBER OF THE ATOM WHICH CORRESPONDS TO ISHELA 
C         WITHIN THE LISTS OF ALL ATOMS CONSIDERING THE FIRST
C         MEMBER OF ALL SYMMETRY EQUIVALENT SHELLS ISHELA
C
       ICENTA = NUCNUM(NCENTA,1)
C
C  MULA: BITMAP SHOWING UNDER WHICH OPEREATIONS ISHELA IS
C  REDUNDANT:   1 --> FIRST OPERATION, 2 --> SECOND OPERATION,
C  3 --> FIRST AND SECOND OPERATIONS, 4 --> THIRD OPERATION,
C  5 --> FIRST AND THIRD OPERATIONS, 6 --> SECOND AND THIRD
C  OPERATIONS, 7 --> ALL OPERATIONS
C
       MULA   = ISTBAO(ISHELA)
C
C MULTA:  NUMBER OF SYMMETRY EQUIVALENT SHELLS WHICH BELONG TO ISHELA
C
       MULTA  = MULT(MULA)
C
C NUCA: NUMBER OF PRIMITIVES
C
       NUCA   = NUCO(ISHELA)
C
C NRCA: NUMBER OF CONTRACTIONS
C
       NRCA   = NRCO(ISHELA)
C
C NUMCFA: .... 
C
       NUMCFA = NUMCF(ISHELA)
C
C JSTA: OFFSET IN LIST OF PRIMITIVES FOR ISHELA
C
       JSTA   = JSTRT(ISHELA)
C
C CORAX, CORAY, CORAY: COORDINATES OF THE CENTER OF ISHELA
C
       CORAX  = CENT(ISHELA,1)
       CORAY  = CENT(ISHELA,2)
       CORAZ  = CENT(ISHELA,3)
C
       IDENB0 = 0
C
C COMPUTE SYMMETRY INTEGRAL POINTERS FOR CONTRIBUTIONS
C FROM THIS BLOCK.  NOTE THAT AT PRESENT THIS ASSUMES ALL
C COMPONENTS FROM A SHELL ARE INCLUDED.
C
       DO 600 I = 1, 8
        ISOFRB(I) = 0
        DO 610 J = 1, 10
         INDFA(I,J) = -10 000 000
610     CONTINUE
600    CONTINUE
C
       DO 620 NA = 1, KHKTA
        DO 630 IREP = 0, MAXLOP
         IF (IBTAND(MULA,IBTXOR(IREP,ITYPE(NHKTA,NA))).EQ.0) THEN
          ISOFRA(IREP+1)    = ISOFRA(IREP+1) + NRCA
          INDFA (IREP+1,NA) = ISOFRA(IREP+1)
         END IF
630     CONTINUE
620    CONTINUE
C
C LOOP OVER SECOND SHELL : ISHELB 
C
C THE LOOP IS TRIANGULAR, I.E ISHELA GE ISHELB
C
       DO 110 ISHELB = 1,ISHELA
C
C IF SHELLS ARE EQUAL SET LAEQB TO TRUE 
C
        LAEQB = ISHELA .EQ. ISHELB
C
        NHKTB = NHKT(ISHELB)
        KHKTB = KHKT(ISHELB)
        MHKTB = MHKT(ISHELB)
        CALL LMNVAL(NHKTB,MHKTB,LVALUB,MVALUB,NVALUB)
        NCENTB = NCENT(ISHELB)
C
C NHKTAB: THE SUM OF ANGULAR MOMENTUMS OF SHELL A AND B ( OF COURSE + 2) 
C
        NHKTAB = NHKTA + NHKTB
        MULB   = ISTBAO(ISHELB)
        MULTB  = MULT(MULB)
        NUCB   = NUCO(ISHELB)
        NRCB   = NRCO(ISHELB)
        NUMCFB = NUMCF(ISHELB)
        JSTB   = JSTRT(ISHELB)
        CORBX0 = CENT(ISHELB,1)
        CORBY0 = CENT(ISHELB,2)
        CORBZ0 = CENT(ISHELB,3)
C
C THE SIZE OF THE ARRAY OF PRIMITIVES OF ISHELA TIMES PIMITIVES ISHELB
C
        KHKTAB = KHKTA*KHKTB
C
C MAB: THE SYMMETRY OPERATIONS UNDER WHICH AT LEAST ONE OF BOTH
C      SHELLS IS CHANGING
C
        MAB    = IBTOR(MULA,MULB)
C
C KAB: THE SYMMETRY OPERATIONS UNDER WHICH BOTH SHELLS ARE CHANGING
C
        KAB    = IBTAND(MULA,MULB)
C
C THE MULTIPLICITY FACTOR WHICH CORRESPONDS TO KAB
C
        HKAB   = FMULT(KAB)
C
C COMPUTE SYMMETRY INTEGRAL POINTERS FOR CONTRIBUTIONS
C FROM THIS BLOCK.  NOTE THAT AT PRESENT THIS ASSUMES ALL
C COMPONENTS FROM A SHELL ARE INCLUDED
C
        DO 700 I = 1, 8
         DO 710 J = 1, 10
          INDFB(I,J) = -10 000 000
710      CONTINUE
700     CONTINUE
        DO 720 NB = 1, KHKTB
         DO 730 IREP = 0, MAXLOP
          IF (IBTAND(MULB,IBTXOR(IREP,ITYPE(NHKTB,NB))).EQ.0) THEN
           ISOFRB(IREP+1)    = ISOFRB(IREP+1) + NRCB
           INDFB (IREP+1,NB) = ISOFRB(IREP+1)
          END IF
730      CONTINUE
720     CONTINUE
C
C INITIALIZATION FOR NUCLEAR ATTRACTION INTEGRALS
C
C JMAX: THE MAXIMUM ANGULAR MOMENTUM NECEESARY TO CONSIDER, HOWEVER
C       ADD THE LEVEL OF DIFFERENTIATION
C
        JMAX = NHKTAB - 2
        JMAX=JMAX+MAXDIF
        ISTEPU = JMAX + 1
        ISTEPV = ISTEPU*ISTEPU
        NAHGTF = ISTEPU*ISTEPV
C
C NATOMC: NUMBER OF ATOMS CONSIDERED FOR NUCLEAR ATTRACTION INTEGRALS
C
        NATOMC = 0
C
C LOOP OVER ALL NUCLEI CONSIDERED FOR NUCLEAR ATTRACTION 
C INTEGRALS (ONLY THOSE WHICH ARE NON-SYMMETRY EQUIVALENT)
C
        DO 120 IATOMC = 1,NUCIND
C
C MULC: BITMAP POINTING TO THE OPERATIONS UNDER WHICH ATOM C
C       IS REDUNDANT
C
         MULC = ISTBNU(IATOMC)
C
C MABC: BITMAP POINTING TO THE OPERATIONS UNDER WHICH AT LEAST
C       ONE OF ISHELA, ISHELB, AND IATOM C IS CHANGING
C
         MABC = IBTOR(MULC,KAB)
C
C THE COORDINATES OF ATOM C
C
         CORCX0 = CORD(IATOMC,1)
         CORCY0 = CORD(IATOMC,2)
         CORCZ0 = CORD(IATOMC,3)
C
C FACTOR CONSISTING OF NEGATIVE CHARGE OF ATOM TIMES A MULTIPLICITY
C CORRESPONDING TO THE REDUNDANCIES OF A,B,C OVER THE MULTIPLICITY
C CORRESPONDING THE REDUNDANCIES OF A AND B UNDER ALL SYMMETRY
C OPERATIONS
C 
         FACTOR = - FMULT(IBTAND(MULC,KAB))*CHARGE(IATOMC)/HKAB
         IF(JFC) FACTOR=-FACTOR/CHARGE(IATOMC)
         FACECP(IATOMC) =  FMULT(IBTAND(MULC,KAB))/HKAB
C
C LOOP OVER ALL SYMMETRY OPERATIONS 
C
         DO 130 ISYMOP = 0, MAXLOT
C
C IS ISYMOP IS NOT CREATING A NEW A,B,C COMBINATION SKIP
C
          IF (IBTAND(ISYMOP,MABC) .EQ. 0) THEN
C
C INCREMENT NATOMC
C
           NATOMC = NATOMC + 1
C
C JSYMC: SYMMETRY OPERATIONS WHICH CREATED ATOM NATOMC
C
           JSYMC(NATOMC)  = ISYMOP
C
C JCENTC: SET OF SYMMETRY EQUIVALENT ATOMS TO WHICH NATOMC BELONGS
C
           JCENTC(NATOMC) = IATOMC
C
C SIGNCX, ... DETERMINE WHETHER THE COORDINATES CHANGE SIGN UNDER
C             THE SYMMETRY OPERATION
C
           SIGNCX(NATOMC) = PT(IBTAND(ISYTYP(1),ISYMOP))
           SIGNCY(NATOMC) = PT(IBTAND(ISYTYP(2),ISYMOP))
           SIGNCZ(NATOMC) = PT(IBTAND(ISYTYP(3),ISYMOP))
C
C COORDINATES FOR NATOMC CREATED FROM THOSE FOR ATOM C
C
           CORCX(NATOMC)  = SIGNCX(NATOMC)*CORCX0
           CORCY(NATOMC)  = SIGNCY(NATOMC)*CORCY0
           CORCZ(NATOMC)  = SIGNCZ(NATOMC)*CORCZ0
C
C FACTOR FOR NATOMC
C
           FACINT(NATOMC) = FACTOR
C
C NUMBER OF ATOM NATOMC IN THE LIST OF ALL ATOMS
C
           NCENTC(NATOMC) = NUCNUM(IATOMC,ISYMOP+1)
C
C ICXVEC, ... 
           ICXVEC(NATOMC) = IPTCNT(3*IATOMC-2,0)
           ICYVEC(NATOMC) = IPTCNT(3*IATOMC-1,0)
           ICZVEC(NATOMC) = IPTCNT(3*IATOMC  ,0)
          END IF
130      CONTINUE
120     CONTINUE
C
C  LOOP OVER SYMMETRY OPERATIONS WITH RESPECT TO
C  THE SECOND SHELL
C
        IDENB = IDENB0 - KHKTB*NRCB
C
        DO 200 ISYMOP = 0, MAXLOT
C
C CONSIDER THIS SYMMETRY OPERATION ONLY
C IF IT PROVIDES A NEW SHELL
C SKIP IF REDUNDANT
C
         IF(IBTAND(ISYMOP,MAB) .NE. 0) GO TO 200
C
         IDENB  = IDENB + KHKTB*NRCB
C
C LDIAG IS SET TO TRUE IF BOTH SHELLS ARE IDENTICAL ( ONLY
C TRUE IF ISYMOP IS 0 AND LAEQB IS TRUE
C
         LDIAG  = LAEQB
         IF(ISYMOP.NE.0) LDIAG=.FALSE.
C
         ICENTB = NUCNUM(NCENTB,ISYMOP+1)
         ONECEN = (ICENTA .EQ. ICENTB).AND.(.NOT.JSD)
         SIGNBX = PT(IBTAND(ISYTYP(1),ISYMOP))
         SIGNBY = PT(IBTAND(ISYTYP(2),ISYMOP))
         SIGNBZ = PT(IBTAND(ISYTYP(3),ISYMOP))
         CORBX  = SIGNBX*CORBX0
         CORBY  = SIGNBY*CORBY0
         CORBZ  = SIGNBZ*CORBZ0
         DIFABX = CORAX - CORBX
         DIFABY = CORAY - CORBY
         DIFABZ = CORAZ - CORBZ
         DISTAB = DIFABX*DIFABX + DIFABY*DIFABY + DIFABZ*DIFABZ
C
         IF (ONECEN) THEN
          NHKTAP = NHKTA
         ELSE
          NHKTAP = NHKTA + 2 + MAXDIF
         END IF
         ISTEPB = NHKTAP + NHKTB
         ISTEPA = NHKTB*ISTEPB
         NATOT  = 0
         NINT=KHKTAB*NRCA*NRCB
         IF(LDIAG) NINT=KHKTAB*(NRCA*(NRCA+1)/2)
         NINTS = NATOMC*NINT
         IF(JFC) THEN
          IS000X=KSTART-1
          ITOP=IS000X+NINTS
          NATOT=NINTS
          CALL ZERO(WORK1(IS000X+1),NATOT)
         ELSE IF(JSD) THEN
          IS00XX=KSTART-1
          IS00XY=IS00XX+NINTS
          IS00XZ=IS00XY+NINTS
          IS00YY=IS00XZ+NINTS
          IS00YZ=IS00YY+NINTS
          IS00ZZ=IS00YZ+NINTS
          ITOP=IS00ZZ+NINTS
          NATOT=6*NINTS
          CALL ZERO(WORK1(IS00XX+1),NATOT)
         ELSE
          IS0000 = KSTART-1
          IS000X = IS0000+NINT
          IS000Y = IS000X+NINT
          IS000Z = IS000Y+NINT
          IT0000 = IS000Z+NINT 
          IT000X = IT0000+NINT
          IT000Y = IT000X+NINT
          IT000Z = IT000Y+NINT
          ID0000 = IT000Z+NINT 
          ID000X = ID0000+NINT
          ID000Y = ID000X+NINT
          ID000Z = ID000Y+NINT
          IQ00XX = ID000Z+NINT
          IQ00XY = IQ00XX+NINT
          IQ00XZ = IQ00XY+NINT
          IQ00YY = IQ00XZ+NINT
          IQ00YZ = IQ00YY+NINT
          IQ00ZZ = IQ00YZ+NINT
          ITOP=IQ00ZZ+NINT
          NATOT=18*NINT
          CALL ZERO(WORK1(IS0000+1),NATOT)
          IF (ONECEN) THEN
           IA0000 = ITOP
           IA000X = IA0000 + NINTS
           IA000Y = IA000X + NINTS
           IA000Z = IA000Y + NINTS
           ITOP=IA000Z+NINTS
           NATOT=4*NINTS
           IF(SECDER) THEN
            IA00XX = IA000Z + NINTS
            IA00XY = IA00XX + NINTS
            IA00XZ = IA00XY + NINTS
            IA00YY = IA00XZ + NINTS
            IA00YZ = IA00YY + NINTS
            IA00ZZ = IA00YZ + NINTS
            ITOP=IA00ZZ+NINTS
            NATOT  = 10*NINTS
           ENDIF
           CALL ZERO(WORK1(IA0000 + 1),NATOT)
          ELSE
           ISTART= ITOP-NINT
           IF (SECDER) THEN
            IS00XX = ISTART + NINT
            IS00XY = IS00XX + NINT
            IS00XZ = IS00XY + NINT
            IS00YY = IS00XZ + NINT
            IS00YZ = IS00YY + NINT
            IS00ZZ = IS00YZ + NINT
            IT00XX = IS00ZZ + NINT
            IT00XY = IT00XX + NINT
            IT00XZ = IT00XY + NINT
            IT00YY = IT00XZ + NINT
            IT00YZ = IT00YY + NINT
            IT00ZZ = IT00YZ + NINT
            ID00XX = IT00ZZ + NINT
            ID00XY = ID00XX + NINT
            ID00XZ = ID00XY + NINT
            ID00YX = ID00XZ + NINT
            ID00YY = ID00YX + NINT
            ID00YZ = ID00YY + NINT
            ID00ZX = ID00YZ + NINT
            ID00ZY = ID00ZX + NINT
            ID00ZZ = ID00ZY + NINT
            ITOP=ID00ZZ+NINT
            NATOT=21*NINT
            CALL ZERO(WORK1(IS00XX+1),NATOT)
            ISTART=ID00ZZ
           END IF
           IA0000 = ISTART + NINT
           IA0X00 = IA0000 + NINTS
           IA0Y00 = IA0X00 + NINTS
           IA0Z00 = IA0Y00 + NINTS
           IA000X = IA0Z00 + NINTS
           IA000Y = IA000X + NINTS
           IA000Z = IA000Y + NINTS
           ITOP=IA000Z+NINTS
           NATOT=7*NINTS
           IF(SECDER) THEN
            IAXX00 = IA000Z + NINTS
            IAXY00 = IAXX00 + NINTS
            IAXZ00 = IAXY00 + NINTS
            IAYY00 = IAXZ00 + NINTS
            IAYZ00 = IAYY00 + NINTS
            IAZZ00 = IAYZ00 + NINTS
            IA0X0X = IAZZ00 + NINTS
            IA0X0Y = IA0X0X + NINTS
            IA0X0Z = IA0X0Y + NINTS
            IA0Y0X = IA0X0Z + NINTS
            IA0Y0Y = IA0Y0X + NINTS
            IA0Y0Z = IA0Y0Y + NINTS
            IA0Z0X = IA0Y0Z + NINTS
            IA0Z0Y = IA0Z0X + NINTS
            IA0Z0Z = IA0Z0Y + NINTS
            IA00XX = IA0Z0Z + NINTS
            IA00XY = IA00XX + NINTS
            IA00XZ = IA00XY + NINTS
            IA00YY = IA00XZ + NINTS
            IA00YZ = IA00YY + NINTS
            IA00ZZ = IA00YZ + NINTS
            ITOP=IA00ZZ+NINTS
            NATOT  = 28*NINTS
           ENDIF
           CALL ZERO(WORK1(IA0000 + 1),NATOT)
          ENDIF
         ENDIF
C
C ALLOCATE MEMORY FOR SCRATCH ARRAYS
C
         ISNUM=8
         JSNUM=7
         IF(SECDER) THEN
          ISNUM=20
          JSNUM=28
         ENDIF
         DO 298 INUM=1,ISNUM
          ISCR1(INUM)=ITOP+(INUM-1)*KHKTA*KHKTB
298      CONTINUE
         ITOP2=ITOP+ISNUM*KHKTA*KHKTB
         DO 299 INUM=1,JSNUM
          ISCR2(INUM)=ITOP2+(INUM-1)*KHKTA*KHKTB*NATOMC
299      CONTINUE
         ITOP3=ITOP2+JSNUM*KHKTA*KHKTB*NATOMC
         NSCR=(ISNUM+JSNUM*NATOMC)*KHKTA*KHKTB
C
C LOOP OVER PRIMITIVE ORBITALS 
C
            DO 300 IPRIMA = 1,NUCA
             JPRIMA = JSTA + IPRIMA
             DO 301 IRCA = 1,NRCA
              CONTA(IRCA) = PRICCF(JPRIMA,IRCA)
301          CONTINUE
             EXPA = PRIEXP(JPRIMA)
             DO 300 IPRIMB = 1,NUCB
              JPRIMB = JSTB + IPRIMB
              DO 302 IRCB = 1,NRCB
               CONTB(IRCB) = PRICCF(JPRIMB,IRCB)
302           CONTINUE
              EXPB = PRIEXP(JPRIMB) 
C
              IF(.NOT.JFC) THEN
C
              EXPP = EXPA + EXPB
              EXPPI = ONE/EXPP
C
C CALCULATE AND TEST SQUARE ROOT FACTOR
C
              EXPABQ = EXPA*EXPB*DISTAB*EXPPI
              IF (EXPABQ.GT.TOLOG) GO TO 300
              SAAB = EXP( - EXPABQ)
              ASAAB = ABS(SAAB)
              IF (ASAAB.LT.TOLS) GO TO 300
              SAAB13 = SIGN(ASAAB**THIRD,SAAB)
C
C CALCULATE COORDINATES OF PRODUCT GAUSSIAN P
C
              EXPAPI = EXPA*EXPPI
              EXPBPI = EXPB*EXPPI
              CORPX  = EXPAPI*CORAX + EXPBPI*CORBX
              CORPY  = EXPAPI*CORAY + EXPBPI*CORBY
              CORPZ  = EXPAPI*CORAZ + EXPBPI*CORBZ
C
C OVERLAP DISTRIBUTION COEFFICIENTS 
C
C EXPANSION COEFFICIENTS FOR UNDIFFERENTIATED ORBITALS
C
              DIFPAX = CORPX - CORAX
              DIFPAY = CORPY - CORAY
              DIFPAZ = CORPZ - CORAZ
              DIFPBX = CORPX - CORBX
              DIFPBY = CORPY - CORBY
              DIFPBZ = CORPZ - CORBZ
C              IPRINT = 21
              CALL ODC(NHKTAP,NHKTB,ISTEPA,ISTEPB,SAAB13,EXPPI,ONE,
     &                 DIFPAX,DIFPBX,DIFPAY,DIFPBY,DIFPAZ,DIFPBZ,
     &                 ONE,ONE,ONE,ONE,ONE,ONE,IPRINT)
C
C EXPANSION COEFFICIENTS FOR DERIVATIVES WITH
C RESPECT TO COORDINATES OF NUCLEUS A
C
               IF (.NOT.ONECEN) THEN
                CALL DODC(NHKTA,NHKTB,ISTEPA,ISTEPB,EXPA,IPRINT)
               END IF
               CALL TODC(NHKTA,NHKTB,ISTEPA,ISTEPB,EXPA)
C               IPRINT = 0
C
C  CALCULATION OF HERMITIAN INTEGRALS 
C
C  OVERLAP INTEGRAL
C
              SHGTF = SQRT(PI*EXPPI)
C
C  NUCLEAR ATTRACTION INTEGRALS
C
              IADR = 1
              DO 400 IATOMC = 1,NATOMC
               ICENTC = NCENTC(IATOMC)
               IF(.NOT.(ONECEN.AND.ICENTA.EQ.ICENTC)) THEN
                FACTOR = FACINT(IATOMC)
                DIFCPX = CORCX(IATOMC) - CORPX
                DIFCPY = CORCY(IATOMC) - CORPY
                DIFCPZ = CORCZ(IATOMC) - CORPZ
                CALL HERNAI(JMAX,EXPP,DIFCPX,DIFCPY,DIFCPZ,FACTOR,
     &                      IADR,ISTEPU,ISTEPV,NAHGTF,IPRINT)
               END IF
               IADR = IADR + NAHGTF
400           CONTINUE
C
C CALCULATION OF CARTESIAN INTEGRALS 
C
               CALL ZERO(WORK1(ITOP+1),NSCR)
               IF(JSD) THEN
                CALL SDINT(NHKTA,NHKTB,KHKTA,KHKTB,ICENTA,LDIAG,
     &                     ISTEPA,ISTEPB,ISTEPU,ISTEPV,NAHGTF,
     &                     NATOMC,CHARGE,WORK1)
               ELSE
                IF (ONECEN) THEN
                 CALL CINT1(NHKTA,NHKTB,KHKTA,KHKTB,ICENTA,LDIAG,
     &                      ISTEPA,ISTEPB,ISTEPU,ISTEPV,NAHGTF,
     &                      NATOMC,SECDER,WORK1)
                ELSE
              
                 CALL CINT2(NHKTA,NHKTB,KHKTA,KHKTB,
     &                      ISTEPA,ISTEPB,ISTEPU,ISTEPV,NAHGTF,
     &                      NATOMC,SECDER,LDIAG,WORK1)
                END IF
CSSS                Write(6, "(3(1x,F20.10))") (Work1(IS0000+i),i=1,NINTS)
CSSS                Write(6,*) 

                CALL DIPINT(NHKTA,NHKTB,KHKTA,KHKTB,LDIAG,ISTEPA,
     &                      ISTEPB,ONECEN,CORPX,CORPY,CORPZ,DIFDIP,
     &                      WORK1)

                CALL QUAINT(NHKTA,NHKTB,KHKTA,KHKTB,LDIAG,ISTEPA,
     &                      ISTEPB,ONECEN,CORPX,CORPY,CORPZ,EXPPI,
     &                      DIFQUA,WORK1)
               ENDIF
               ELSE
                CALL ZERO(WORK1(ITOP+1),NSCR)
                CALL FCINT(NHKTA,NHKTB,KHKTA,KHKTB,LDIAG,CORAX, 
     &                     CORAY,CORAZ,EXPA,
     &                     CORBX,CORBY,CORBZ,EXPB,CORCX,CORCY,
     &                     CORCZ,FACINT,NATOMC,WORK1)
               ENDIF
  300        CONTINUE
CSSS             Write(6,*) "The kinetic derivative integrals",ishela,
CSSS     &                   ishelb 
CSSS             Write(6, "(3(1x,F20.10))") (Work1(IAXX00+i),i=1,NATOT)
CSSS            Write(6,"(3(1x,ES21.13E3))") (Work1(IT000X+i),i=1,NINT)
CSSS             Write(6,*) 
C
C CALCULATE EXPECTATION VALUES 
C AND DENSITY CONTRIBUTIONS -  
C ELSE GATHER UNDIF. INTEGRALS 
C
             IF (PROPTY) THEN
CCH
C --- CALCULATE THE ECP-CONTRIBUTIONS FOR THE SHELL-COMBINATION 
C --- (ISHELA,ISHELB)                                          
CCH
              IF (IECP.EQ.1) THEN
                IFIRST=ISHELA
                ISECON=ISHELB              
                NCNTRA=NRCA
                NCNTRB=NRCB
C --- FIRST INIT THE ARRAYS
                N = KHKTA*KHKTB*NATOMC*MXCONT*MXCONT
                CALL ZERO(WORK1(I_DCRTOX),N*6)
cHACK           CALL ZERO(WORK1(I_DCRTOY),N)
cHACK           CALL ZERO(WORK1(I_DCRTOZ),N)
cHACK           CALL ZERO(WORK1(I_DCRTBX),N)
cHACK           CALL ZERO(WORK1(I_DCRTBY),N)
cHACK           CALL ZERO(WORK1(I_DCRTBZ),N)
                I_DTMP1X = ITOP3+1
                I_DTMP1Y = I_DTMP1X + N
                I_DTMP1Z = I_DTMP1Y + N
                I_DTMP2X = I_DTMP1Z + N
                I_DTMP2Y = I_DTMP2X + N
                I_DTMP2Z = I_DTMP2Y + N
                I_DTVHLF = I_DTMP2Z + N
                IF (I_DTVHLF.GT.LWORK1) THEN
                   print *, '@ONEDRV: Insufficient memory.'
                   print *, '         need ',I_DTVHLF,' dbls'
                   print *, '         have ',LWORK1,' dbls'
                   call errex
                END IF
                N_DTVHLF = LWORK1-I_DTVHLF+1
C --- THEN CALCULATE THE ECP CONTRIBUTIONS
CSSS                CALL ECPABL(IFIRST,ISECON,WORK1(I_DTVHLF),N_DTVHLF,
CSSS     &                  WORK1(I_DCRTOX),WORK1(I_DCRTOY),WORK1(I_DCRTOZ),
CSSS     &                  WORK1(I_DCRTBX),WORK1(I_DCRTBY),WORK1(I_DCRTBZ),
CSSS     &                  WORK1(I_DTMP1X),WORK1(I_DTMP1Y),WORK1(I_DTMP1Z),
CSSS     &                  WORK1(I_DTMP2X),WORK1(I_DTMP2Y),WORK1(I_DTMP2Z),
CSSS     &                  KHKTA,KHKTB,NATOMC,LDIAG,NCNTRA,NCNTRB,ISYMOP)
              ENDIF
CCH
C
C Expectation values of derivative one-electron Hamiltonian
C integrals and reorthonormalization contributions
C
              IF (ONECEN) THEN
C
C Nuclear attraction average value
C
               CALL AVENA1(KHKTA,KHKTB,IDENA,IDENB,ICENTA,NCENTA,
     &                     NATOMC,SECDER,LDIAG,WORK1,ENERNA,GRADNA,
     &                     HESSNA,NCOORD,
     &                  WORK1(I_DCRTOX),WORK1(I_DCRTOY),WORK1(I_DCRTOZ))
              ELSE
C
C Kinetic energy average value and reorthonormalization
C
               CALL AVEKFS(KHKTA,KHKTB,IDENA,IDENB,ICENTA,ICENTB,
     &                     NCENTA,NCENTB,SIGNBX,SIGNBY,SIGNBZ,
     &                     ISYMOP,SECDER,LDIAG,WORK1,ENERKE,
     &                     GRADKE,GRADFS,HESSKE,HESFS2,NCOORD)
C
C Nuclear attraction average value
C
               CALL AVENA2(KHKTA,KHKTB,IDENA,IDENB,ICENTA,ICENTB,
     &                     NCENTA,NCENTB,SIGNBX,SIGNBY,SIGNBZ,
     &                     NATOMC,ISYMOP,SECDER,LDIAG,WORK1,
     &                     ENERNA,GRADNA,HESSNA,NCOORD,
     &                  WORK1(I_DCRTOX),WORK1(I_DCRTOY),WORK1(I_DCRTOZ),
     &                  WORK1(I_DCRTBX),WORK1(I_DCRTBY),WORK1(I_DCRTBZ))
              END IF
C
             ENDIF
C
             IF(CCSDEH.OR.FOCK.AND.(.NOT.JFC).AND.(.NOT.JSD)) THEN
C
C Transform dipole integrals to symmetry basis
C
             FULMAT = .TRUE.
C
C x dipole
C
             IF (ISYTYP(1) .EQ. 0) THEN
            CALL SYM1S(WORK1(ID000X+1),WORK1(KDPXAO),ISYMOP,MULA,MULB,
     &                   NHKTA,NHKTB,KHKTA,KHKTB,-HKAB,LDIAG,LAEQB,
     &                       FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ELSE
            CALL SYM1N(WORK1(ID000X+1),WORK1(KDPXAO),ISYTYP(1),
     &                 ISYMOP,MULA,MULB,NHKTA,NHKTB,KHKTA,KHKTB,
     &                 -HKAB,LDIAG,LAEQB,FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ENDIF
C
C y dipole
C
             IF (ISYTYP(2) .EQ. 0) THEN
              CALL SYM1S(WORK1(ID000Y+1),WORK1(KDPYAO),
     &                   ISYMOP,MULA,MULB,NHKTA,NHKTB,KHKTA,
     &                   KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ELSE
              CALL SYM1N(WORK1(ID000Y+1),WORK1(KDPYAO),
     &                   ISYTYP(2),ISYMOP,MULA,MULB,NHKTA,
     &                   NHKTB,KHKTA,KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ENDIF
C
C z dipole
C
             IF (ISYTYP(3) .EQ. 0) THEN
              CALL SYM1S(WORK1(ID000Z+1),WORK1(KDPZAO),
     &                   ISYMOP,MULA,MULB,NHKTA,NHKTB,KHKTA,
     &                   KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ELSE
              CALL SYM1N(WORK1(ID000Z+1),WORK1(KDPZAO),
     &                   ISYTYP(3),ISYMOP,MULA,MULB,NHKTA,
     &                   NHKTB,KHKTA,KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ENDIF
C
             IF(CCSDEH) THEN
C
C xx quadrupole
C
              CALL SYM1S(WORK1(IQ00XX+1),WORK1(KQXXAO),
     &                   ISYMOP,MULA,MULB,NHKTA,NHKTB,KHKTA,
     &                   KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
C
C xy quadrupole
C
             IF (IXYPERT.EQ.1) THEN
              CALL SYM1S(WORK1(IQ00XY+1),WORK1(KQXYAO),
     &                   ISYMOP,MULA,MULB,NHKTA,NHKTB,KHKTA,
     &                   KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ELSE
              CALL SYM1N(WORK1(IQ00XY+1),WORK1(KQXYAO),
     &                   IXYPERT-1,ISYMOP,MULA,MULB,NHKTA,
     &                   NHKTB,KHKTA,KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ENDIF
C
C xz quadrupole
C
             IF (IXZPERT.EQ.1) THEN
              CALL SYM1S(WORK1(IQ00XZ+1),WORK1(KQXZAO),
     &                   ISYMOP,MULA,MULB,NHKTA,NHKTB,KHKTA,
     &                   KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ELSE
              CALL SYM1N(WORK1(IQ00XZ+1),WORK1(KQXZAO),
     &                   IXZPERT-1,ISYMOP,MULA,MULB,NHKTA,
     &                   NHKTB,KHKTA,KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ENDIF
C
C yy quadrupole
C
              CALL SYM1S(WORK1(IQ00YY+1),WORK1(KQYYAO),
     &                   ISYMOP,MULA,MULB,NHKTA,NHKTB,KHKTA,
     &                   KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
C
C yz quadrupole
C
             IF (IYZPERT.EQ.1) THEN
              CALL SYM1S(WORK1(IQ00YZ+1),WORK1(KQYZAO),
     &                   ISYMOP,MULA,MULB,NHKTA,NHKTB,KHKTA,
     &                   KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ELSE
              CALL SYM1N(WORK1(IQ00YZ+1),WORK1(KQYZAO),
     &                   IYZPERT-1,ISYMOP,MULA,MULB,NHKTA,
     &                   NHKTB,KHKTA,KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ENDIF
C
C zz quadrupole
C
              CALL SYM1S(WORK1(IQ00ZZ+1),WORK1(KQZZAO),
     &                   ISYMOP,MULA,MULB,NHKTA,NHKTB,KHKTA,
     &                   KHKTB,-HKAB,LDIAG,LAEQB,
     &                   FULMAT,DUM,IDUM,1,IPRINT,ONE)
             ENDIF

            ENDIF
C
            IF(PROPTY) THEN
C
C EXPECTATION VALUE OF DIPOLE MOMENT AND DIPOLE DERIVATIVES
C
             CALL DIPAVR(KHKTA,KHKTB,IDENA,IDENB,NCENTA,NCENTB,
     &                   ISYMOP,SIGNBX,SIGNBY,SIGNBZ,LDIAG,ONECEN,
     &                   DIFDIP,WORK1,DIPME,DDIPE,NCOORD)
C
C EXPECTATION VALUE OF QUADRUPOLE MOMENT
C
             CALL QUAAVR(KHKTA,KHKTB,IDENA,IDENB,NCENTA,NCENTB,
     &                   ISYMOP,SIGNBX,SIGNBY,SIGNBZ,LDIAG,ONECEN,
     &                   DIFQUA,WORK1,QUADME,DQUADE,NCOORD)
            ENDIF
C
C TRANSFORM INTEGRAL DERIVATIVES TO SO BASIS
C
            IF (FOCK.AND.(.NOT.JFC).AND.(.NOT.JSD)) THEN
C
C OVERLAP AND KINETIC ENERGY INTEGRALS
C
             IF (.NOT.ONECEN) THEN
              CALL DRSYM1(WORK1(IS000X+1),WORK1(IT000X+1),WORK1,
     &                    KSDAO,KFDAO,NCENTA,
     &                    NCENTB,ISYMOP,
     &                    MULA,MULB,NHKTA,NHKTB,KHKTA,KHKTB,HKAB,
     &                    LDIAG,LAEQB,THRS,IPRINT)
             END IF
C
C NUCLEAR ATTRACTION INTEGRALS
C
             DO 250 IATOMC = 1, NATOMC
               ISYMC  = JSYMC(IATOMC)
               ICENTC = JCENTC(IATOMC)
               CALL DASYM1(WORK1(IA000X+IATOMC),WORK1(IA0X00+IATOMC),
     &                     WORK1,KFDAO,NATOMC,ONECEN,
     &                     NCENTA,NCENTB,ICENTC,ISYMOP,ISYMC,
     &                     MULA,MULB,NHKTA,NHKTB,
     &                     KHKTA,KHKTB,HKAB,LDIAG,LAEQB,THRS,
     &                     IPRINT)
  250         CONTINUE
             ENDIF
C
             IF(JFC) THEN
C
C FC INTEGRALS 
C
              DO 251 IATOMC = 1, NATOMC
               ISYMC  = JSYMC(IATOMC)
               ICENTC = JCENTC(IATOMC)
               CALL DASYM2(WORK1(IS000X+IATOMC),
     &                     WORK1,KFDAO,NATOMC,
     &                     ICENTC,ISYMOP,ISYMC,
     &                     MULA,MULB,NHKTA,NHKTB,
     &                     KHKTA,KHKTB,HKAB,LDIAG,LAEQB,THRS,
     &                     IPRINT)
  251         CONTINUE

             ELSE IF(JSD) THEN
C
C SD INTEGRALS
C
              DO 252 IATOMC=1,NATOMC
               ISYMC=JSYMC(IATOMC)
               ICENTC=JCENTC(IATOMC)
               CALL DASYM4(WORK1(IS00XX+IATOMC),
     &                     WORK1,KFDAO,NATOMC,
     &                     ICENTC,ISYMOP,ISYMC,
     &                     MULA,MULB,NHKTA,NHKTB,
     &                     KHKTA,KHKTB,HKAB,LDIAG,LAEQB,THRS,
     &                     IPRINT)
252           CONTINUE
             ENDIF
C
  200       CONTINUE
C
C END LOOP OVER SYMMETRY OPERATIONS 
C
            IDENB0 = IDENB0 + KHKTB*MULTB*NRCB
110        CONTINUE
           IDENA = IDENA + KHKTA*MULTA*NRCA
100       CONTINUE
C
C  END LOOP OVER SYMMETRY INDEPENDENT ORBITALS 
C
            IF(CCSDEH) THEN
             IF(IDFGH) THEN
C
              CALL EXPCAR(IXPERT,1,WORK1(KDPXAO),
     &                    WORK1(KSTART),0)
              CALL EXPCAR(IYPERT,1,WORK1(KDPYAO),
     &                    WORK1(KSTART),0)
              CALL EXPCAR(IZPERT,1,WORK1(KDPZAO),
     &                    WORK1(KSTART),0)
              CALL EXPCAR(1,1,WORK1(KQXXAO),
     &                    WORK1(KSTART),0)
              CALL EXPCAR(IXYPERT,1,WORK1(KQXYAO),
     &                    WORK1(KSTART),0)
              CALL EXPCAR(IXZPERT,1,WORK1(KQXZAO),
     &                    WORK1(KSTART),0)
              CALL EXPCAR(1,1,WORK1(KQYYAO),
     &                    WORK1(KSTART),0)
              CALL EXPCAR(IYZPERT,1,WORK1(KQYZAO),
     &                    WORK1(KSTART),0)
              CALL EXPCAR(1,1,WORK1(KQZZAO),
     &                    WORK1(KSTART),0)
             ENDIF
C
             CALL PUTREC(20,'JOBARC','DIPOLE_X',
     &                   NLENT(IXPERT)*IINTFP,WORK1(KDPXAO))
             CALL PUTREC(20,'JOBARC','DIPOLE_Y',
     &                   NLENT(IYPERT)*IINTFP,WORK1(KDPYAO))
             CALL PUTREC(20,'JOBARC','DIPOLE_Z',
     &                   NLENT(IZPERT)*IINTFP,WORK1(KDPZAO))
             CALL PUTREC(20,'JOBARC','2NDMO_XX',
     &                   NLENT(1)*IINTFP,WORK1(KQXXAO))
             CALL PUTREC(20,'JOBARC','2NDMO_XY',
     &                   NLENT(IXYPERT)*IINTFP,WORK1(KQXYAO))
             CALL PUTREC(20,'JOBARC','2NDMO_XZ',
     &                   NLENT(IXZPERT)*IINTFP,WORK1(KQXZAO))
             CALL PUTREC(20,'JOBARC','2NDMO_YY',
     &                   NLENT(1)*IINTFP,WORK1(KQYYAO))
             CALL PUTREC(20,'JOBARC','2NDMO_YZ',
     &                   NLENT(IYZPERT)*IINTFP,WORK1(KQYZAO))
             CALL PUTREC(20,'JOBARC','2NDMO_ZZ',
     &                   NLENT(1)*IINTFP,WORK1(KQZZAO))

            ENDIF
            IF (FOCK.AND.(.NOT.JFC).AND.(.NOT.JSD)) THEN
C
             NSYM=MAXLOP+1
C
C  WRITE OVERLAP DERIVATIVE INTEGRALS TO GAMLAM
C
c              CALL GFNAME('GAMLAM  ',FNAME,ILENGTH)
c              INQUIRE(FILE=FNAME(1:ILENGTH),EXIST=YESNO)
c              IF(YESNO) THEN
               IENTER=0
               IOFF=0
c              ELSE
c               IENTER=1
c               IOFF=-1
c              ENDIF
              IF(.NOT.ELECT) THEN
C
              DO 1890 IRREP=1,MAXLOP+1
              IF (NLENT(IRREP) .NE. 0) THEN
C
C ELIMINATE TRANSLATIONAL REDUNDANT COORDINATES
C                
              MPERT=NPERT(IRREP)
              IF(TRAINV) THEN
               JTRANSY=ITRANSY
               JTRANSZ=ITRANSZ
               IF(IXPERT.EQ.IRREP) THEN
                MPERT=MPERT-1
                CALL REDUCE(WORK1(KSDAO(IRREP,1)),NLENT(IRREP),
     &                      ITRANSX,MPERT+1)
                IF(IXPERT.EQ.IYPERT.AND.ITRANSY.GT.ITRANSX)
     &            JTRANSY=JTRANSY-1 
                IF(IXPERT.EQ.IZPERT.AND.ITRANSZ.GT.ITRANSX)
     &            JTRANSZ=JTRANSZ-1 
               ENDIF
               IF(IYPERT.EQ.IRREP) THEN
                MPERT=MPERT-1
                CALL REDUCE(WORK1(KSDAO(IRREP,1)),NLENT(IRREP),
     &                      JTRANSY,MPERT+1)
                IF(IYPERT.EQ.IZPERT.AND.ITRANSZ.GT.ITRANSY)
     &            JTRANSZ=JTRANSZ-1 
               ENDIF
               IF(IZPERT.EQ.IRREP) THEN
                MPERT=MPERT-1
                CALL REDUCE(WORK1(KSDAO(IRREP,1)),NLENT(IRREP),
     &                      JTRANSZ,MPERT+1)
               ENDIF
C
              ENDIF
              ENDIF !Endif for (NLENT(IRREP) .NE. 0)
C
              CALL UPDMOI(MPERT,NLENT5(IRREP),IRREP,101,IENTER,
     &                    IOFF)
              IENTER=0
              IOFF=0
C
              IF(IDFGH) THEN
C
               CALL EXPCAR(IRREP,MPERT,WORK1(KSDAO(IRREP,1)),     
     &                     WORK1(KSTART),0)
C
              ENDIF
C
              CALL PUTLST(WORK1(KSDAO(IRREP,1)),1,MPERT,1,
     &                    IRREP,101)
1890          CONTINUE
C
C WRITE ONE-ELECTRON HAMILTON DERIVATIVES TO GAMLAM
C
        DO 1900 IRREP=1,MAXLOP+1
              IF (NLENT(IRREP) .NE. 0) THEN
C
C ELIMINATE TRANSLATIONAL REDUNDANT COORDINATES
C                
              MPERT=NPERT(IRREP)
              IF(TRAINV) THEN
               JTRANSY=ITRANSY
               JTRANSZ=ITRANSZ
               IF(IXPERT.EQ.IRREP) THEN
                MPERT=MPERT-1
                CALL REDUCE(WORK1(KFDAO(IRREP)),NLENT(IRREP),
     &                      ITRANSX,MPERT+1)
                IF(IXPERT.EQ.IYPERT.AND.ITRANSY.GT.ITRANSX)
     &            JTRANSY=JTRANSY-1 
                IF(IXPERT.EQ.IZPERT.AND.ITRANSZ.GT.ITRANSX)
     &            JTRANSZ=JTRANSZ-1 
               ENDIF
               IF(IYPERT.EQ.IRREP) THEN
                MPERT=MPERT-1
                CALL REDUCE(WORK1(KFDAO(IRREP)),NLENT(IRREP),
     &                     JTRANSY,MPERT+1)
                IF(IYPERT.EQ.IZPERT.AND.ITRANSZ.GT.ITRANSY)
     &            JTRANSZ=JTRANSZ-1 
               ENDIF
               IF(IZPERT.EQ.IRREP) THEN
                MPERT=MPERT-1
                CALL REDUCE(WORK1(KFDAO(IRREP)),NLENT(IRREP),
     &                      JTRANSZ,MPERT+1)
               ENDIF
C
              ENDIF
              ENDIF !Endif for (NPERT(IRREP) .NE. 0)
C
C
C ALPHA FOCK MATRIX DERIVATIVES
C
         CALL UPDMOI(MPERT,NLENT5(IRREP),IRREP,102,IENTER,
     &               IOFF)

C This is for Marcel's work on Vibronic models. Save the 
C one Hamiltonian derivatives on list 108. 
         CALL UPDMOI(MPERT,NLENT5(IRREP),IRREP,108,IENTER,
     &               IOFF)
         IF(.NOT.SCF) THEN
C
C ALPHA D(RELAX) * d I/d chi
C
          CALL UPDMOI(MPERT,NLENT5(IRREP),IRREP,105,IENTER,
     &                IOFF)
         ENDIF
C
         IF(IUHF.NE.0) THEN
C
C BETA FOCK MATRIX DERIVATIVES
C
          CALL UPDMOI(MPERT,NLENT5(IRREP),IRREP,103,IENTER,
     &                IOFF)
          IF(.NOT.SCF) THEN
C
C BETA D(RELAX) * d I/ d chi
C
           CALL UPDMOI(MPERT,NLENT5(IRREP),IRREP,106,IENTER,
     &                 IOFF)
          ENDIF
         ENDIF
         IF(IDFGH) THEN
C
          CALL EXPCAR(IRREP,MPERT,WORK1(KFDAO(IRREP)),     
     &                WORK1(KSTART),0)
C
         ENDIF
C
         CALL PUTLST(WORK1(KFDAO(IRREP)),1,MPERT,1,IRREP,102)
C See the above comment. 
         CALL PUTLST(WORK1(KFDAO(IRREP)),1,MPERT,1,IRREP,108)
1900    CONTINUE    
C
        ENDIF
C
C  WRITE DIPOLE INTEGRALS TO GAMLAM 
C
       IF(DIFDIP.OR.FOCK)THEN
C
        CALL UPDMOI(1,NLENT5(IXPERT),1,104,IENTER,IOFF)
C
        IENTER=0
        IOFF=0
C
        CALL UPDMOI(1,NLENT5(IYPERT),2,104,IENTER,IOFF)
        CALL UPDMOI(1,NLENT5(IZPERT),3,104,IENTER,IOFF)
C
        IF(IDFGH) THEN
C
         CALL EXPCAR(IXPERT,1,WORK1(KDPXAO),     
     &               WORK1(KSTART),0)
         CALL EXPCAR(IYPERT,1,WORK1(KDPYAO),     
     &               WORK1(KSTART),0)
         CALL EXPCAR(IZPERT,1,WORK1(KDPZAO),     
     &               WORK1(KSTART),0)
C
        ENDIF
C
        CALL PUTLST(WORK1(KDPXAO),1,1,1,1,104)
        CALL PUTLST(WORK1(KDPYAO),1,1,1,2,104)
        CALL PUTLST(WORK1(KDPZAO),1,1,1,3,104)
C
       END IF
C
      END IF
C
C WRITE FC OR SD INTEGRALS TO GAMLAM
C
      IF(JFC.OR.JSD) THEN
C
c       CALL GFNAME('GAMLAM  ',FNAME,ILENGTH)
c       INQUIRE(FILE=FNAME(1:ILENGTH),EXIST=YESNO)
c       IF(YESNO) THEN
        IENTER=0
        IOFF=0
c       ELSE
c        IENTER=1
c        IOFF=-1
c       ENDIF   
C
       DO 1901 IRREP=1,MAXLOP+1
C
        MPERT=NPERT(IRREP)
        IF(MPERT.NE.0) THEN
C
         CALL UPDMOI(MPERT,NLENT5(IRREP),IRREP,102,IENTER,
     &               IOFF)
C
         IENTER=0
         IOFF=0
C
         IF(IDFGH) THEN
C
          CALL EXPCAR(IRREP,MPERT,WORK1(KFDAO(IRREP)),     
     &                WORK1(KSTART),0)
C
         ENDIF
C
c          do 1234 i=1,mpert
c           call pritri(work1(kfdao(irrep)+(i-1)*nlent5(irrep)),
c     &                 nbasis,'fc')
c1234      continue
         CALL PUTLST(WORK1(KFDAO(IRREP)),1,MPERT,1,IRREP,102)
C
        ENDIF
1901   CONTINUE
C
      ENDIF
C
C Add the Direct ECP gradinets to Nuclear Attration gradinets.
C
      If (Iecp .EQ. 1) Then
         Do Ixyz = 1, Ncoord
            Gradna(Ixyz) = Gradna(Ixyz) + ECP_grad(Ixyz)
          Enddo
      Endif 
C
C  SYMMETRIZE HESSIANS
C
      IF(PROPTY.AND.SECDER) THEN
       DO 500 I=1,NCOORD
        DO 510 J=1,I
         IF(I.NE.J) THEN
          HESSKE(I,J)=HESSKE(I,J)+HESSKE(J,I)
          HESSNA(I,J)=HESSNA(I,J)+HESSNA(J,I)
          HESFS2(I,J)=HESFS2(I,J)+HESFS2(J,I)
         END IF
         HESSKE(J,I)=HESSKE(I,J)
         HESSNA(J,I)=HESSNA(I,J)
         HESFS2(J,I)=HESFS2(I,J)
510     CONTINUE
500    CONTINUE
      ENDIF
C
C  PRINT SECTION 
C
      IF (PROPTY .AND. (IPRINT .GT. 0)) THEN
       IF(.NOT.ELECT) THEN
        CALL HEADER('Kinetic energy integral gradient',-1)
        CALL PRIGRD(GRADKE,0)
        If (Iecp .EQ. 1) Then
            CALL HEADER('ECP Nuclear attraction integral gradient',-1)
        Else
            CALL HEADER('Nuclear attraction integral gradient',-1)
        Endif
        CALL PRIGRD(GRADNA,0)
        CALL HEADER('Reorthonormalization gradient',-1)
        CALL PRIGRD(GRADFS,0)
        IF (SECDER) THEN
         CALL HEADER('Kinetic energy integral Hessian',-1)
         CALL PRIHES(HESSKE,NCOORD,'CENTERS',0)
         CALL HEADER('Nuclear attraction integral Hessian',-1)
         CALL PRIHES(HESSNA,NCOORD,'CENTERS',0)
         CALL HEADER('Highest order reorthonormalization Hessian',-1)
         CALL PRIHES(HESFS2,NCOORD,'CENTERS',0)
        ENDIF
       ENDIF
       CALL HEADER('Electronic contributions to dipole moment',-1)
       CALL DP0PRI(DIPME)
       CALL HEADER('Electronic contributions to quadrupole moment',
     &             -1)
       CALL QU0PRI(QUADME)
       IF (DIFDIP.AND.(.NOT.ELECT)) THEN
        CALL HEADER('Electronic contributions to static part'//
     &              ' of dipole moment derivatives',-1)
        CALL DP1PRI(DDIPE,NCOORD,'CENTERS',0)
       ENDIF
      ENDIF
C
      IF(JFC.OR.JSD) THEN
       DO 8001 INUC=1,NUCIND
        MULTAT(INUC)=MULT(ISTBNU(INUC))
8001   CONTINUE
       CALL PUTREC(20,'JOBARC','NINDATOM',1,NUCIND)
       CALL PUTREC(20,'JOBARC','MULTATOM',NUCIND,MULTAT)
       CALL PUTREC(20,'JOBARC','NAMCOORD',IINTFP*3*NUCIND,NAMEX)
      ENDIF
C
      RETURN
      END
