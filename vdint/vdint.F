
C PROGRAM FOR CALCULATING FIRST AND SECOND INTEGRAL DERIVATIVES
C WITH RESPECT TO ELECTRIC, MAGNETIC, OR GEOMETRIC PERTURBATIONS.
C THIS PROGRAM IS BASED ON SYMMETRY ADAPTED BASIS FUNCTIONS AND
C ESPECIALLY DESIGNED FOR CC/MBPT CALCULATIONS.
C
C THE CURRENT VERSION OF VDINT IS BASED ON THE ABACUS PROGRAM 
C WRITTEN BY T. HELGAKER, P. JOERGENSEN, H. AA. JENSEN, AND
C P.R. TAYLOR, BUT VDINT HAS BEEN SIGNIFICANTLY REWRITTEN 
C DURING THE LAST YEAR AT THE UNIVERSITY OF FLORIDA AND
C UNIVERSITY OF KARLSRUHE.
C
C  UNIVERSITY OF KARLSRUHE,  AUGUST 91    J. GAUSS, J.F. STANTON

      PROGRAM VDINT
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
#include "mxcent.par"
#include "lwork.par"
#include "flags.h"
#include "jodaflags.com"
C
      LOGICAL ELECT,MAGNET,GEOM,GRAD,INTWRIT,FOCK,SCF,NONHF
      LOGICAL MAGNET2,GIAO,HFDFT_GRAD
      LOGICAL MOLGRD,MOLHES,DIPDER,POLAR,INPTES,
     &        VIB,RESTAR,DOWALK,GDALL,FOCK1,H2MO
      LOGICAL PROPTY
      LOGICAL IFIRST,IALL,XCOMP,YCOMP,ZCOMP
      LOGICAL MVDINT1,MVDINT2
      LOGICAL JSO,JFC,JSD,CCSDEH
      LOGICAL EXTRAPOLATE
C
      COMMON /ABAINF/ IPRDEF,MOLGRD,MOLHES,DIPDER,POLAR,INPTES,
     &                VIB,RESTAR,DOWALK,GDALL,FOCK1,H2MO
      COMMON /CWORK2/ WK2LOW, WORK2(LWORK2), WK2HGH
      COMMON /CWORK3/ WK3LOW, WORK3(LWORK3), WK3HGH
      COMMON/BASSYM/NBAS(8),NBASIS,NBASSQ,NBASTT
      COMMON//ICORE(1) 
      COMMON/ISTART/I0,ICRSIZ
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/PROP/ELECT,MAGNET,GEOM,MAGNET2,GIAO
      COMMON/OPTION/GRAD,INTWRIT,FOCK
      COMMON/METHOD/IUHF,SCF,NONHF
      COMMON/MVDINT/MVDINT1,MVDINT2
      COMMON/IPRI/IPRINT
      COMMON/TREATP/IFIRST,IALL,XCOMP,YCOMP,ZCOMP,IBF,IBL
      COMMON/SYMLOC/ISYMOFF(8,8,25)
      COMMON/JNMR/JSO,JFC,JSD
      COMMON/EH/CCSDEH
      COMMON /ECP/ IECP
C
      iPRINT=0
C  
C   INITIALIZE PROGRAM IN THE CRAPS ENVIRONMENT
C
      CALL CRAPSI(ICORE,IUHF,-1)

c   o ABACUS causes some memory problems when requiring the full core;
c     therefore, we reduce the requested core size by a constant amount
c     making sure that a minimum is always allocated.
c     (This is set to run efficiently in the 8MW queue of a YMP.)
      MAXCOR = IFLAGS(36)
      iTmp   = min(3500000,MAXCOR)
      MAXCOR = max(iTmp,MAXCOR-3000000)
      call aces_malloc(MAXCOR,ICORE,I0)
      if (icore(1).eq.0) then
         print *, '@VDINT: Request for ',MAXCOR,' integers of core ',
     &            'memory failed.'
         call aces_exit(1)
      end if
      call aces_io_init(ICORE,I0,MAXCOR,.TRUE.)
C
C  SET MAXCOR IN FLOATING POINT WORDS
C
      MAXCOR=MAXCOR/IINTFP
C
C   FILL COMMON BLOCK METHOD
C
      CALL SETMET
C
C     INPUT FOR ABACUS
C
      CALL ABAINP(ICORE(I0),MAXCOR,NUCIND)
C
C   FILL COMMON BLOCK BASSYM
C
      CALL SETBAS
C
C DETERMINE THE NUMBER OF PERTURBATIONS WITHIN 
C EACH IRREP
C NCOORD IS THE TOTAL NUMBER OF PERTURBATIONS
C
      CALL DETPERT(ICORE(I0),NUCIND,NCOORD)
C
C ALLOCATE CORE MEMORY
C
      IF(GEOM.OR.ELECT) THEN
C
C CORE MEMORY FOR ENERGY
C    
       IEM=I0
C
C CORE MEMORY FOR GRADIENT, DIPOLE AND QUADRUPOLE MOMENTS
C
       IGM=IEM+IINTFP
       ID0=IGM+IINTFP*NCOORD
       IQ0=ID0+IINTFP*3
       IHM=IQ0+IINTFP*6
       ISTART=IHM  
C
C  CORE MEMORY FOR DIPOLE DERIVATIVES AND FORCE CONSTANTS
C
       IF(MOLHES) ISTART=IHM+NCOORD*NCOORD*IINTFP
       IF(DIPDER) THEN
        IDD=ISTART
        ISTART=IDD+3*NCOORD*IINTFP
       ENDIF
C
C CORE MEMORY FOR THE VARIOUS CONTRIBUTIONS TO THE ENERGY
C
       IEKE=ISTART
       IENA=IEKE+IINTFP
       IEEE=IENA+IINTFP
       IENN=IEEE+IINTFP
C
C CORE MEMORY FOR THE VARIOUS CONTRIBUTIONS TO FIRST DERIVATIVES
C
       IGKE=IENN+IINTFP
       IGNA=IGKE+IINTFP*NCOORD
C
C Store the SCF grads for post-HF rate constant work.
C (see intexp for further comments)
C
       ISCF_GEE=IGNA+IINTFP*NCOORD
C
       IGEE=ISCF_GEE+IINTFP*NCOORD
       IGNN=IGEE+IINTFP*NCOORD
       IGFS=IGNN+IINTFP*NCOORD
       IDME=IGFS+IINTFP*NCOORD
       IDMN=IDME+IINTFP*3
       IQME=IDMN+3*IINTFP
       IQMN=IQME+6*IINTFP
       ICSCF_GRAD=IQMN+6*IINTFP
       ISTART= ICSCF_GRAD + NCOORD*IINTFP
C
C CORE MEMORY FOR THE VARIOUS CONTRIBUTIONS TO SECOND DERIVATIVES
C
       IF(MOLHES .OR. GRAD) THEN
        IHKE=ISTART
        IHNA=IHKE+NCOORD*NCOORD*IINTFP
C
C Store the SCF Hessian for post-HF rate constant work (for future use).
C (see intexp for further comments)
C
        ISCF_HEE=IHNA+NCOORD*NCOORD*IINTFP
C
        IHEE=ISCF_HEE+NCOORD*NCOORD*IINTFP
        IHNN=IHEE+NCOORD*NCOORD*IINTFP
        IHFS2=IHNN+NCOORD*NCOORD*IINTFP
        ISTART=IHFS2+NCOORD*NCOORD*IINTFP
       ENDIF
       IF(DIPDER) THEN
        IDDN=ISTART
        IDDE=IDDN+IINTFP*3*NCOORD
        IDQN=IDDE+IINTFP*3*NCOORD
        IDQE=IDQN+IINTFP*6*NCOORD
        ISTART=IDQE+IINTFP*6*NCOORD
       ENDIF
C
C EVALUATE THE NUCLEAR REPULSION PART
C
       IF((.NOT.ELECT).AND.GRAD) THEN
        CALL NUCREP(ICORE(IENN),ICORE(IGNN),ICORE(IHNN),NCOORD)
       ENDIF
C
      ELSE IF(MAGNET) THEN
C
C CORE MEMORY FOR MAGNETIC SUSZEPTIBILTIES
C
       IHM=I0
       ID0=IHM+9*IINTFP
       ISTART=ID0+9*NCOORD*IINTFP
C
C CORE MEMORY FOR VARIOUS CONTRIBUTIONS TO MAGNETIC PROPERTIES
C   
       IHKE=ISTART
       ISTART=IHKE+IINTFP*9
C
C CORE MEMORY FOR NMR SHIFTS
C
       IDME=ISTART
       IDMN=IDME+IINTFP*3*NCOORD
       ISTART=IDMN+IINTFP*3*NCOORD
       IF(JSO) THEN
        IHNA=ISTART
        ISTART=IHNA+3*NCOORD*IINTFP
       ENDIF
      ENDIF
C
C ONE-ELECTRON EXPECTATION VALUES AND INTEGRALS
C
      PROPTY=GRAD
      IF(JFC.OR.JSD) THEN
       PROPTY=.FALSE.
       ISTART=I0
      ENDIF
      MAXCOR=MAXCOR-(ISTART-I0)/IINTFP
      CALL ONEINT(PROPTY,ICORE(ISTART),MAXCOR,ICORE(IEKE),
     &            ICORE(IGKE),ICORE(IHKE),ICORE(IENA),
     &            ICORE(IGNA),ICORE(IHNA),ICORE(IGFS),
     &            ICORE(IHFS2),ICORE(IDME),ICORE(IDMN),
     &            ICORE(IDDE),ICORE(IDDN),
     &            ICORE(IQME),ICORE(IDQE),ICORE(IQMN),
     &            ICORE(IDQN),NCOORD,.FALSE.)
C
      CALL TIMER(1)
      IF(.NOT.MAGNET.OR.IFIRST) THEN

       WRITE(*,1000) TONE
1000   FORMAT('  Evaluation of 1e integral derivatives required',
     &         F8.2,' seconds.')
      ENDIF
CSSS      GO to 10
C
C TWO-ELECTRON EXPECTATION VALUES AND INTEGRALS
C
      IF((.NOT.CCSDEH).AND. .NOT. ELECT .AND.
     &   (.NOT.JSO).AND.(.NOT.JFC).AND.(.NOT.JSD)) THEN
       IF(.NOT.MAGNET.OR.GIAO) THEN
C 
C TWOEXP IS NOT CALLED FOR ELECTRIC PROPERTIES ONLY, AND FOR CONVENTIONAL
C CALCULATIONS OF MAGNETIC PROPERTIES USING FIELD-INDEPENDENT BASIS 
C FUNCTIONS. TWOEXP IS ALSO NOT CALLED FOR J(FC) AND J(SD) CONTRIBUTIONS.
C
        CALL TWOEXP(ICORE(ISTART),MAXCOR,ICORE(IEEE),
     &              ICORE(ISCF_GEE),ICORE(IGEE),ICORE(ISCF_HEE),
     &              ICORE(IHEE),ICORE(IHKE),NCOORD)
C
        CALL TIMER(1)
c        TTWO=TTWO-TONE 
cmn        WRITE(*,2000) TTWO
2000    FORMAT('  Evaluation of 2e integral derivatives required',
     &         F8.2,' seconds.')
C
       ENDIF
      ENDIF
C
C ADD ALL CALCULATED CONTRIBUTIONS
C
C MOLECULAR GRADIENT
C     
CSSS 10   CONTINUE     
      IF(GRAD) THEN
      IF(.NOT.CCSDEH.AND. .NOT. ELECT .AND.          
     &    .NOT.MAGNET.AND..NOT.JFC.AND..NOT.JSD) THEN
      IF (MOLGRD) THEN
       CALL ZERO(ICORE(IGM),NCOORD)
C
#ifdef _DEBUG_LVLM
          Write(6,"(a)")  "WARNING: The Debug printing is turned on!"
          Write(6,"(a)")  "WARNING: Only suited for debugging by "
          Write(6,"(a)")  "Developers."
          CALL HEADER('Nuclear attraction energy gradient',-1)
          CALL PRIGRD(ICORE(IGNA),0) 
          CALL HEADER('Two electron energy gradient',-1)
          CALL PRIGRD(ICORE(IGEE),0) 
          CALL HEADER('Nuclear repulsion energy gradient',-1)
          CALL PRIGRD(ICORE(IGNN),0) 
          CALL HEADER('Kinetic energy energy gradient',-1)
          CALL PRIGRD(ICORE(IGKE),0) 
          CALL HEADER('Renormalization energy gradient',-1)
          CALL PRIGRD(ICORE(IGFS),0) 
#endif       
       CALL ADDGRD(ICORE(IGNA),ICORE(IGM),NCOORD)
       CALL ADDGRD(ICORE(IGNN),ICORE(IGM),NCOORD)
       CALL ADDGRD(ICORE(IGKE),ICORE(IGM),NCOORD)
       CALL ADDGRD(ICORE(IGFS),ICORE(IGM), NCOORD)

#ifdef _DEBUG_LVLM
       CALL HEADER('One elctron Molecular energy gradient',-1)
       CALL PRIGRD(ICORE(IGM),1)
#endif

       CALL ADDGRD(ICORE(IGEE),ICORE(IGM),NCOORD)
C
       CALL HEADER('Symmetry unique center gradients',-1)
       CALL PRIGRD(ICORE(IGM),1)
C
C In the case of HF-DFT gradients this contribution is already 
C computed in DFT gradient code. The HF-DFT is invoked when
C SCF_TYPE=KS and exchange is Hartree-Fock. Ajith Perera, 02/2008.

CSSS       CALL GETREC(0, "JOBARC", "EXCHANGE", Length, Itmp)
CSSS       HFDFT_GRAD = (IFLAGS2(h_IFLAGS2_scf_type) .EQ. 1 .AND. 
CSSS     &               LENGTH .GT. 0)
CSSS       IF (.NOT. HFDFT_GRAD) CALL ADDGRD(ICORE(IGFS),ICORE(IGM),
CSSS     &                                   NCOORD)
C Moved above to improve the readablityAjith Perera, 10/2010 
CSSS       CALL ADDGRD(ICORE(IGFS),ICORE(IGM), NCOORD)
CSSS       CALL PRIGRD(ICORE(IGM),1)
C
       GRDNRM=SDOT(NCOORD,ICORE(IGM),1,ICORE(IGM),1)
       GRDNRM=SQRT(GRDNRM)
       IF(IPRINT.NE.0) WRITE(6,3000) GRDNRM
3000   FORMAT('  ','Molecular gradient norm',E10.3)
C
       EXTRAPOLATE = (iflags2(h_IFLAGS2_extrap) .Gt. 0)
       IPRINT = 0
       IF (EXTRAPOLATE .AND. (.NOT.SCF .AND. IECP.EQ.0)) THEN
C
C Complete the formation of SCF gradients (for correlated calculations)
C and write it directly to the JOBARC file.
C
          CALL ONEINT(PROPTY,ICORE(ISTART),MAXCOR,ICORE(IEKE),
     &                ICORE(IGKE),ICORE(IHKE),ICORE(IENA),
     &                ICORE(IGNA),ICORE(IHNA),ICORE(IGFS),
     &                ICORE(IHFS2),ICORE(IDME),ICORE(IDMN),
     &                ICORE(IDDE),ICORE(IDDN),
     &                ICORE(IQME),ICORE(IDQE),ICORE(IQMN),
     &                ICORE(IDQN),NCOORD,.TRUE.)
          CALL ZERO(ICORE(IGM),NCOORD)
          CALL ADDGRD(ICORE(IGNA),ICORE(IGM),NCOORD)
          CALL ADDGRD(ICORE(ISCF_GEE),ICORE(IGM),NCOORD)
          CALL ADDGRD(ICORE(IGNN),ICORE(IGM),NCOORD)
          CALL ADDGRD(ICORE(IGKE),ICORE(IGM),NCOORD)
          CALL ADDGRD(ICORE(IGFS),ICORE(IGM),NCOORD)
          CALL TRAGRD(ICORE(IGM), ICORE(ICSCF_GRAD), NCOORD)
          CALL PUTREC(20,"JOBARC","SCF_GRAD",NCOORD*IINTFP,
     &                ICORE(ICSCF_GRAD))
       END IF
C
      END IF
C
C MOLECULAR HESSIAN
C
      IF (MOLHES) THEN
       CALL ZERO(ICORE(IHM),NCOORD*NCOORD)
       IF(IPRINT.NE.0) 
     &  CALL HEADER('Potential energy (NN + NE + EE) Hessian',-1)
       CALL ADDHES(ICORE(IHNN),ICORE(IHM),NCOORD)
       CALL ADDHES(ICORE(IHEE),ICORE(IHM),NCOORD)
       CALL ADDHES(ICORE(IHNA),ICORE(IHM),NCOORD)
       ISAVE=0
       IF(IPRINT.NE.0) CALL PRIHES(ICORE(IHM),NCOORD,'CENTERS',ISAVE)
CSSS       CALL HEADER('Molecular hessian',-1)
       CALL ADDHES(ICORE(IHKE),ICORE(IHM),NCOORD)
       CALL ADDHES(ICORE(IHFS2),ICORE(IHM),NCOORD)
       ISAVE=1
C       IF(.NOT.SCF) ISAVE=2
       CALL PRIHES(ICORE(IHM),NCOORD,'CENTERS',ISAVE)
      ENDIF
      ENDIF
C
C DIPOLE MOMENT 
C
      IF(.NOT.MAGNET.AND..NOT.JFC.AND..NOT.JSD) THEN
       CALL DP0SUM(ICORE(IDMN),ICORE(IDME),ICORE(ID0))
       CALL QU0SUM(ICORE(IQMN),ICORE(IQME),ICORE(IQ0))
C
C DIPOLE GRADIENT
C
       IF(.NOT.ELECT) THEN
        IF (DIPDER) THEN
         CALL ZERO(ICORE(IDD),3*NCOORD)
         CALL DIPADD(ICORE(IDDN),ICORE(IDD),NCOORD)
         CALL DIPADD(ICORE(IDDE),ICORE(IDD),NCOORD)
         ISAVE=1
C        IF(.NOT.SCF) ISAVE=2
         CALL DP1PRI(ICORE(IDD),NCOORD,'CENTERS',ISAVE)
        END IF
C
C TRA/ROT SYMMETRY
C
        NUCDEP=NCOORD/3
        IX=IGNN
        IY=IX+NUCDEP*IINTFP 
        IZ=IY+NUCDEP*IINTFP
        CALL TRRTIV(ICORE(IGM),ICORE(IX),ICORE(IY),ICORE(IZ),NUCDEP)
C
       ENDIF
      ENDIF
      ENDIF
C
C END OF THE CALCULATION
C
      call aces_fin
      STOP 
      END
