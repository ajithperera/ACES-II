      SUBROUTINE RCC_Q2AA(T,W,Z,T1A,TAU,ISPIN,POP,VRT,NOCCSQ,
     &                     NOCC2SQ,DISSYW,DISSYT,NUMSYW,NUMSYT,
     &                     IRREP,TMP,FACT)

      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL TAU,ADC2
      LOGICAL MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC,
     &            CC2,RCCD,DRCCD
      INTEGER DISSYT,DISSYW,DIRPRD,POP,VRT
      DIMENSION W(DISSYW,NOCC2SQ),T(DISSYT,NOCC2SQ),Z(NOCCSQ)
      DIMENSION TMP(1)
      DIMENSION POP(8),VRT(8),T1A(1)
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
      COMMON /FLAGS/  IFLAGS(100)
      COMMON /FLAGS2/ IFLAGS2(500)
      COMMON/METH/MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC,
     &            CC2,RCCD,DRCCD
      DATA ONEM,ONE,HALF,TWO /-1.0D0,1.D0,0.5D0,2.D0/
C
      IND(I,J)=((I-2)*(I-1))/2+J

      IF (DRCCD) THEN
         CALL GETLST(W,1,NUMSYW,2,IRREP,ISPIN)
      ELSE IF (RCCD) THEN
         CALL GETLST(W,1,NUMSYW,2,IRREP,ISPIN+2)
#ifdef _DEBUG_LVLM
         call checksum("w->fij",w,NUMSYW*DISSYW)
#endif 
      ENDIF
      CALL GETLST(T,1,NUMSYT,1,IRREP,ISPIN+43)

         JOFF=1
         IOFF=1
         DO 90 IRREPJ=1,NIRREP
C          
C        GET OCCUPATION NUMBER FOR JRREP     
C
           NOCCJ=POP(IRREPJ)
C
C
C        IF ZERO, NOTHING TO COMPUTE
C
           IF(NOCCJ.EQ.0) GO TO 90
C
C        DETERMINE IRREPI WHOSE DIRECT PRODUCT WITH JRREP GIVES IRREP
C
           IRREPI=DIRPRD(IRREP,IRREPJ)
C
C        GET OCCUPATION NUMBER FOR IRREPI
C
           NOCCI=POP(IRREPI)
C
C        IF ZERO, NOTHING TO COMPUTE
C
           IF(NOCCI.EQ.0) GO TO 80
C
            CALL XGEMM('T','N',NOCCJ,NOCCJ,DISSYW*NOCCI,FACT,
     &                 W(1,JOFF),NOCCI*DISSYW,T(1,JOFF),      
     &                 NOCCI*DISSYW,ONE,Z(IOFF),NOCCJ)
C
           JOFF=JOFF+NOCCJ*NOCCI 

80         CONTINUE
C
C         UPDATE THE OFFSET FOR THE INTERMEDIATE Z
C
            IOFF=IOFF+POP(IRREPJ)**2
90        CONTINUE
C
      RETURN
      END
