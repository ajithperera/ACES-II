       SUBROUTINE Rcc_fij(ICORE,MAXCOR,IUHF,FACT)
C
C      ARGUMENTS IN SUBROUTINE CALL : ICORE,MAXCOR,IUHF
C
C THIS PROGRAM COMPUTES :
C
C             1/2 SUM N SUM E,F   <MN//EF> T(IN,EF)
C
C THE MULTIPLICATION IS CARRIED OUT USING SYMMETRY
C AND THE RESULTING PRODUCT ARRAY IS STORED IN A 
C SYMMETRY ADAPTED WAY
C
CEND
C
C THE SPIN ADAPTED CODE FOR RHF HAS BEEN ADDED IN AUGUST 90  JG
C
C CODED JG JUNE/90
C 
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DIRPRD,DISSYW,DISSYT,POP,VRT
      LOGICAL TAU
      LOGICAL MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC,
     &        CC2,RCCD,DRCCD
      DIMENSION ICORE(MAXCOR)
      COMMON /SYM/ POP(8,2),VRT(8,2),NTAA,NTBB,NF1AA,NF1BB,NF2AA,NF2BB
      COMMON /INFO/ NOCCO(2),NVRTO(2)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /FILES/ LUOUT,MOINTS
      COMMON/METH/MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC,
     &            CC2,RCCD,DRCCD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),
     &DIRPRD(8,8)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),NTOT(18)
      COMMON /CONTROL/ IPRNT,IXXX,IXXX2
      COMMON /FLAGS/ IFLAGS(100)
C
      EQUIVALENCE(IFLAGS(2),METHOD)
C
      MXCOR=MAXCOR
C
C   ALLOCATE MEMORY FOR T1 AMPLITUDES
C
      I0TA=MXCOR+1-NTAA*IINTFP
      MXCOR=MXCOR-NTAA*IINTFP
      IF(IUHF.EQ.0) THEN
       I0TB=I0TA
      ELSE
       I0TB=I0TA-NTBB*IINTFP
       MXCOR=MXCOR-NTBB*IINTFP
      ENDIF
      CALL ZERO(ICORE(I0TA),NTAA)
      IF(IUHF.EQ.1) CALL ZERO(ICORE(I0TB),NTBB)
      TAU=.FALSE.
C
      DO 1000 ISPIN=1,IUHF+1 
C
C      AA AND BB SPIN CASES
C
       IF(ISPIN.EQ.1) THEN
        I0T=I0TA
        NOCCSQ=NF1AA
       ELSE
        I0T=I0TB
        NOCCSQ=NF1BB
       ENDIF
C
       I000=MXCOR+1-NOCCSQ*IINTFP
       MXCOR=MXCOR-NOCCSQ*IINTFP
       CALL ZERO(ICORE(I000),NOCCSQ)
C
       IF(IUHF.EQ.1) THEN
C
C LOOP OVER IRREPS OF EF BLOCK (THE SAME IRREPS AS THE IN AND MN BLOCKS 
C HAVE
C
       DO 100 IRREP=1,NIRREP
C
C RETRIEVE INTEGRALS AND T2 AMPLITUDES.
C
        NOCC2SQ=0 
        DO 110 IRREPJ=1,NIRREP
         NOCC2SQ=NOCC2SQ+POP(IRREPJ,ISPIN)
     &                    *POP(DIRPRD(IRREPJ,IRREP),ISPIN)
110     CONTINUE 
        DISSYW=IRPDPD(IRREP,18+ISPIN)
        DISSYT=IRPDPD(IRREP,18+ISPIN)
        NUMSYW=IRPDPD(IRREP,20+ISPIN)
        NUMSYT=IRPDPD(IRREP,20+ISPIN)
        I001=1
        I002=I001+IINTFP*MAX(NUMSYW,DISSYW,DISSYT,
     &                       NUMSYW,NUMSYT)*NOCC2SQ
        I003=I002+IINTFP*MAX(NUMSYW,DISSYW,DISSYT,
     &                       NUMSYW,NUMSYT)*NOCC2SQ
        I004=I003+IINTFP*MAX(NUMSYT*DISSYT,NUMSYW*DISSYW)
        IF(MIN(NUMSYT,NUMSYW,DISSYT,DISSYW).NE.0) THEN
         I004=I003+IINTFP*MAX(NUMSYT,NUMSYW)
         if (I004.LT.0) call trap_intovf('QUAD2',1)
         IF(I004.LT.MXCOR) THEN
C  
C         IN CORE VERSION
C
C
      CALL RCC_Q2AA(ICORE(I001),ICORE(I002),ICORE(I000),ICORE(I0T),
     &              TAU,ISPIN,POP(1,ISPIN),VRT(1,ISPIN),NOCCSQ,
     &              NOCC2SQ,DISSYW,
     &              DISSYT,NUMSYW,NUMSYT,IRREP,ICORE(I003),FACT)
          ENDIF 
         ELSE
        ENDIF 
100    CONTINUE
       ENDIF
C
C       AB SPIN CASE
C
      NMULT = 1
      IF (RCCD .AND. IUHF .EQ. 0) NMULT = 2

      DO IMULT = 1, NMULT

       IF (IMULT.EQ.2) CALL ZERO(ICORE(I000),NOCCSQ)
C
C      LOOP OVER IRREPS.
C
       DO 200 IRREP=1,NIRREP
C
C     RETRIEVE INTEGRALS AND T2 AMPLITUDES
C
        DISSYW=IRPDPD(IRREP,13)
        DISSYT=IRPDPD(IRREP,13)
        NUMSYW=IRPDPD(IRREP,14)
        NUMSYT=IRPDPD(IRREP,14)
        I001=1
        I002=I001+IINTFP*NUMSYW*DISSYW
        I003=I002+IINTFP*NUMSYT*DISSYT
        IF(MIN(NUMSYT,NUMSYW,DISSYT,DISSYW).NE.0) THEN
         I004=I003+3*IINTFP*MAX(NUMSYT,NUMSYW,DISSYW,DISSYT)
         if (I004.LT.0) call trap_intovf('QUAD2',2)
         IF(I004.LT.MXCOR) THEN
C
C         IN CORE VERSION
C
          CALL RCC_Q2AB(ICORE(I001),ICORE(I002),ICORE(I000),ICORE(I0TA),
     &              ICORE(I0TB),TAU,ISPIN,POP(1,ISPIN),POP(1,3-ISPIN),
     &              VRT(1,ISPIN),VRT(1,3-ISPIN),NOCCSQ,DISSYW,DISSYT,
     &              NUMSYW,NUMSYT,IRREP,ICORE(I003),IUHF,FACT,IMULT)
         ELSE
          STOP 'Q2AB'
         ENDIF
        ELSE
       ENDIF 
200   CONTINUE
#ifdef _DEBUG_LVL0
      call checksum("F(i,j):",icore(i000),NOCCSQ)
#endif
      IF (IMULT .EQ. 1) THEN
         CALL PUTLST(ICORE(I000),1,1,1,ISPIN,91)
      ELSE
         CALL PUTLST(ICORE(I000),1,1,1,10,91)
      ENDIF

      ENDDO 
C
1000  CONTINUE
C
      RETURN
      END
