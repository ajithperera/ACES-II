C
      SUBROUTINE W1AA(W,Z,MAXSIZE,T1,FACT,VRT,POP,DISSYZ,DISSYW,
     &                NUMSYZ,NUMSYW,NVRTSQ,LISTW,LISTZ,IRREP,
     &                TMP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      INTEGER DISSYW,DISSYZ,DISMAX,DISWRITE,DISLEFT,DIRPRD,POP,VRT
      DIMENSION Z(DISSYZ,1),W(DISSYW,NUMSYW),T1(1),
     &          POP(8),VRT(8),TMP(1)
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPBA(255),IRREPB(255),
     &                DIRPRD(8,8)
C
      DATA AZERO,ONE,ONEM /0.0D0,1.0D0,-1.D0/
C
      IF(MIN(NUMSYW,DISSYW).NE.0) THEN
C
C GET INTEGRALS <EF//AM> FROM LISTW, WE NEED THEM ANYWAY
C
       CALL GETLST(W,1,NUMSYW,2,IRREP,LISTW)
C
C DECIDE WHICH ALGORITHM IS USED
C
       IF(MAXSIZE.GE.MAX(NUMSYZ*DISSYZ*2,NVRTSQ*DISSYZ)) THEN
C
C FULL IN CORE
C
        CALL ZERO(Z,NVRTSQ*DISSYZ)
C
C      PERFORM MULTIPLICATION
C
        JOFFW=1
        JOFFZ=1
        IOFF=1
C 
        DO 90 IRREPJ=1,NIRREP
C
         NOCCJ=POP(IRREPJ)
         NVRTJ=VRT(IRREPJ)
C
         IRREPI=DIRPRD(IRREPJ,IRREP)
C
         NVRTI=VRT(IRREPI)
C
         IF(MIN(NVRTJ,NVRTI,NOCCJ).NE.0) THEN
C
          CALL XGEMM('N','T',DISSYW*NVRTI,NVRTJ,NOCCJ,FACT,W(1,JOFFW),
     &               DISSYW*NVRTI,T1(IOFF),NVRTJ,AZERO,Z(1,JOFFZ),
     &               DISSYZ*NVRTI)
         ENDIF
C
C UPDATE OFFSETS
C
         JOFFW=JOFFW+NOCCJ*NVRTI
         JOFFZ=JOFFZ+NVRTJ*NVRTI
         IOFF=IOFF+NOCCJ*NVRTJ
C
90      CONTINUE
C
C  ANTISYMMETRIZE Z, TRANPOSE IT AND ADD IT TO LISTZ
C
        CALL ASSYM2(IRREP,VRT,DISSYZ,Z)
        CALL TRANSP(Z,Z(1,NUMSYZ+1),NUMSYZ,DISSYZ)
        CALL GETLST(Z,1,NUMSYZ,1,IRREP,LISTZ)
        CALL SAXPY(NUMSYZ*DISSYZ,ONE,Z(1,NUMSYZ+1),1,Z,1)
        CALL PUTLST(Z,1,NUMSYZ,1,IRREP,LISTZ)
       ELSE
C          write(6,*) ' out-of-core w1aa'
C
C  WE HAVE TO DO IT OUT OF CORE, PRObABLY MORE OFTEN THAN WE LIKE
C
C  DETERMINE FIRST THE NUMBER OF DISTRIBUTIONS WHICH FIT INTO CORE
C
        DISMAX=MAXSIZE/(NVRTSQ+NUMSYW)
        IF(DISMAX.EQ.0) STOP 'W1AA'
C
C  SET OFFSET FOR TARGET LIST
C
        IOFFSET=1
C
C  SET NUMBER OF DISTRIBUTIONS TO BE CALCULATED
C
        DISLEFT=NUMSYZ
C
10      CONTINUE
C
C  DETERMINE NUMBER OF DISTRIBUTIONS TO CALCULATE IN THIS PASS
C
         DISWRITE=MIN(DISLEFT,DISMAX)
         DISLEFT=DISLEFT-DISWRITE
C
C  OFFSET FOR COPY OF INTEGRALS
C
         IOFFW=1+DISWRITE*NVRTSQ
C
C  COPY INTEGRALS TO THE NEW LOCATION 
C  
         IOFFW2=0
         DO 180 INUM=1,NUMSYW
c YAU : old
c         CALL ICOPY(IINTFP*DISWRITE,W(IOFFSET,INUM),1,Z(IOFFW+IOFFW2,1),1)
c YAU : new
          CALL DCOPY(DISWRITE,W(IOFFSET,INUM),1,Z(IOFFW+IOFFW2,1),1)
c YAU : end
          IOFFW2=IOFFW2+DISWRITE
180      CONTINUE
C
C  ZERO TARGET ARRAY
C
         CALL ZERO(Z,NVRTSQ*DISWRITE)
C
C  PERFORM MULTIPLICATION
C
         JOFFW=IOFFW
         JOFFZ=1
         IOFF=1
         DO 190 IRREPJ=1,NIRREP
          NOCCJ=POP(IRREPJ)
          NVRTJ=VRT(IRREPJ)
          IRREPI=DIRPRD(IRREP,IRREPJ)
          NVRTI=VRT(IRREPI)
C
          IF(MIN(NVRTI,NOCCJ,NVRTJ).NE.0) THEN
C
           CALL XGEMM('N','T',DISWRITE*NVRTI,NVRTJ,NOCCJ,FACT,
     &                Z(JOFFW,1),DISWRITE*NVRTI,T1(IOFF),NVRTJ,
     &                AZERO,Z(JOFFZ,1),DISWRITE*NVRTI)
          ENDIF
C
C  UPDATE OFFSETS
C
          JOFFW=JOFFW+DISWRITE*NVRTI*NOCCJ
          JOFFZ=JOFFZ+DISWRITE*NVRTI*NVRTJ
          IOFF=IOFF+NOCCJ*NVRTJ
190      CONTINUE
C
         CALL ASSYM2(IRREP,VRT,DISWRITE,Z)
         CALL TRANSP(Z,Z(1,1+DISWRITE),DISSYZ,DISWRITE)
         CALL GETLST(Z,IOFFSET,DISWRITE,1,IRREP,LISTZ)
         CALL SAXPY(DISWRITE*DISSYZ,ONE,Z(1,1+DISWRITE),1,Z,1)
         CALL PUTLST(Z,IOFFSET,DISWRITE,1,IRREP,LISTZ)
C
C  UPDATE IOFFSET
C
         IOFFSET=IOFFSET+DISWRITE
C
C  IF NOT ALL TARGET DISTRIBUTIONS HAVE BEEN FORMED, GO BACK TO 10
C
        IF(DISLEFT.NE.0) GO TO 10
C
       ENDIF
      ENDIF
      RETURN
      END 
