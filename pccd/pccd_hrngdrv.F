      SUBROUTINE PCCD_HRNGDRV(ICORE,MAXCOR,LISTW,LISTT,CALMOD,MAXSIZ,
     &                  INCREM,LSTSCR,TAU,T1A,T1B,POP1,POP2,VRT1, 
     &                  VRT2,FACT,SPCASE,IUHF)
C     
C     THIS SUBROUTINE IS CALLED BY H4X2ALL
C     
CEND  
C
      IMPLICIT INTEGER (A-Z)
      LOGICAL TAU
      LOGICAL MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC
      CHARACTER*3 CALMOD
      CHARACTER*4 SPCASE
      DOUBLE PRECISION FACT,T1A(1),T1B(1)
      DOUBLE PRECISION ONE,ONEM,HALF
      DOUBLE PRECISION BETA
      DIMENSION ICORE(MAXCOR),VRT1(8),VRT2(8),POP1(8),POP2(8)
CSSS      COMMON/METH/MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),
     &DIRPRD(8,8)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /FLAGS2/IFLAGS2(500)
C
#include "parcc.com"
C
      DATA ONE,ONEM,HALF /1.0D0,-1.D0,0.5D0/
C
C LOOP OVER IRREPS.
C
       DO 100 IRREP=1,NIRREP
        DISSYW=IRPDPD(IRREP,ISYTYP(1,LISTW))
        DISSYT=IRPDPD(IRREP,ISYTYP(1,LISTT))
        NUMSYW=IRPDPD(IRREP,ISYTYP(2,LISTW))
        NUMSYT=IRPDPD(IRREP,ISYTYP(2,LISTT))
        DISSYQ=DISSYT
        NUMSYQ=NUMSYW
        MAXSIZ=MAX(NUMSYQ*DISSYQ,MAXSIZ)
        I000=1
        I010=I000+IINTFP*MAX(NUMSYQ*DISSYQ,NUMSYQ+DISSYQ)
        I020=I010+IINTFP*NUMSYT*DISSYT
        I030=I020+IINTFP*DISSYW*NUMSYW
        I040=I030+IINTFP*DISSYT*NUMSYT
C
C CAN WE DO IT IN CORE?
C
        IF(I040.LT.MAXCOR)THEN
C
C For Pccd (RHF only) form the list 34 on the fly using lists 37 and 
C 39
            CALL GETLST(ICORE(I040),1,NUMSYT,1,IRREP,37)
            CALL GETLST(ICORE(I010),1,NUMSYT,1,IRREP,39)
            CALL DAXPY(NUMSYT*DISSYT,ONEM,ICORE(I040),1,
     &                 ICORE(I010),1) 

CSSS#ifdef _DCC_FLAG
C This will form (Beta T2 + 2T1*T1) before multilying with H4, which
C (T2 * L2 +  T1*L1) (without explictly considering the factors)
C As a result of this multiplication we introduce extra term
C in (when Beta is not 1.0). That will be substracted in the next
c call by doing (1-beta) T2*(2T1*L1). 
C
        If (Ispar .and. .not. Coulomb) Then
           Write(6, "(a,F5.2)") " In HRNGDR setting delta to :", 
     &                            Wmbej_scale
           Write(6,*)
           CALL DSCAL(NUMSYT*DISSYT, Wmbej_scale, ICORE(I010), 1)
        Endif 
CSSS#endif 
CSSS         call checksum("T2-RNGDR",icore(i010),numsyt*dissyt)

         IF(TAU) THEN
          CALL F2TAU(ICORE(I010),T1A,T1B,DISSYT,NUMSYT,POP1,POP2,
     &               VRT1,VRT2,IRREP,FACT,SPCASE)
         ENDIF
         CALL GETLST(ICORE(I020),1,NUMSYW,2,IRREP,LISTW)
C
C  SCALE H4 FIRST BY 0.5
C
         CALL SSCAL(NUMSYW*DISSYW,HALF,ICORE(I020),1)
CSSS         call checksum("W2-RNGDR",icore(i020),numsyt*dissyt)
C
C  FOR QCISD AND CCSD ADD L1*T1 TERM
C
C NOTE THE DIFFERENT CALLS FOR THE DIFFERENT H4 LISTS
C
         IF((QCISD.OR.CCSD).AND.IRREP.EQ.1) THEN
          IF(MOD(LISTW,100).EQ.54) THEN
           CALL L1T1H4(ICORE(I020),DISSYW,NUMSYW,ICORE(I000),
     &                 ONEM,1,1,190,90)
          ELSE IF(MOD(LISTW,100).EQ.55) THEN
           CALL L1T1H4(ICORE(I020),DISSYW,NUMSYW,ICORE(I000),
     &                 ONEM,2,2,190,90)
          ELSE IF(MOD(LISTW,100).EQ.56) THEN
           CALL L1T1H4(ICORE(I020),DISSYW,NUMSYW,ICORE(I000),
     &                 ONE,1,1+IUHF,190,90)
          ELSE IF(MOD(LISTW,100).EQ.57) THEN
           CALL L1T1H4(ICORE(I020),DISSYW,NUMSYW,ICORE(I000),
     &                 ONE,2,1,190,90)
          ENDIF
         ENDIF
         IF(MIN(DISSYT,NUMSYT,NUMSYW).NE.0)THEN
          CALL MXM(ICORE(I010),DISSYT,ICORE(I020),NUMSYT,ICORE(I000),
     &             NUMSYW)
         ENDIF
        ELSE
         CALL INSMEM('PCCD_HRNGDRV',I040,MAXCOR)
        ENDIF
        IF(CALMOD.EQ.'WxT')THEN
         CALL TRANSP(ICORE(I000),ICORE(I010),NUMSYQ,DISSYQ)
c YAU : old
c        CALL ICOPY(IINTFP*NUMSYQ*DISSYQ,ICORE(I010),1,ICORE(I000),1)
c YAU : new
         CALL DCOPY(NUMSYQ*DISSYQ,ICORE(I010),1,ICORE(I000),1)
c YAU : end
         ITMP=NUMSYQ
         NUMSYQ=DISSYQ
         DISSYQ=ITMP
        ENDIF
C
C AUGMENT Q(ABAB) AND DUMP IT TO DISK.
C
        IF(INCREM.EQ.1)THEN
         CALL GETLST(ICORE(I020),1,NUMSYQ,1,IRREP,LSTSCR)
         CALL VADD(ICORE(I020),ICORE(I020),ICORE(I000),
     &             DISSYQ*NUMSYQ,1.D0)
         CALL PUTLST(ICORE(I020),1,NUMSYQ,1,IRREP,LSTSCR)

c         call chksums("HRNGDRVR PUTLST 1 ",icore(i020),numsyq*dissyq)

         CALL DCOPY(DISSYQ*NUMSYQ,ICORE(I020),1,ICORE(I000),1)
        ELSE
         CALL PUTLST(ICORE(I000),1,NUMSYQ,1,IRREP,LSTSCR)
CSSS         call checksum(SPCASE,icore(i000),numsyt*dissyt)
        ENDIF
100    CONTINUE
       RETURN
       END
