      SUBROUTINE T12ALL(W,Z,SCR,T1A,T1B,DISSYW,DISSYZ,DISTMP,NUMSYW,
     &                  NUMSYZ,NUMTMP,NOCCSQ,POP1,POP2,VRT1,VRT2,
     &                  LISTW,LISTZ,FACT,ITRANS,INCREM,IRREP,MAXCOR)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL bRedundant
      INTEGER DISSYW,DISSYZ,DISTMP,DIRPRD,POP1,POP2,VRT1,VRT2
      DIMENSION W(DISSYW,NUMSYW),Z(DISTMP,NUMSYZ),T1A(1),T1B(1),
     &          POP1(8),POP2(8),VRT1(8),VRT2(8),SCR(MAXCOR)
C     
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),
     &                DIRPRD(8,8)
      COMMON /FLAGS2/ IFLAGS2(500)
      integer         iintln, ifltln, iintfp, ialone, ibitwd
      common /machsp/ iintln, ifltln, iintfp, ialone, ibitwd
C 
      DATA AZERO,ONE /0.D0,1.D0/
C
      IF(MIN(NUMSYZ,DISSYZ).EQ.0) RETURN
      bRedundant = IFLAGS2(155).EQ.0
C
C GET INTEGRAL LIST AND TRANSPOSE LAST TWO INDICES
C
      IF(bRedundant .or. (LISTW.gt.22)) THEN
        CALL GETLST(Z,1,NUMSYW,2,IRREP,LISTW)
      ELSE
        CALL GETLST_NR(Z,SCR,MAXCOR*IINTFP,LISTW,IRREP)
      ENDIF            

CSSS      If (listw .eq. 121 .or. listw .eq. 122) then
CSSS         call dzero(z,NUMSYW*DISSYW)
CSSS      endif 
C
      CALL SYMTRA(IRREP,VRT2,POP1,DISSYW,Z,W)
C
C ZERO TARGET ARRAY
C
      CALL ZERO(Z,DISTMP*NOCCSQ)
C
C PERFORM FIRST MULTIPLICATION
C
      IOFFT=1
      IOFFZ=1
      IOFFW=1
      DO 100 IRREPJ=1,NIRREP
       NVRTJ=VRT2(IRREPJ)
       NOCCJ=POP2(IRREPJ)
       IRREPI=DIRPRD(IRREPJ,IRREP)
       NOCCI=POP1(IRREPI) 
       IF(NOCCI.NE.0.AND.NOCCJ.NE.0.AND.NVRTJ.NE.0) THEN
C
        CALL XGEMM('N','N',DISSYW*NOCCI,NOCCJ,NVRTJ,ONE,W(1,IOFFW),
     &             DISSYW*NOCCI,T1A(IOFFT),NVRTJ,AZERO,Z(1,IOFFZ),
     &             DISSYW*NOCCI)
       ENDIF
       IOFFT=IOFFT+NOCCJ*NVRTJ
       IOFFZ=IOFFZ+NOCCJ*NOCCI
       IOFFW=IOFFW+NOCCI*NVRTJ
100   CONTINUE
C
C TRANSPOSE AGAIN LAST TWO INDICES
C
      CALL SYMTRA(IRREP,POP1,POP2,DISSYW,Z,W)
C
C ZERO TARGET ARRAY
C
      CALL ZERO(Z,NUMSYZ*DISSYZ)
C
C PERFORM SECOND MULTIPLICATION
C
      IOFFT=1
      IOFFW=1
      IOFFZ=1
      DO 200 IRREPJ=1,NIRREP
       NVRTJ=VRT1(IRREPJ)
       NOCCJ=POP1(IRREPJ)
       IRREPI=DIRPRD(IRREPJ,IRREP)
       NOCCI=POP2(IRREPI)
       IF(NOCCI.NE.0.AND.NOCCJ.NE.0.AND.NVRTJ.NE.0) THEN
C
        CALL XGEMM('N','T',DISSYW*NOCCI,NVRTJ,NOCCJ,FACT,W(1,IOFFW),
     &             DISSYW*NOCCI,T1B(IOFFT),NVRTJ,AZERO,Z(1,IOFFZ),
     &             DISSYW*NOCCI)
       ENDIF
       IOFFT=IOFFT+NOCCJ*NVRTJ
       IOFFZ=IOFFZ+NOCCI*NVRTJ
       IOFFW=IOFFW+NOCCI*NOCCJ
200   CONTINUE
C
C TRANSPOSE AGAIN THE LAST TWO INDICES AND SAVE RESULTS ON LIST
C
      CALL SYMTRA(IRREP,POP2,VRT1,DISSYW,Z,W)
C
C FIRST CASE, NO TRANSPOSE OF RESULTS ARE REQUIRED 
C
CSSS      call checksum("t12int2",w,DISSYW*NUMSYW)
CSSS      Write(6,*) "intentionally making t12int2 zero"
CSSS      CALL ZERO(W,NUMSYW*DISSYW)

      IF(ITRANS.EQ.0) THEN
       IF(INCREM.EQ.1) THEN
C UPDATE
        CALL GETLST(Z,1,NUMSYZ,1,IRREP,LISTZ)
        CALL VADD(Z,Z,W,NUMSYZ*DISSYZ,ONE)
        CALL PUTLST(Z,1,NUMSYZ,1,IRREP,LISTZ)
       ELSE
C INITIALIZE
        CALL PUTLST(W,1,NUMSYZ,1,IRREP,LISTZ)
       ENDIF
C
      ELSE
C
C TRANSPOSE RESULTS FIRST
       CALL TRANSP(W,Z,DISSYZ,NUMSYZ)
       IF(INCREM.EQ.1) THEN
C UPDATE
        CALL GETLST(W,1,NUMSYZ,1,IRREP,LISTZ)
#ifdef _DEBUG_LVLM
       call checksum("t12int2-in",w,DISSYW*NUMSYW)
       call checksum("t12int2-ic",Z,DISSYZ*NUMSYZ)
#endif 
        CALL VADD(W,W,Z,NUMSYZ*DISSYZ,ONE)
#ifdef _DEBUG_LVLM
       call checksum("t12int2-fn",w,DISSYZ*NUMSYZ)
#endif 
        CALL PUTLST(W,1,NUMSYZ,1,IRREP,LISTZ)
       ELSE
C INITIALIZE
        CALL PUTLST(Z,1,NUMSYZ,1,IRREP,LISTZ)
       ENDIF
      ENDIF
      RETURN
      END
