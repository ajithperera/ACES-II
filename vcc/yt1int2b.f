      SUBROUTINE YT1INT2B(ICORE,MAXCOR,IUHF,IRROMEGA)
C
C THIS SUBROUTINE CALCULATES THE CONTRIBUTION OF T1 TO
C   T2 (T2<-T1).  THIS CODE IS GENERAL IN THE SENSE THAT
C   IT DOES NOT ASSUME THAT T (AND Z) ARE TOTALLY SYMMETRIC
C   QUANTITIES, BUT RATHER TRANSFORM AS IRROMEGA.
C
C  This has been modified to give only the pieces necessary for
C  semicanonical ROHF-MBPT.
C
C CONTRACTION 1:
C
C     Z(ab,ij) = SUM  T(e,i) * <ab||ej>   [AAAA and BBBB]
C                 e
C
C     Z(Ab,Ij) = SUM  T(E,I) * <Ab||Ej> + T(e,j) * <Ab||Ie> [ABAB]
C                 e
C
CEND
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION ONE,ZILCH,HALF
      LOGICAL RHF
C
      DIMENSION ICORE(MAXCOR),IOFFT1(8,2),IOFFW(8),IOFFZ(8)
C
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON /SYM/ POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
C
      DATA HALF /0.5/
      DATA ONE  /1.0/
      DATA ZILCH/0.0/
C
      CALL GETDT1(ICORE,MAXCOR,MXCOR,IUHF,IOFFT1,IRROMEGA)
      RHF=.FALSE.
      IF(IUHF.EQ.0)RHF=.TRUE.
C
C
C DO ALPHA-BETA SPIN CASE.  CONTAINS BOTH GENERAL AB AND 
C SPIN-ADAPTED RHF CODE.  THIS BLOCK OF CODE ALWAYS RUNS.
C
      DO 100 IRREPZR=1,NIRREP
C
C LOOP OVER KET IRREPS OF *TARGET*.  THIS IS NOT THE SAME AS THE
C  IRREPS OF THE INTEGRALS AND AMPLITUDES UNLESS IRROMEGA=1.
C
       IRREPZL=DIRPRD(IRREPZR,IRROMEGA)
       IRREPW=IRREPZL
       LISTW=130
       LISTZ=63
       DISSYW=IRPDPD(IRREPW,ISYTYP(1,LISTW)) 
       NUMDSW=IRPDPD(IRREPW,ISYTYP(2,LISTW)) 
       DISSYZ=IRPDPD(IRREPZL,ISYTYP(1,LISTZ))
       NUMDSZ=IRPDPD(IRREPZR,ISYTYP(2,LISTZ))
       MAXW=MAX(NUMDSW,DISSYW)
       MAXZ=MAX(DISSYZ,NUMDSZ)
       I000=1
       I010=I000+IINTFP*MAX(DISSYZ*NUMDSZ,3*MAXW)
       I020=I010+IINTFP*MAX(DISSYW*NUMDSW,3*MAXZ,NUMDSZ*DISSYZ)
       IF(I020.LT.MXCOR)THEN
C
C DO IN-CORE ALGORITHM
C
C
C READ W INTO W(Ab,Ej) AND TRANSPOSE KET INDICES TO W(Ab,jE).  
C  ALSO SPIN ADAPT FOR RHF CALCULATION.
C
        CALL GETLST(ICORE(I010),1,NUMDSW,1,IRREPW,LISTW)
        ITMP1=I000
        ITMP2=ITMP1+IINTFP*MAXW
        ITMP3=ITMP2+IINTFP*MAXW
        ITMP4=ITMP3+IINTFP*MAXW
        CALL SYMTR1 (IRREPW,VRT(1,1),POP(1,2),DISSYW,ICORE(I010),
     &               ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
C
C COMPUTE OFFSETS FOR W AND Z VECTORS
C
        IW=0
        IZ=0
        DO 110 IRR2=1,NIRREP
         IOFFW(IRR2)=I010+IW
         IOFFZ(IRR2)=I000+IZ
         IRR1W=DIRPRD(IRR2,IRREPW)
         IRR1Z=DIRPRD(IRR2,IRREPZR)
         IW=IW+DISSYW*POP(IRR1W,2)*VRT(IRR2,1)*IINTFP
         IZ=IZ+DISSYZ*POP(IRR1Z,2)*POP(IRR2,1)*IINTFP
110     CONTINUE
C
C PERFORM MATRIX MULTIPLICATION
C
C         Z(Ab,jI) = SUM W(Abj,E) * T(E,I)
C                     e
C  
        DO 120 IRREPE=1,NIRREP
         IRREPI=DIRPRD(IRREPE,IRROMEGA)
         IRREPJ=DIRPRD(IRREPE,IRREPW)
         NROW=DISSYW*POP(IRREPJ,2)
         NCOL=POP(IRREPI,1)
         NSUM=VRT(IRREPE,1)
         IZ=IOFFZ(IRREPI)
         IW=IOFFW(IRREPE)
         IT=IOFFT1(IRREPI,1) 
         CALL XGEMM('N','N',NROW,NCOL,NSUM,ONE,ICORE(IW),NROW,
     &              ICORE(IT),NSUM,ZILCH,ICORE(IZ),NROW)
120     CONTINUE
C
C TRANSPOSE KET INDICES BACK TO Z(Ab,Ij)
C
        ITMP1=I010
        ITMP2=ITMP1+IINTFP*MAXZ
        ITMP3=ITMP2+IINTFP*MAXZ
        ITMP4=ITMP3+IINTFP*MAXZ
        CALL SYMTR1 (IRREPZR,POP(1,2),POP(1,1),DISSYZ,ICORE(I000),
     &               ICORE(ITMP1),ICORE(ITMP2),ICORE(ITMP3))
        CALL SUMSYM2(ICORE(I000),ICORE(I010),NUMDSZ*DISSYZ,1,
     &                IRREPZR,LISTZ)
C
       ELSE
C
C OUT-OF-CORE ALGORITHM
C
        WRITE(6,*)' out-of-core AB not coded '
C
       ENDIF
C
c       IF(RHF)THEN
       IF(.true.)THEN
C
C IF RHF, SYMMETRIZE TARGET, DUMP TO DISK AND RETURN
C
C           Z(ab,ij) = Z(ab,ij) + Z(ba,ji)
C
c        ITMP1=I010
c        ITMP2=ITMP1+DISSYZ*IINTFP
c        ITMP3=ITMP2+DISSYZ*IINTFP
c        ITMP4=ITMP3+DISSYZ*IINTFP
c        CALL SYMRHF3(IRREPZL,IRREPZR,VRT(1,1),POP(1,1),DISSYZ,
c     &               ICORE(I000),ICORE(ITMP1),ICORE(ITMP2),
c     &               ICORE(ITMP3))
c        CALL SUMSYM2(ICORE(I000),ICORE(I010),NUMDSZ*DISSYZ,1,
c     &               IRREPZR,LISTZ)
C
       ELSE
C
C IF UHF, HAVE TO DO ANOTHER CONTRACTION FOR AB CASE
C
C        Z(Ab,Ij) = W(Ab,Je) * T(e,i)
C
C
C READ W INTO W(Ab,Je)
C
        LISTW=129
        DISSYW=IRPDPD(IRREPW,ISYTYP(1,LISTW)) 
        NUMDSW=IRPDPD(IRREPW,ISYTYP(2,LISTW)) 
        I020=I010+IINTFP*MAX(DISSYW*NUMDSW,3*MAXZ,NUMDSZ*DISSYZ)
        IF(I020.LT.MXCOR)THEN
         CALL GETLST(ICORE(I010),1,NUMDSW,1,IRREPW,LISTW)
C
C COMPUTE OFFSETS FOR W AND Z VECTORS
C
         IW=0
         IZ=0
         DO 140 IRR2=1,NIRREP
          IOFFW(IRR2)=I010+IW
          IOFFZ(IRR2)=I000+IZ
          IRR1W=DIRPRD(IRR2,IRREPW)
          IRR1Z=DIRPRD(IRR2,IRREPZR)
          IW=IW+DISSYW*POP(IRR1W,1)*VRT(IRR2,2)*IINTFP
          IZ=IZ+DISSYZ*POP(IRR1Z,1)*POP(IRR2,2)*IINTFP
140      CONTINUE
C
C PERFORM MATRIX MULTIPLICATION
C
C         Z(Ab,Ji) = SUM W(Ab,Je) * T(e,i)
C                     e
C  
         DO 150 IRREPE=1,NIRREP
          IRREPI=DIRPRD(IRREPE,IRROMEGA)
          IRREPJ=DIRPRD(IRREPE,IRREPW)
          NROW=DISSYW*POP(IRREPJ,1)
          NCOL=POP(IRREPI,2)
          NSUM=VRT(IRREPE,2)
          IZ=IOFFZ(IRREPI)
          IW=IOFFW(IRREPE)
          IT=IOFFT1(IRREPI,2) 
          CALL XGEMM('N','N',NROW,NCOL,NSUM,ONE,ICORE(IW),NROW,
     &               ICORE(IT),NSUM,ONE,ICORE(IZ),NROW)
150      CONTINUE
C
         CALL SUMSYM2(ICORE(I000),ICORE(I010),NUMDSZ*DISSYZ,1,
     &                IRREPZR,LISTZ)
C
        ELSE
C
         WRITE(6,*)' out-of-core not coded yet '
C
        ENDIF
C
       ENDIF
C
100   CONTINUE
C
      IF(RHF)RETURN
C
C NOW DO AAAA AND BBBB SPIN CASES IF WE HAVEN'T RETURNED YET.
C
      DO 200 ISPIN=1,1+IUHF
       DO 210 IRREPZR=1,NIRREP
C
C LOOP OVER KET IRREPS OF *TARGET*.  THIS IS NOT THE SAME AS THE
C  IRREPS OF THE INTEGRALS AND AMPLITUDES UNLESS IRROMEGA=1.
C
        IRREPZL=DIRPRD(IRREPZR,IRROMEGA)
        IRREPW=IRREPZL
        LISTW=126+ISPIN
        LISTZ=60+ISPIN
        DISSYW=IRPDPD(IRREPW,ISYTYP(1,LISTW)) 
        NUMDSW=IRPDPD(IRREPW,ISYTYP(2,LISTW)) 
        DISSYZ=IRPDPD(IRREPZL,ISYTYP(1,LISTZ))
        NUMDSZ=IRPDPD(IRREPZR,ISYTYP(2,LISTZ))
        NUMDSZ0=IRPDPD(IRREPZR,20+ISPIN)
        MAXW=MAX(DISSYW,NUMDSW)
        MAXZ=MAX(DISSYZ,NUMDSZ,NUMDSZ0)
        I000=1
        I010=I000+IINTFP*MAX(DISSYZ*NUMDSZ0,3*MAXW)
        I020=I010+IINTFP*MAX(DISSYW*NUMDSW,DISSYZ*NUMDSZ)
        IF(I020.LT.MXCOR)THEN
C
C DO IN-CORE ALGORITHM
C
C
C READ W INTO W(a<b,ej) AND TRANSPOSE KET INDICES TO W(a<b,je)
C
         CALL GETLST(ICORE(I010),1,NUMDSW,1,IRREPW,LISTW)
         ITMP1=I000
         ITMP2=ITMP1+IINTFP*MAXW
         ITMP3=ITMP2+IINTFP*MAXW
         ITMP4=ITMP3+IINTFP*MAXW
         CALL SYMTR1 (IRREPW,VRT(1,ISPIN),POP(1,ISPIN),DISSYW,
     &                ICORE(I010),ICORE(ITMP1),ICORE(ITMP2),
     &                ICORE(ITMP3))
C
C COMPUTE OFFSETS FOR W AND Z VECTORS
C
         IW=0
         IZ=0
         DO 220 IRR2=1,NIRREP
          IOFFW(IRR2)=I010+IW
          IOFFZ(IRR2)=I000+IZ
          IRR1W=DIRPRD(IRR2,IRREPW)
          IRR1Z=DIRPRD(IRR2,IRREPZR)
          IW=IW+DISSYW*POP(IRR1W,ISPIN)*VRT(IRR2,ISPIN)*IINTFP
          IZ=IZ+DISSYZ*POP(IRR1Z,ISPIN)*POP(IRR2,ISPIN)*IINTFP
220      CONTINUE
C
C PERFORM MATRIX MULTIPLICATION
C
C         Z(a<b,ji) = SUM W(a<bj,e) * T(e,i)
C                     e
C  
         DO 230 IRREPE=1,NIRREP
          IRREPI=DIRPRD(IRREPE,IRROMEGA)
          IRREPJ=DIRPRD(IRREPE,IRREPW)
          NROW=DISSYW*POP(IRREPJ,ISPIN)
          NCOL=POP(IRREPI,ISPIN)
          NSUM=VRT(IRREPE,ISPIN)
          IZ=IOFFZ(IRREPI)
          IW=IOFFW(IRREPE)
          IT=IOFFT1(IRREPI,ISPIN) 
          CALL XGEMM('N','N',NROW,NCOL,NSUM,HALF,ICORE(IW),NROW,
     &               ICORE(IT),NSUM,ZILCH,ICORE(IZ),NROW)
c          CALL XGEMM('N','N',NROW,NCOL,NSUM,ONE,ICORE(IW),NROW,
c     &               ICORE(IT),NSUM,ZILCH,ICORE(IZ),NROW)
          call vminus(icore(iz),nrow*ncol)
230      CONTINUE
C
C NOW ANTISYMMETRIZE TARGET TO Z(a<b,i<j) AND DUMP IT TO INCREMENTS
C
         CALL ASSYM2 (IRREPZR,POP(1,ISPIN),DISSYZ,ICORE(I000))
         itmp = NUMDSZ*DISSYZ
         if (itmp.gt.0) then
            CALL SUMSYM2(ICORE(I000),ICORE(I010),itmp,1,IRREPZR,LISTZ)
         end if
C
        ELSE
C
C OUT-OF-CORE ALGORITHM
C
         WRITE(6,*)' out-of-core not coded yet '
C
        ENDIF
C
210    CONTINUE
200   CONTINUE
C
      RETURN
      END
