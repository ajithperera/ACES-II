      SUBROUTINE T12INT2(ICORE,MAXCOR,IUHF)
C
C THIS ROUTINE CALCULATES THE FOLLOWING TERM REQUIRED FOR CCSD
C
C  - P(IJ,AB) SUM M E  T(E,I) T(A,M) <MB//EJ>
C
C  IN RHF THERE ARE TWO REMAINING TERMS
C
C         - SUM m E T(E,I) T(b,m) <Am//Ej>   (INTEGRAL LIST 25)
C
C         - SUM m e T(e,j) T(b,m) <Ae//Im>   (INTEGRAL LIST 18)
C
C  IN UHF , THERE ARE FOUR ADDITIONAL TERMS REQUIRED
C
C         - SUM M E T(E,J) T(A,M) <MB//IE>  (INTEGRAL LIST 23)
C
C         - SUM m e T(e,j) T(a,m) <mb//ie>  (INTEGRAL LIST 24)
C
C         - SUM M E T(E,I) T(A,M) <Eb//mJ>  (INTEGRAL LIST 17)
C
C         - SUM M e T(e,j) T(A,M) <eI//bM>  (INTEGRAL LIST 26)
C
C  THE MULTIPLICATION IS CARRIED OUT IN T12ALL (THE 
C  LOGIC IS FOR ALL SIX TERMS THE SAME).
C  
C  THE TRANSPOSITIONS WITHIN RHF IS CARRIED OUT IN THE STANDARD
C  RING CODE, ALSO REORDERING OF THE AMPLITUDES ETC. IS DONE
C  THERE. NOTE ALSO THAT THE T2 INCREMENTS ARE MULTIPLIED BY MINUS
C  ONE IN THE RING CODE SO THAT HERE THE NEGATIVE CONTRIBUTION   
C  WILl BE CALCULATED.
C
C  THE T2 INCREMENTS ARE ACTUALLY STORED ON
C
C  LIST 40,41  (AAAA and BBBB, UHF ONLY)
C
C  LIST 42 AND 43 (AABB AND ABBA SPIN CASES, FOR
C                  UHF A TRANSPOSITION OF THE RESULT
C                  FROM BBAA TO AABB AND BAAB TO ABBA
C                  MUST BE PERFORMED)
C
CEND
C
C   CODED  JULY/90   JG
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DIRPRD,DISSYW,DISSYZ,DISTMP,VRT,POP
      DIMENSION ICORE(MAXCOR),IOFFT1(8,2)
      LOGICAL IJAB_DEBUG
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWO
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),
     &                DIRPRD(8,8)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),NTOT(18)
      COMMON /SYM/ POP(8,2),VRT(8,2),NTAA,NTBB,NF1AA,NF1BB,
     &             NF2AA,NF2BB
C
      DATA AZERO,ONE,ONEM /0.D0,1.D0,-1.D0/
C
C ALLOCATE MEMORY FOR T1 AMPLITUDE AND GET THEM FROM DISK
C
      CALL GETT1(ICORE,MAXCOR,MXCOR,IUHF,IOFFT1)
C 
C    AAAA AND BBBB SPIN CASES (ONLY NECCESARY FOR UHF)
C
C    - SUM M E T(E,I) T(B,M) <MA//EJ>
C
C    - SUM m e T(e,i) T(b,m) <ma//ej>
C
      IF(IUHF.EQ.1) THEN
C
       DO 100 ISPIN=1,2
C
C     ITRANS=0   .... NO TRANSPOSE OF RESULT IS NECESSARY
C     INCREM=0   .... INITIALIZE TARGET LIST, DO NOT UPDATE
C
        ITRANS=0
        INCREM=0
C
C     PREFACTOR OF THE CORRESPONDING CONTRIBUTION
C
        FACT=ONE
C
C     INTEGRAL AND TARGET LIST
C
        LISTW=22+ISPIN
        LISTZ=39+ISPIN
C
C    LOOP OVER IRREP
C
        DO 50 IRREP=1,NIRREP
C
         NOCCSQ=0
         DO 45 IRREPJ=1,NIRREP
          IRREPI=DIRPRD(IRREP,IRREPJ)
          NOCCSQ=NOCCSQ+POP(IRREPJ,ISPIN)*POP(IRREPI,ISPIN)
45       CONTINUE
C
         DISSYW=IRPDPD(IRREP,ISYTYP(1,LISTW))
         NUMSYW=IRPDPD(IRREP,ISYTYP(2,LISTW))
         DISSYZ=IRPDPD(IRREP,ISYTYP(1,LISTZ))
         NUMSYZ=IRPDPD(IRREP,ISYTYP(2,LISTZ))
         DISTMP=DISSYZ
         NUMTMP=NUMSYZ
         MSIZE=MAX(NUMSYW*DISSYW,NUMSYZ*DISSYZ,DISSYZ*NOCCSQ) 
         I001=1
         I002=I001+IINTFP*MSIZE
         I003=I002+IINTFP*MSIZE
         IF(I003.LT.MXCOR) THEN
C
C  IN CORE MULTIPLICATION
C
          CALL T12ALL(ICORE(I001),ICORE(I002),ICORE(I003),
     &                ICORE(IOFFT1(1,ISPIN)),
     &                ICORE(IOFFT1(1,ISPIN)),DISSYW,DISSYZ,DISTMP,
     &                NUMSYW,NUMSYZ,NUMTMP,NOCCSQ,POP(1,ISPIN),
     &                POP(1,ISPIN),VRT(1,ISPIN),VRT(1,ISPIN),LISTW,
     &                LISTZ,FACT,ITRANS,INCREM,IRREP,MXCOR-I003)
         ELSE
C 
C    SORRY, NO OUT CORE ALGORITHM AVAILABLE 
C
          STOP 'T12ALL'
         ENDIF
50      CONTINUE
100    CONTINUE
      ENDIF
C
C   ABAB SPIN CASE
      DO 200 ISPIN=1,IUHF+1
C
       FACT=ONE
C
C    ON THE FIRST PASS, INITIALIZE OUTPUT LIST AND DO NOT TRANSPOSE
C    RESULT, ON THE SECOND PASS, UPDATE OUTPUT LIST AND TRANSPOSE
C
       IF(ISPIN.EQ.1) THEN
        I0T1=IOFFT1(1,1)
        I0T2=IOFFT1(1,2)
        ITRANS=0
        INCREM=0
       ELSE
        I0T1=IOFFT1(1,2)
        I0T2=IOFFT1(1,1)
        ITRANS=1
        INCREM=1
       ENDIF
C
C  INTEGRAL AND TARGET LIST
C
       LISTW=24+ISPIN
       LISTZ=41+2*IUHF
C
       DO 150 IRREP=1,NIRREP
C
        DISSYW=IRPDPD(IRREP,ISYTYP(1,LISTW))
        NUMSYW=IRPDPD(IRREP,ISYTYP(2,LISTW))
        DISSYZ=IRPDPD(IRREP,ISYTYP(1,LISTZ))
        NUMSYZ=IRPDPD(IRREP,ISYTYP(2,LISTZ))
        IF(ITRANS.EQ.0) THEN
         DISTMP=DISSYZ
         NUMTMP=NUMSYZ
        ELSE
         DISTMP=NUMSYZ
         NUMTMP=DISSYZ
        ENDIF
        NOCCSQ=IRPDPD(IRREP,14)
        MSIZE=MAX(NUMSYW*DISSYW,NUMSYZ*DISSYZ,DISTMP*NOCCSQ,
     &            DISSYZ*NOCCSQ)
        I001=1
        I002=I001+IINTFP*MSIZE
        I003=I002+IINTFP*MSIZE 
        IF(I003.LT.MXCOR) THEN
C
C   IN CORE ALGORITHM
C
         CALL T12ALL(ICORE(I001),ICORE(I002),ICORE(I003),
     &               ICORE(I0T1),ICORE(I0T2),
     &               DISSYW,DISSYZ,DISTMP,NUMSYW,NUMSYZ,NUMTMP,NOCCSQ,
     &               POP(1,3-ISPIN),POP(1,ISPIN),VRT(1,3-ISPIN),
     &               VRT(1,ISPIN),LISTW,LISTZ,FACT,ITRANS,INCREM,IRREP,
     &               MXCOR-I003)
        ELSE
C
C   SORRY, NO OUT CORE ALGORITHM AVAILABLE
C
         STOP 'T12ALL'
        ENDIF
150    CONTINUE
200   CONTINUE
C 
C     ABAB SPIN CASE SECOND CONTRIBUTION
C
C         - SUM m e T(e,j) T(b,m) <Ae//Im>
C
C         - SUM M E T(E,I) T(A,M) <Eb//mJ>  (UHF ONLY)
C
#ifdef _DEBUG_LVL0
CSSS      IJAB_DEBUG=.FALSE.
CSSS      Write(6,"(a,a)")" @-T2INT2: List 121 and 122 instead of 17 and",
CSSS     +                " 18 is read for <MB||EJ> Ints"
#endif 
      DO 300 ISPIN=1,IUHF+1
C
       FACT=ONE
C
C ONE THE FIRST PASS, INITIALIZE TARGET LIST AND DO NOT TRANSPOSE
C CALCULATED ARRAY, IN THE SECOND PASS, UPDATE TARGET LIST AND
C TRANSPOSE THE RESULT ARRAY
C
       IF(ISPIN.EQ.1) THEN
        I0T1=IOFFT1(1,2)
        I0T2=IOFFT1(1,2)
        ITRANS=0
        INCREM=0
       ELSE
        I0T1=IOFFT1(1,1)
        I0T2=IOFFT1(1,1)
        ITRANS=1
        INCREM=1
       ENDIF
C
C  INTEGRAL AND TARGET LIST
C
       LISTW=19-ISPIN
CSSS       IF (IJAB_DEBUG) LISTW=123-ISPIN
       LISTZ=42
C
       DO 250 IRREP=1,NIRREP
C
        NOCCSQ=0
        DO 245 IRREPJ=1,NIRREP
         IRREPI=DIRPRD(IRREP,IRREPJ)
         NOCCSQ=NOCCSQ+POP(IRREPJ,3-ISPIN)*POP(IRREPI,3-ISPIN)
245     CONTINUE
C
        DISSYW=IRPDPD(IRREP,ISYTYP(1,LISTW))
        NUMSYW=IRPDPD(IRREP,ISYTYP(2,LISTW))
        DISSYZ=IRPDPD(IRREP,ISYTYP(1,LISTZ))
        NUMSYZ=IRPDPD(IRREP,ISYTYP(2,LISTZ))
        IF(ITRANS.EQ.0) THEN
         DISTMP=DISSYZ
         NUMTMP=NUMSYZ
        ELSE
         DISTMP=NUMSYZ
         NUMTMP=DISSYZ
        ENDIF
        MSIZE=MAX(NUMSYW*DISSYW,NUMSYZ*DISSYZ,DISTMP*NOCCSQ,
     &            DISSYZ*NOCCSQ)
        I001=1
        I002=I001+IINTFP*MSIZE
        I003=I002+IINTFP*MSIZE
        IF(I003.LT.MXCOR) THEN
C
C IN CORE ALGORITHM
C
         CALL T12ALL(ICORE(I001),ICORE(I002),ICORE(I003),
     &               ICORE(I0T1),ICORE(I0T2),
     &               DISSYW,DISSYZ,DISTMP,NUMSYW,NUMSYZ,NUMTMP,NOCCSQ,
     &               POP(1,3-ISPIN),POP(1,3-ISPIN),VRT(1,3-ISPIN),
     &               VRT(1,3-ISPIN),LISTW,LISTZ,FACT,ITRANS,INCREM,
     &               IRREP,MXCOR-I003)
        ELSE 
C
C SORRY, NO OUT CORE ALGORITHM
C
         STOP 'T12ALL'
        ENDIF
250    CONTINUE
300   CONTINUE
C
C ALL DONE, RETURN
C
      RETURN
      END
