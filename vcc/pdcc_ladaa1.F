      SUBROUTINE PDCC_LADAA1(W,T,Z,MAXSIZE,DISSYW,NUMSYW,DISSYT,NUMSYT,
     &                  LISTW,LISTT,ITYPE,IRREP,T1,TAU,POP,VRT,
     &                  LISTZ,ELADAA,MODIF,ISPIN)
C
C THIS ROUTINE COMPUTES THE A-A OR B-B LADDER CONTRIBUTIONS.
C
CEND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL TAU
      LOGICAL MBPT3,MBPT4,CC,TRPEND,SNGEND,GRAD,MBPTT,SING1,
     &              QCISD,UCC,CC2
      INTEGER DISSYT,DISSYW,DISLEFT,DISREAD,DISMAX,DIRPRD,POP,VRT
      CHARACTER*2 SPCASE(2)
      CHARACTER*4 MODIF
      DIMENSION W(DISSYW,1),T(DISSYT,NUMSYT)
      DIMENSION Z(DISSYT,NUMSYT),T1(1)
      DIMENSION POP(8),VRT(8) 
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),
     &DIRPRD(8,8)
      COMMON/SWITCH/MBPT3,MBPT4,CC,TRPEND,SNGEND,GRAD,MBPTT,SING1,
     &              QCISD,UCC,CC2
      DATA SPCASE /'AA','BB'/
      DATA ONE,AZERO /1.0D0,0.D0/
#include "parcc.com"
C
C PICK UP THE RELEVANT T2 AND W PIECES. FOR CC2, this should simply
C be T1 * T1 (no tau). 
C
      If (Ispar) Then
         CALL ZERO(T,NUMSYT*DISSYT)
      Else 
         IF (CC2) THEN
            CALL ZERO(T,NUMSYT*DISSYT)
         ELSE
            CALL GETLST(T,1,NUMSYT,1,IRREP,LISTT)
         ENDIF 
      Endif 

      IF(TAU) THEN
       CALL FTAU(T,T1,T1,DISSYT,NUMSYT,POP,POP,
     &           VRT,VRT,IRREP,ISPIN,ONE)
      ENDIF
C
C     MAXIMUM NUMBER OF DISTRIBUTION WHICH CAN BE HELD IN CORE
C
      DISMAX=MAXSIZE/DISSYW
C
C  CAN WE DO IT INCORE ?
C
      IF(DISMAX.GE.NUMSYW) THEN
C
C  INCORE
C
       CALL GETLST(W,1,NUMSYW,2,IRREP,LISTW)
C
C COMPUTE THE LADDER CONTRIBUTION.
C
       IF(ITYPE.EQ.6)THEN
        MODIF='abef'
        CALL XGEMM('N','N',DISSYW,NUMSYT,DISSYT,ONE,W,DISSYW,
     &            T,DISSYT,AZERO,Z,DISSYW)
       ELSEIF(ITYPE.EQ.1)THEN
        CALL XGEMM('N','N',DISSYT,DISSYW,DISSYW,ONE,T,DISSYT,
     &             W,DISSYW,AZERO,Z,DISSYT)
        MODIF='mnij'
       ELSE
        WRITE(6,*)' ITYPE IS ',ITYPE,'!!!'
        CALL ERREX
       ENDIF
      ELSE
C
C   WE HAVE TO DO IT OUT OF CORE
C
       if (NUMSYT*DISSYT.LT.0) call trap_intovf('LADAA1',1)
       CALL ZERO(Z,NUMSYT*DISSYT)
       IOFFSET=1
       DISLEFT=NUMSYW
10     CONTINUE
       DISREAD=MIN(DISMAX,DISLEFT)
       IF(DISREAD.EQ.0) THEN
        WRITE(6,*) ' @-LADAA1-F, no out-of-core algorithm possible.'
        CALL ERREX
       ENDIF
       DISLEFT=DISLEFT-DISREAD
       CALL GETLST(W,IOFFSET,DISREAD,2,IRREP,LISTW)
C
C COMPUTE NOW THE LADDER CONTRIBUTION.
C
       IF(ITYPE.EQ.6) THEN
        MODIF='abef'
        CALL XGEMM('N','N',DISSYW,NUMSYT,DISREAD,ONE,W,DISSYW,
     &             T(IOFFSET,1),DISSYT,ONE,Z,DISSYW)
       ELSEIF(ITYPE.EQ.1)THEN
        MODIF='mnij'
        CALL XGEMM('N','N',DISSYT,DISREAD,DISSYW,ONE,T,DISSYT,
     &             W,DISSYW,ONE,Z(1,IOFFSET),DISSYT)
       ELSE
        WRITE(6,*)' ITYPE IS ',ITYPE,'!!!'
        CALL ERREX
       ENDIF
       IOFFSET=IOFFSET+DISREAD
       IF(DISLEFT.NE.0) GO TO 10
      ENDIF
      ELADAA=SDOT(DISSYT*NUMSYT,Z,1,T,1)+ELADAA
C
C AUGMENT T2 INCREMENT.
C
      CALL SUMSYM2(Z,T,NUMSYT*DISSYT,1,IRREP,LISTZ)
C
      RETURN
      END
