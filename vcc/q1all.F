      SUBROUTINE Q1ALL(W,T,Z,TA,TB,ISPIN,TAU,
     &                  DISSYW,DISSYT,NUMSYW,NUMSYT,
     &                  IRREP,TMP,IRSTART,INTPCK,FACT,UCC)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      LOGICAL TAU,UCC1,ADC2
      LOGICAL MBPT3,MBPT4,CC,TRPEND,SNGEND,GRAD,MBPTT,
     &              SING1,QCISD,UCC,CC2
      INTEGER DISSYT, DISSYW, DIRPRD,POP,VRT
      DIMENSION W(DISSYW,NUMSYW),T(DISSYT,NUMSYT),Z(NUMSYW,NUMSYT)
      DIMENSION TMP(1)
      DIMENSION TA(1),TB(1)
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
      COMMON /SYM/ POP(8,2),VRT(8,2),
     &             NTAA,NTBB,NF1AA,NF1BB,NF2AA,NF2BB
      COMMON/SWITCH/MBPT3,MBPT4,CC,TRPEND,SNGEND,GRAD,MBPTT,
     &              SING1,QCISD,UCC1,CC2
      COMMON /FLAGS/ IFLAGS(100)
      COMMON /FLAGS2/ IFLAGS2(500)

#include "parcc.com"
C
      DATA ZILCH,ONE,TWO /0.0D0,1.D0,2.D0/
C
C      PICK UP FIRST THE RELEVANT T2 AND W PIECES, FOR CC2, this is
C      only T1*T1. 
C
C
C ADC2 check; CALC=MBPT(2),EXCITE=EOMEE,EOMREF=ADC2
C
      ADC2 = .FALSE.
      ADC2 =  (IFLAGS(2) .EQ. 1 .AND. IFLAGS(87) .EQ. 3 .AND.
     &         IFLAGS2(117) .EQ. 10)

      CALL GETLST(W,1,NUMSYW,2,IRREP,13+ISPIN)

CSSS#ifdef _DCC_FLAG
       If (Ispar) Then
#ifdef _DEBUG_LVL0
          Write(6,"(a,F10.5)") "Constructing W(mn,ij). scaling by ",
     &                          Wmnij_scale 
#endif 
          CALL GETLST(T,1,NUMSYT,1,IRREP,43+ISPIN)
          CALL DSCAL(NUMSYT*DISSYT, Wmnij_scale, T, 1)
CSSS#else
       Else
          IF (CC2) THEN
             CALL ZERO(T,NUMSYT*DISSYT)
          ELSE
             CALL GETLST(T,1,NUMSYT,1,IRREP,43+ISPIN)
          ENDIF 
       Endif
CSSS#endif 

      IF(TAU) THEN
       IF(ISPIN.LT.3) THEN
       CALL FTAU(T,TA,TB,DISSYT,NUMSYT,POP(1,ISPIN),POP(1,ISPIN),
     &           VRT(1,ISPIN),VRT(1,ISPIN),IRREP,ISPIN,ONE)
       ELSE
       CALL FTAU(T,TA,TB,DISSYT,NUMSYT,POP(1,1),POP(1,2),VRT(1,1),
     &           VRT(1,2),IRREP,ISPIN,ONE)
       ENDIF
      ENDIF
C
C     INITIALIZE Z BY THE INTEGRALS <IJ||MN>
C
      NLIST1=ISPIN+10 
      NLIST2=ISPIN+50 
      IF(INTPCK.NE.1)THEN
       CALL GETLST(Z,1,NUMSYW,2,IRREP,NLIST1)
       IF(UCC) THEN
        CALL PUTLST(Z,1,NUMSYW,2,IRREP,NLIST2)
        CALL ZERO(Z,NUMSYW*NUMSYT)
       ENDIF
      ELSE
       CALL ZERO(Z,NUMSYW*NUMSYT)
      ENDIF

C NO T2*W terms in Hbar(mn,ij) for ADC2 (like Lin-CCSD)
     
C
C     PERFORM THE MULTIPLICATION IF WE WANT THE INTERMEDIATE.
C
CSSS      Print*, "The W(mn|ab)"
CSSS      CALL OUTPUT(W, 1, DISSYW, 1, NUMSYW, DISSYW, NUMSYW, 1)
CSSS      print*, "The t2(ij,ab)"
CSSS      CALL OUTPUT(T, 1, DISSYT, 1, NUMSYT, DISSYT, NUMSYT, 1)

      IF(INTPCK.NE.0.AND.INTPCK.NE.3 .AND. (.NOT. ADC2))THEN
       CALL XGEMM('T','N',NUMSYW,NUMSYT,DISSYW,FACT,W,DISSYW,T,DISSYT,
     &           ONE,Z,NUMSYW)
        IF(UCC) THEN
          CALL DT(ONE,Z,NUMSYW,NUMSYT,'ADD',Z)
         ENDIF  
      ENDIF
C
C     SAVE THE RESULT ON FILE
C
      IF(UCC.AND.INTPCK.NE.1) THEN
       IF(DISSYW.LT.NUMSYT) STOP 'Q1ALL PS'
       CALL SUMSYM2(Z,W,NUMSYW*NUMSYT,2,IRREP,NLIST2)
      ELSE

CSSS       call checksum("q1all", z, numsyw*numsyt)
       CALL PUTLST(Z,1,NUMSYW,2,IRREP,NLIST2)
      ENDIF
C
      RETURN
      END
