      SUBROUTINE IPDAVID(BUF,BUF3,SCR,MAXCOR,CONVRG,
     &                    NROOT,ISIDE,ISPIN,IUHF,ITER,ITMAX)
C
C DAVIDSON EXTRAPOLATION ROUTINE FOR UNSYMMETRIC MATRICES.  THIS
C APPROACH FOLLOWS THAT OF HIRAO AND NAKATSUJI (J. COMP. PHYS. 45, 246).
C MODIFICATION OF NEXTDAV IN IP-EOM PROGRAM
C THE VECTORS STORED ON DISK ARE AS FOLLOWS:
C
C LISTC  470  - OLD C VECTORS, ONE VECTOR PER LOGICAL RECORD
C LISTHC 471 - OLD HC VECTORS, ONE VECTOR PER LOGICAL RECORD
C LISTH0 472 - DIAGONAL PART OF H, STORED ON ONE LOGICAL RECORD
C
C THESE LISTS ARE USED BY HARD NUMBERS IN CERTAIN PROCEDURES 
C HENCE THEY SHOULD NOT BE MODIFIED.
CEND
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER SIRREP, STMODE, STCALC
      DOUBLE PRECISION TIN, TOUT,TIMDUM
      DOUBLE PRECISION TSSTGEN, TEADAVID, TEADIR
      LOGICAL CONVRG, LEFTHAND, PRINTV, DEGENRCY, ALLOWED
      LOGICAL LOCK,EMINFOL,EVECFOL,PRINT,PRINT2, SINGONLY,
     $    DROPCORE, NEWSTART, WRONGL, PRINTTRN
      LOGICAL LR 
C
      PARAMETER (MAXORD=100)
      PARAMETER (MAXROOT=100)
C
      DIMENSION BUF(MAXORD*(2*MAXORD+3)+5), SCR(MAXCOR)
      DIMENSION BUF3(MAXORD*MAXORD),SJUNK(MAXORD)
C
      COMMON/LISTDAV/LISTC, LISTHC, LISTH0
      COMMON/EXTINF/NDIMR,IOLDEST
      COMMON/EXTINF2/ROOT
      COMMON/EXTINF3/IROOT,LOCROOT,ITROOT
      COMMON/ROOTS/EIGVAL(100,8,3), OSCSTR(100,8,3)
      COMMON/EXTRAP/MAXEXP,NREDUCE,NTOL,NSIZEC
      COMMON/RMAT/ R(10000), P(10000)
      COMMON/CNVRGE/EMINFOL,EVECFOL
      COMMON /SINFO/ NS(8), SIRREP

#include "machsp.com"
#include "sym.com"
#include "sympop.com"
#include "syminf.com"
#include "flags.com"
#include "flags2.com"

      COMMON/STINFO/ITOTALS, STMODE, LISTST, STCALC, NSIZEST
      COMMON/SLISTS/LS1IN, LS1OUT, LS2IN(2,2), LS2OUT(2,2)
      COMMON/IPCALC/LEFTHAND, SINGONLY, DROPCORE
      COMMON/DIPSYM/IRREPDIP(3)
      COMMON /TIMSUB/ TSSTGEN, TEADAVID, TEADIR
      COMMON /TIMEINFO/ TIMEIN, TIMENOW, TIMETOT, TIMENEW
C
      DATA ONE,ONEM,ZILCH,TWO /1.0D0,-1.0D0,0.0D0,2.0D0/
      DATA FACT /27.2113957D0/
      SAVE LOCK, ISTRATEG
C
      INDXF(I,J,N)=I+(J-1)*N
      IGET(I)=1+MOD(IOLDEST+MAXORD-I,MAXORD+1)
C
      CALL TIMER(1)
      IRREPX = SIRREP
C
      NEWSTART = .FALSE.
C
C  INDICATES IF ITERATIVE SUBSPACE SHOULD BE TRUNCATED TO THE
C  ALREADY FOUND EIGENVECTORS ONLY. (USED ONLY IF ITERATIONS
C  SEEM TO GO ASTRAY)
C
      WRONGL = .FALSE.
C
C  IF CONVERGED LEFT HAND EIGENVALUE DOES NOT EQUAL CONVERGED RIGHT
C  HAND EIGENVALUE WRONGL = .TRUE. AND A POSSIBLE TRANSITIONMOMENT
C  IS PUT TO 1.0E20
C
      ALLOWED  = .TRUE.
      NSPECIAL = 18
      IF (LEFTHAND .AND. ALLOWED) THEN
         NSPECIAL = 18
      ENDIF
C
      PRINTV   = .TRUE.
      PRINTTRN = .FALSE.
      PRINT2   = .FALSE.
      PRINT    = .FALSE.
      IF (LEFTHAND) LR = .FALSE.
C
      IF (SINGONLY) THEN
         EXCPTHRS = 0.25
      ELSE
         EXCPTHRS = 0.90
      ENDIF
      THRESH = -100.0
C
C EA ABOVE THRESH ARE SEARCHED FOR, THIS IN CASE OF CORE-EXCITATIONS.
C THRESH SHOULD BE REDUNDANT ONCE EXCP IS IMPLEMENTED.
C
      DEGTOL=10.0D0**(-NTOL)
      ZFACT =ONE/SQRT(TWO)
      IF(NDIMR.EQ.1)THEN
         IOLDEST=1
         LOCK=.FALSE.
      ENDIF
      IONE=1
      ICALC =3 
#ifdef _DEBUG_LVL0
      write(6,*)
      write(6,*) "     ----------------IP-David----------------"
#endif
C
C  ICALC = 3 REFERS TO IP-EOM CALCULATIONS. IT IS NEEDED
C  TO DEFINE THE SPIN-ADAPTATION IN SPNTSING WHICH OCCURS IN
C  A NUMBER OF PROCEDURES, WHICH ARE IDENTICAL TO THE EE-EOM CODE
C
C MOVE MOST RECENT H*C VECTOR TO MOST CURRENT LOCATION.  DO SAME
C FOR C (NECESSARY IF THIS IS THE FIRST ITERATION).
C
      I000 = 1
      I010 = I000 + NSIZEC
      I020 = I010 + NSIZEC
      CALL LOADS_IPVEC(SCR(I000),NSIZEC,ISPIN, IUHF, LS1IN, LS2IN,
     +                 .FALSE.,SCR(I020),MAXCOR-I020+1)

#ifdef _DEBUG_LVL0
      write(6,*) ' current C-vector, before projecting'
      write(6,"(6(1x,F10.5))") (scr(i000+i-1),i=1,nsizec)
      call checksum("S(hhp)  :",scr(i000),nsizec)
#endif 
C
      CALL PUTLST(SCR(I000),IOLDEST,1,1,ISIDE,LISTC)
C
      CALL LOADS_IPVEC(SCR(I000),NSIZEC,ISPIN, IUHF, LS1OUT, LS2OUT,
     +                 .FALSE.,SCR(I020),MAXCOR-I020+1)

#ifdef _DEBUG_LVL0
      write(6,*) ' current HC-vector, before projecting'
      write(6,"(6(1x,F10.5))") (scr(i000+i-1),i=1,nsizec)
      call checksum("S(hhp)  :",scr(i000),nsizec)
#endif 
C
      CALL PUTLST(SCR,IOLDEST,1,1,ISIDE,LISTHC)
C
      IOLDEST=1+MOD(IOLDEST,MAXORD+1)
C
C AUGMENT EXISTING SUBSPACE MATRIX AND OVERLAP MATRIX OF PROJECTED VECTORS
C
      CALL AUGMENTR(SCR, MAXCOR, ISIDE, IUHF, ICALC)
C
C DIAGONALIZE SUBSPACE MATRIX AND DETERMINE NORMS OF PROJECTED EIGENVECTORS
C
      CALL DIAGR(BUF3, BUF, MAXORD, IEVAL, IEVEC, IEXCP,
     $           IEVALSEL,EXCPTHRS,PRINT)
C
C FOLLOW EIGENVECTOR ASSOCIATED WITH LOWEST UNCONVERGED EIGENVALUE
C
C      IF(NDIMR.NE.1)CALL GETREC(20,'JOBARC','LASTVCTR',100*IINTFP,SJUNK)
C
      IF (ISIDE.EQ.2) THEN
       IF(.NOT.LOCK)THEN
            IF(EMINFOL .OR. (NDIMR .EQ. 1))THEN
               CALL FNDMINE(NDIMR,BUF(IEVALSEL),
     $            EIGVAL(1,IRREPX,ISPIN+1-ITOTALS),
     $            SCR, IROOT,Z,ILOC,1.D-3, THRESH)
            ELSEIF(EVECFOL.AND.NDIMR.NE.1)THEN
               CALL FNDMAXS(NDIMR,SJUNK,BUF(IEVEC),NDIMR,
     &            SCR,OVRLAP,ILOC)
            ENDIF


C LOCK ON ROOT IF RELATIVE CHANGE IN EIGENVALUE IS LESS THAN TOLERANCE
C
            IF(ROOT.NE.ZILCH)THEN
               XTEST=ABS((BUF(ILOC)-ROOT)/ROOT)
            ELSE
               XTEST=ABS(BUF(ILOC)-ROOT)
            ENDIF
            IF(ABS(XTEST).LT.1.D-3.AND.ITER.NE.1)THEN
               LOCK=.TRUE.
            ENDIF
      ELSE
C
C LOCK = TRUE
C
            CALL FNDCLOSE(NDIMR, BUF(IEVALSEL), ROOT, XCLOSE, ILOC)
         ENDIF

      ELSE
C
         IF(.NOT.LOCK)THEN
            IF(EMINFOL .OR. (NDIMR .EQ. 1))THEN
               CALL FNDMINE(NDIMR,BUF(IEVALSEL),
     $            EIGVAL(1,IRREPX,ISPIN+1-ITOTALS),
     $            SCR, IROOT,Z,ILOC,1.D-3, THRESH)
            ELSEIF(EVECFOL.AND.NDIMR.NE.1)THEN
               CALL FNDMAXS(NDIMR,SJUNK,BUF(IEVEC),NDIMR,
     &            SCR,OVRLAP,ILOC)
            ENDIF
C
C LOCK ON ROOT IF RELATIVE CHANGE IN EIGENVALUE IS LESS THAN TOLERANCE
C
            IF(ROOT.NE.ZILCH)THEN
               XTEST=ABS((BUF(ILOC)-ROOT)/ROOT)
            ELSE
               XTEST=ABS(BUF(ILOC)-ROOT)
            ENDIF
            IF(ABS(XTEST).LT.1.D-3.AND.ITER.NE.1)THEN
               LOCK=.TRUE.
               WRITE(6,*)' L-O-C-K-I-N-G O-N R-O-O-T '
            ENDIF
         ELSE
C
C LOCK = TRUE
C
            CALL FNDCLOSE(NDIMR, BUF(IEVALSEL), ROOT, XCLOSE, ILOC)
         ENDIF
      ENDIF

      IF(ROOT.NE.ZILCH)THEN
         XTEST=ABS((BUF(ILOC)-ROOT)/ROOT)
      ELSE
         XTEST=ABS(BUF(ILOC)-ROOT)
      ENDIF
      IF((ABS(XTEST).GT.5.D-2) .AND. LOCK) THEN
         WRITE(6,*) ' UNLOCKING ROOT, NOT STABLE YET '
         LOCK=.FALSE.
      ENDIF
C
      IF(NDIMR.EQ.1)THEN
         CALL ZERO(SJUNK,NDIMR+1)
         ILOC=1
         CALL SCOPY(NDIMR,BUF(IEVEC+(ILOC-1)*NDIMR),1,SJUNK(2),1)
C     CALL PUTREC(20,'JOBARC','LASTVCTR',100*IINTFP,SJUNK)
      ENDIF
C
      IBUFLC=IEVEC-1+INDXF(1,ILOC,NDIMR)
      ROOT=BUF(ILOC)
      EXCPOVRL = BUF(IEXCP+ILOC-1)
C
C  POSITION OF SOUGHT FOR EIGENVECTOR IN BUF
C
      OVRLAP=SDOT(NDIMR,SJUNK,1,BUF(IBUFLC),1)
C
      CALL FNDCLOSE(NDIMR, BUF, ZILCH, XZERO, IDUM)
      IF(ABS(XZERO).LT.1.0D-5)THEN
         WRITE(6,*)' SUBSPACE EIGENVALUES CLOSE TO ZERO !!'
      ENDIF
C
      CALL ZERO(SJUNK,NDIMR+1)
      CALL SCOPY(NDIMR,BUF(IBUFLC),1,SJUNK(2),1)
C     CALL PUTREC(20,'JOBARC','LASTVCTR',100*IINTFP,SJUNK)
C
C CALCULATE RESIDUAL : [H C(new) - E C(new)]
C
      CALL RESVEC(SCR, MAXCOR, BUF, MAXORD, ISIDE, IBUFLC)
C
      I000 = 1
      I010 = I000 + NSIZEC
      I020 = I010 + NSIZEC
C
C  FIND THE LARGEST COMPONENT IN THE ERROR VECTOR (ON SCR(I000))
C
      CALL FNDMAXD(NSIZEC, SCR(I000), DIFF, IOLD,RMS)
C
      IF((DIFF.GT.DEGTOL) .AND. (ITER .LT. ITMAX)) THEN
         CONVRG=.FALSE.
C
C FIND NEW TRIAL VECTOR BY APPLYING THE DAVIDSON CORRECTION. SAVE THE 
C ERROR VECTOR IN CASE DAVIDSON CORRECTION LEADS TO LINEAR DEPENDENCIES.
C
         CALL PUTLST(SCR(I000), 7, 1, 1, 1, LISTH0)
         CALL GSORTHOG_IP(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &      SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     &      RESID,ICALC) 
         IF (ABS(1.0D0-RESID) .GT. 1.0D-10) THEN
            WRITE(6,'(A,E12.6)')' TROUBLES ANTICIPATED ',
     $         (1.0D0 - RESID)
         ENDIF
         IF (MOD(ITER, NSPECIAL) .NE. 0) THEN
            
            CALL GETLST(SCR(I000),7,1,1,1,LISTH0)
            CALL GETLST(SCR(I010),1,1,1,1,LISTH0)

            IF(NDIMR .NE.1) CALL VECDIV2(ROOT,SCR(I000),SCR(I010),
     &                                   SCR(I000),NSIZEC)
#ifdef _DEBUG_LVL0
      write(6,*)
      write(6,"(a)") "@-ipdavid-guess vecs after vecdiv2"
      write(6,"(6(1x,F10.5))") (scr(i000+i-1),i=1,nsizec)
#endif 
C
C SCHMIDT ORTHOGONALIZE NEW BASIS VECTOR TO EXISTING SPACE.
C
            CALL GSORTHOG_IP(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &         SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     &         RESID,ICALC) 
         ELSE
            WRITE(6,*) ' ITERATION VECTOR BASED ON UNSCALED RESIDUE'
         ENDIF
#ifdef _DEBUG_LVL0
      write(6,*)
      write(6,"(a)") "@-ipdavid-guess vecs after gsorthg"
      write(6,"(6(1x,F10.5))") (scr(i000+i-1),i=1,nsizec)
#endif 

      WRITE(6,5000)ITER,NDIMR,ROOT,DIFF, IOLD
C
      IF (RESID .GT. 0.05) THEN
         ISTRATEG = 0
      ELSE
        WRITE(6,'(1X,A,E12.3)')' LINEAR DEPENDANCY DETECTED: ', RESID
C
        IF (ISTRATEG .EQ. 0) THEN
           WRITE(6,*) ' ONE MORE ITERATION IN USUAL WAY'
           ISTRATEG = ISTRATEG + 1
        ELSEIF (ISTRATEG .EQ. 1) THEN
           CALL GETLST(SCR(I000), 7, 1, 1, 1, LISTH0)
           CALL GSORTHOG_IP(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &           SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     &           RESID,ICALC) 
           WRITE(6,'(1X,A,E12.3)') ' TRIAL BASED ON UNSCALED RESIDUE',
     $           RESID
           ISTRATEG = ISTRATEG + 1
        ELSEIF (ISTRATEG .EQ. 3) THEN
           CALL DUALRES(SCR, MAXCOR, IRREPX, ISIDE,
     $         IUHF, ISPIN)
           CALL GSORTHOG_IP(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &           SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     $           RESID,ICALC) 
           WRITE(6,'(1X,A,E12.3)') ' NEW TRIAL BASED ON DUAL RESIDUAL ',
     $     RESID
           ISTRATEG = ISTRATEG+1
        ELSEIF (ISTRATEG .EQ. 2) THEN
          CALL DUALRES(SCR, MAXCOR, IRREPX, ISIDE,
     $           IUHF, ISPIN)
          CALL GETLST(SCR(I010),1,1,1,1,LISTH0)
          CALL VECDIV2(ROOT,SCR(I000),SCR(I010),
     $           SCR(I000),NSIZEC)
          CALL GSORTHOG_IP(IRREPX,NSIZEC,NDIMR,SCR(I000),
     $           SCR(I010),SCR(I020),ISIDE,LISTC,IUHF.EQ.0,
     $           IOLDEST,MAXORD,RESID,ICALC)
          WRITE(6,'(1X,A,E12.3)')'TRIAL BASED ON SCALED DUAL RESIDUAL ',
     $         RESID
           ISTRATEG = ISTRATEG + 1
        ENDIF
        ENDIF

        IF (ISTRATEG .GT. 1) ISTRATEG = 0
C
C  NEW ITERATION VECTOR CONSTRUCTED, CONVRG = .FALSE. HAS BEEN 
C  DEALT WITH. NEXT CONSIDER CONVRG = .TRUE.
C
      ELSE
C
         if ((iter .eq. ITMAX) .and. (diff .gt. degtol)) then
            write(6,*) ' iter =29: Fake convergence '
            IF (DIFF .GT. 1.0E-2) THEN
               NEWSTART = .TRUE.
               write(6,*) ' DAVIDSON PROCEDURE IS RESTARTED'
            ENDIF
         endif
C         WRITE(6,5000)ITER,NDIMR,ROOT,ABS(OVRLAP),DIFF, IOLD
         WRITE(6,5000)ITER,NDIMR,ROOT,DIFF, IOLD
         CONVRG=.TRUE.
         IROOT=IROOT+1
C
         IF (ISIDE.EQ.1) THEN
C
C WRITE OUT SOME INFO ON ROOT FOUND
C     
            write(6,1300)
            WRITE(6,*)' CONVERGED EIGENVALUE:  ',root,' A.U.'
            WRITE(6,*)'                        ',root*fact,' eV'
            EIGVAL(IROOT,IRREPX,ISPIN+1-ITOTALS)=ROOT
            CALL GETREC(20,'JOBARC','TOTENERG',IINTFP,ECC)
            WRITE(6,99)ECC+ROOT
 99    FORMAT(' TOTAL IP-EOM-CCSD ELECTRONIC ENERGY',F15.8,' A.U.')
            CALL PUTREC(20,'JOBARC','TOTENER2',IINTFP,ECC+ROOT)
C
C CHECK ON POSSIBLE DEGENERACY
C
            IF (IROOT.EQ.1) THEN
               DEGENRCY = .FALSE.
            ELSE
               CALL FNDCLOSE(IROOT-1,EIGVAL(1,IRREPX,ISPIN+1-ITOTALS),
     $            ROOT,TEST,ITEST)
               IF (ABS(ROOT - TEST) .LT. DEGTOL) THEN
            WRITE(6,*) ' CURRENT ROOT IS DEGENERATE WITH ROOT ',ITEST
                  OSCSTR(IROOT, IRREPX,ISPIN+1-ITOTALS) = 1.0D30
                  DEGENRCY = .TRUE.
               ELSE
                  DEGENRCY = .FALSE.
               ENDIF
            ENDIF
C
         ELSE
            write(6,1300)
            WRITE(6,*)' CONVERGED EIGENVALUE:  ',root,' A.U.'
            WRITE(6,*)'                        ',root*fact,' eV'
            EIGVAL(IROOT,IRREPX,ISPIN+1-ITOTALS)=ROOT
            CALL GETREC(20,'JOBARC','TOTENERG',IINTFP,ECC)
            WRITE(6,99)ECC+ROOT
            CALL PUTREC(20,'JOBARC','TOTENER2',IINTFP,ECC+ROOT)

C            IF (ABS(EIGVAL(IROOT,IRREPX,ISPIN+1-ITOTALS) - ROOT)
C     $         .GT. 5.0D-3) THEN'jjj
C               WRITE(6,*)' WARNING !!! LEFT AND RIGHT ROOT',
C     $            ' ARE NOT EQUAL !'
C               WRONGL = .TRUE.
C            ENDIF
         ENDIF
C
C PUT CONVERGED VECTOR ON LISTH0
C
         CALL FORMS(NSIZEC,NDIMR,SCR(I000),SCR(I010),BUF(IBUFLC),
     &      ISIDE,LISTC,IOLDEST,MAXORD)
         CALL NORMVEC(SCR(I000), NSIZEC, SCR(I010), MAXCOR-I010+1,
     $      IUHF, ICALC, SIRREP)
C     
         IF (PRINTV) THEN
            WRITE(6,1300)
            CALL PUTS_HHP(SCR(I000), NSIZEC, ISPIN, IUHF, LS1OUT,
     &                    LS2OUT)
#ifdef _DEBUG_LVLM
           write(6,"(a)") "@-ipdavid-converged vectors"
           Call Check_ipvecs(Iuhf,Ispin,scr,Maxcor,Ls1out,Ls2out)
#endif 
            WRITE(6,*)' EIGENVECTOR COMPONENTS IROOT =', IROOT
            CALL PRMAINS_IP(IUHF, ISPIN, SCR(I010), MAXCOR-I010+1)
         ENDIF
C
         IF(LEFTHAND)THEN
            IF (.NOT. ALLOWED) THEN
               WRITE(6,1300)
               WRITE(6,*) ' TRANSITION IS NOT ALLOWED '
               OSCSTR(IROOT, SIRREP, ISPIN+1-ITOTALS) = 0.0D0
            ELSE IF (NEWSTART) THEN
               WRITE(6,1300)
               WRITE(6,*) ' TRANSITION MOMENT IS NOT CALCULATED',
     $            ' BECAUSE'
               WRITE(6,*) ' OF POOR QUALITY CURRENT EIGENVECTOR'
               OSCSTR(IROOT, SIRREP, ISPIN+1-ITOTALS) = 1.0D20
            ELSE
               IF(ISIDE.EQ.1)THEN
                  IF(PRINT)THEN
                     CALL BLKCPY2(R,MAXORD,MAXORD,BUF3,
     $                  NDIMR,NDIMR,1,1)
                     WRITE(6,1106)
 1106                FORMAT(T3,'@NEXTDAV-I, righthand subspace H: ')
                     CALL OUTPUT(BUF3,1,NDIMR,1,NDIMR,NDIMR,NDIMR,1)
                  ENDIF
                  CALL PUTLST(SCR(I000),1+ISIDE,1,1,1,LISTH0)
CSSS                  CALL PUTREC(20,'JOBARC','RIGHTDIM',IONE,NDIMR)
CSSS                  CALL PUTREC(20,'JOBARC','RIGHTOLD',IONE,IOLDEST)
               ELSEIF (ISIDE.EQ.2) THEN
                  IF(PRINT)THEN
                     CALL BLKCPY2(R,MAXORD,MAXORD,BUF3,
     $                  NDIMR,NDIMR,1,1)
                     WRITE(6,1107)
 1107                FORMAT(T3,'@NEXTDAV-I, lefthand subspace H: ')
                     CALL OUTPUT(BUF3,1,NDIMR,1,NDIMR,NDIMR,NDIMR,1)
                  ENDIF
                  CALL PUTLST(SCR(I000),1+ISIDE,1,1,1,LISTH0)
                  WRITE(6,1300)
                  IF (LR) CALL NORML_IP(SCR(I010), MAXCOR-I010+1,
     $                                  IUHF,ISPIN)
C   Transition moments !!!
                  CALL PUTREC(20,'JOBARC','LEFTDIM',IONE,NDIMR)
                  CALL PUTREC(20,'JOBARC','LEFTOLD',IONE,IOLDEST)
                  ITROOT=ITROOT+1
               ENDIF
            ENDIF
         ENDIF
C
         IF (LEFTHAND.AND.ALLOWED.AND.(ISIDE.EQ.1).AND.
     $      (.NOT.DEGENRCY) .AND. (.NOT. NEWSTART)) THEN
C
            CALL INITLEFT(BUF, BUF3, SCR, MAXCOR, IUHF.EQ.0,
     $                    SIRREP, ICALC)
            LOCK = .FALSE.
            IROOT=IROOT-1
            ISIDE=2     
            IF (IROOT .EQ. 0) THEN
               CALL ZERO(R,MAXORD*MAXORD)
               NDIMR = 0
               WRITE(6,1300)
            WRITE(6,'(1X,A,E12.5)') ' STARTING LEFT HAND VECTOR',
     $            ROOT               
               WRITE(6,1300)
            ELSE
C
C RESTORE EXISTING LEFT VECTOR EXPANSION SPACE FOR NEXT ROOT
C
               CALL GETREC(20,'JOBARC','LEFTDIM',IONE,NDIMR)
               CALL GETREC(20,'JOBARC','LEFTOLD',IONE,IOLDEST)
C
C INSERT
               CALL REFORM(R,P,SCR(I010),NDIMR,NSIZEC,IRREPX,
     $            MAXCOR-I010+1, ISIDE,IUHF,ICALC)
               IF (NDIMR .EQ. MAXEXP) THEN
               CALL DIAGR(BUF3, BUF, MAXORD,IEVAL,IEVEC,IEXCP,
     $               IEVALSEL,EXCPTHRS,PRINT2)
               ENDIF
               IF(PRINT)THEN
                  CALL BLKCPY2(R,MAXORD,MAXORD,BUF3,NDIMR,NDIMR,1,1)
                  WRITE(6,1108)
 1108     FORMAT(T3,'@NEXTDAV-I, recovered lefthand subspace H: ')
                  CALL OUTPUT(BUF3,1,NDIMR,1,NDIMR,NDIMR,NDIMR,1)
               ENDIF
C
C  FINISH STARTING VECTOR FOR LEFTHAND
C
               CALL GSORTHOG_IP(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     $            SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     $            RESID,ICALC) 
               WRITE(6,1300)
        WRITE(6,'(1X,A,2E12.5)') ' STARTING LEFT HAND VECTOR',
     $            ROOT,RESID
               WRITE(6,1300)
               IF (RESID .LT. 0.1) THEN
       WRITE(6,'(1X,A,E12.3)') 'LIN. DEP. IN INITIAL LEFT HAND '
               CALL DIAGR(BUF3, BUF, MAXORD, IEVAL, IEVEC, IEXCP,
     $                 IEVALSEL,EXCPTHRS,.false.)
               ROOTR = EIGVAL(IROOT+1,IRREPX,ISPIN+1-ITOTALS)
               CALL FNDLEFT(NDIMR,ROOTR,BUF(IEVALSEL),
     $            EIGVAL(1,IRREPX,ISPIN+1-ITOTALS),
     $            SCR,IROOT, Z, ILOC, 1.0D-3, THRESH)
               ROOT=BUF(ILOC)
               IBUFLC=IEVEC-1+INDXF(1,ILOC,NDIMR)
               CALL RESVEC(SCR, MAXCOR, BUF, MAXORD, ISIDE, IBUFLC)
               CALL GETLST(SCR(I010),1,1,1,1,LISTH0)
               CALL VECDIV2(ROOT,SCR(I000),SCR(I010),SCR(I000),NSIZEC)
               CALL GSORTHOG_IP(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &            SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     &            RESID,ICALC)
         WRITE(6,'(1X,A,2E12.5)') ' NEW GUESS: ROOT, RESID', ROOT,RESID
               ENDIF
            ENDIF
C
         ELSEIF (IROOT .LT. NROOT) THEN
C
C ADD NEW VECTOR TO SPACE
C
            LOCK=.FALSE.
            IF (ISIDE.EQ.2) THEN
               ISIDE = 1
C
C RESTORE EXISTING RIGHT VECTOR EXPANSION SPACE FOR NEXT ROOT
C
CSSS               CALL GETREC(20,'JOBARC','RIGHTDIM',IONE,NDIMR)
CSSS               CALL GETREC(20,'JOBARC','RIGHTOLD',IONE,IOLDEST)
               CALL REFORM(R,P,SCR,NDIMR,NSIZEC,IRREPX,MAXCOR,
     $            ISIDE,IUHF,ICALC)
               IF ((NDIMR .EQ. MAXEXP) .OR. (NEWSTART)) THEN
               CALL DIAGR(BUF3, BUF, MAXORD,IEVAL,IEVEC,IEXCP,
     $               IEVALSEL,EXCPTHRS,print)
               ENDIF
               IF(PRINT)THEN
                  CALL BLKCPY2(R,MAXORD,MAXORD,BUF3,NDIMR,NDIMR,1,1)
                  WRITE(6,1105)
 1105       FORMAT(T3,'@NEXTDAV-I, recovered righthand subspace H: ')
                  CALL OUTPUT(BUF3,1,NDIMR,1,NDIMR,NDIMR,NDIMR,1)
               ENDIF
            ENDIF
C
C LOAD GUESS FOR NEXT VECTOR
C
C  THE INITIAL GUESS IS BASED ON THE DIAGONAL ELEMENTS OF H0
C
            I000 = 1
            I010 = I000 + NSIZEC
            I020 = I010 + NSIZEC
            CALL GETLST(SCR(I000), 4,1,1,1, LISTH0)
            CALL FNDMINE(NSIZEC, SCR(I000),
     $         EIGVAL(1, IRREPX,ISPIN+1-ITOTALS),
     $         SCR(I010),0, ROOT, ILOC, 1.D-4, THRESH)
            SCR(ILOC) = 1.0D30
            CALL PUTLST(SCR(I000), 4, 1,1,1, LISTH0)        
            CALL ZERO(SCR,NSIZEC)
            SCR(ILOC) = ONE
            CALL NORMVEC(SCR(I000), NSIZEC, SCR(I010), MAXCOR-I010+1,
     $         IUHF, ICALC, SIRREP)
C
C  THIS GUESS MAY ALSO BE USED FOR LEFTHAND, AND IS PUT ON 
C  COLUMN 3 OF LISTH0
C
        CALL PUTLST(SCR(I000),3,1,1,1,LISTH0)
C
            WRITE(6,1300)
C
C  ORTHOGONALIZE GUESS TO ALL PRECEDING VECTORS
C
            CALL GSORTHOG_IP(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &         SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     $         RESID,ICALC)
C     
            WRITE(6,'(1X,A,2E12.6,I6)')' GUESS FOR NEXT EIGENVALUE ',
     $         ROOT, RESID, ILOC
            WRITE(6,1300)
C
            IF ((RESID .LT. 1.E-1)) THEN
        WRITE(6,'(1X,A,E12.3)')' LIN. DEP. FOR INITIAL ESTIMATE '
C     
C  Find best new eigenvector in existing space
C
            IF (LEFTHAND) THEN
              CALL DIAGR(BUF3,BUF,MAXORD,IEVAL,IEVEC,IEXCP,
     $            IEVALSEL,EXCPTHRS,PRINT2)
            ENDIF
            CALL FNDMINE(NDIMR,BUF(IEVALSEL),
     $         EIGVAL(1,IRREPX,ISPIN+1-ITOTALS),
     $         SCR, IROOT,Z,ILOC,1.D-3, THRESH)
            ROOT=BUF(ILOC)
            IBUFLC=IEVEC-1+INDXF(1,ILOC,NDIMR)
            CALL RESVEC(SCR, MAXCOR, BUF, MAXORD, ISIDE, IBUFLC)
            CALL GETLST(SCR(I010),1,1,1,1,LISTH0)
            CALL VECDIV2(ROOT,SCR(I000),SCR(I010),SCR(I000),NSIZEC)
            CALL GSORTHOG_IP(IRREPX,NSIZEC,NDIMR,SCR(I000),SCR(I010),
     &         SCR(I020),ISIDE,LISTC,IUHF.EQ.0,IOLDEST,MAXORD,
     &         RESID,ICALC)
            WRITE(6,'(1X,A,2E12.5)') ' NEW GUESS: ROOT, RESID',
     $         ROOT, RESID
         ENDIF
C
         ENDIF
      ENDIF
C
      CALL PUTS_HHP(SCR(I000),NSIZEC,ISPIN, IUHF, LS1IN, LS2IN)
#ifdef _DEBUG_LVL0
      write(6,*)
      write(6,"(a)") "@-ipdavid-guess vecs 4next iter?-3"
      write(6,"(6(1x,F10.5))") (scr(i000+i-1),i=1,nsizec)
CSSS      if (iuhf.eq.0) call check_ab2aa(scr(i000),nsizec,
CSSS     &                    scr(i020),maxcor-i020,1)
#endif
C
C TRUNCATE EXPANSION SPACE IF WE HAVE REACHED THAT POINT
C
      IF ((NDIMR.EQ.MAXEXP) .OR. NEWSTART) THEN
         CALL ZERO(R,MAXORD*MAXORD)
         write(6,1300)
         write(6,*) ' maximum expansion space reached: truncate !'
         if (NREDUCE.EQ.0) then
            CALL FORMS(NSIZEC,NDIMR,SCR(I000),SCR(I020),BUF(IBUFLC),
     &         ISIDE,LISTC,IOLDEST,MAXORD)
            CALL NORMVEC(SCR(I000), NSIZEC, SCR(I010), MAXCOR-I010+1,
     $         IUHF, ICALC, SIRREP)
            CALL PUTS_HHP(SCR(I000),NSIZEC,ISPIN, IUHF, LS1IN, LS2IN)
            NDIMR = 0
            IOLDEST = 1
         else
            I000 = 1
            I010 = I000 + NREDUCE
            I020 = I010 + NSIZEC * NREDUCE
            IF (SINGONLY) THEN
               IE = IEVAL
            ELSE
               IE = IEVALSEL
            ENDIF
            IF (NEWSTART) THEN
               WRITE(6,*) ' NEW STARTING OF DAVIDSON PROCEDURE'
               WRITE(6,*) ' ONLY CONVERGED EIGENVECTORS ARE RETAINED',
     $            IROOT
               IF (ISIDE .EQ. 1) THEN
                  NDIMIN = IROOT + 1
               ELSE
                  NDIMIN = IROOT + 2
               ENDIF
            ELSE
               NDIMIN = NREDUCE
            ENDIF
            NDIMNEW = NDIMIN
C
C  IN PRINCIPLE NDIMNEW WILL EQUAL NDIMIN, HOWEVER IF TOO FEW
C  REAL EIGENVALUES ARE AVAILABLE THEN NDIMNEW WILL BE
C  EQUAL TO THE NUMBER OF REAL EIGENVALUES.
C
            CALL TRUNCATE(BUF(IE),BUF(IEVEC),SCR(I000),SCR(I010),
     $         SCR(I020),MAXCOR-I020+1,NSIZEC,NDIMR,NDIMNEW,.FALSE.,
     $         IRREPX,ISIDE,ISPIN, IUHF, ICALC)
            IF (NDIMNEW .NE. NDIMIN) THEN
               WRITE(6,*) ' THE SPACE IS TRUNCATED FURTHER BECAUSE NOT',
     $        ' ENOUGH REAL EIGENVALUES WERE FOUND', NDIMIN, NDIMNEW
            ENDIF
            IOLDEST=NDIMNEW+1
            CALL REFORM(R,P,SCR,NDIMNEW,NSIZEC,IRREPX,
     $         MAXCOR,ISIDE,IUHF,ICALC)
         ENDIF
         NDIMR=NDIMNEW
         CALL DIAGR(BUF3, BUF, MAXORD, IEVAL, IEVEC, IEXCP,
     $      IEVALSEL,EXCPTHRS,PRINT2)

#ifdef _DEBUG_LVLM
         write(6,1300)
         WRITE(6,*)' EIGENVALUES AFTER TRUNCATION'
         CALL OUTPUT(BUF(IEVAL),1,1,1,NDIMR,1,NDIMR,1)
         write(6,1300)
         WRITE(6,*)' OVERLAPS WITH EXCITATION PATTERN AFTER TRUNCATION'
         CALL OUTPUT(BUF(IEXCP),1,1,1,NDIMR,1,NDIMR,1)
         write(6,1300)
#endif 
      ENDIF
C
C MOVE R AND P MATRICES
C
      DO 50 I=NDIMR,1,-1
         DO 51 J=NDIMR,1,-1
            R(INDXF(I+1,J+1,MAXORD))=R(INDXF(I,J,MAXORD))
            P(INDXF(I+1,J+1,MAXORD))=P(INDXF(I,J,MAXORD))
 51      CONTINUE
 50   CONTINUE
C     
      CALL TIMER(1)      
      TEADAVID = TEADAVID + TIMENEW
      RETURN
 1300 FORMAT(/)
 5000 FORMAT(T4,I4,T13,I4,T21,D14.7,T36,D13.6,4X,I8)
      END
