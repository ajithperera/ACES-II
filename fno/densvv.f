       SUBROUTINE DENSVV(DVV,ICORE,MAXCOR,UHF)
C
C
C THIS ROUTINE CALCULATES THE VIRTUAL-VIRTUAL BLOCK
C OF THE RELAXED DENSITY MATRIX IN CORRELATION METHODS
C
C THE FORMULAS ARE
C
C D(A,B) = 1/2 SUM M,N,E T[1](MN,AE) T[1](MN,BE)              (MBPT(2))
C
C D(A,B) = 1/2 SUM M,N,E T[1](MN,AE) T[1](MN,BE)            
C
C          + SUM M T[1](M,A) T[1](M,B)                        (ROHF-MBPT(2))
C 
C 
C THERE ARE THE FOLLOWING SPIN TYPES TO CONSIDER
C
C          D(AB)                T(MN,AE),....
C
C          AA                   AAAA, ABAB
C
C          BB                   BBBB, BABA
C
C THIS SUBROUTINE USES EXPLICITELY SYMMETRY
C
C THE TRIPLES CONTRIBUTION IS CALCULATED IN TRPS AND HERE SIMPLY
C ADDED TO THE REMAINING TERMS.
C
C IN THE RHF CASE EXPLICIT SPIN ADAPTED CODE IS USED
C
CEND
C
C CODED   JULY/90    JG
C
C EXTENDED FOR ROHF-MBPT(3), DECEMBER 92
      IMPLICIT NONE
C     COMMON BLOCKS
      INTEGER POP(8,2),VRT(8,2),NT(2),NF1(2),NF2(2)
      COMMON/SYM/POP,VRT,NT,NF1,NF2
      INTEGER NOCCO(2),NVRTO(2)
      COMMON/INFO/NOCCO,NVRTO
      INTEGER IINTLN,IFLTLN,IINTFP
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP
      logical rohf
      common/fnoparam/rohf
      INTEGER NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON/SYMINF/NSTART,NIRREP,IRREPS,DIRPRD
      INTEGER IRPDPD(8,22),ISYTYP(2,500)
      COMMON/SYMPOP/IRPDPD,ISYTYP
C     INPUT VARIABLES
      INTEGER UHF,MAXCOR
C     OUTPUT VARIABLES
      DOUBLE PRECISION DVV(*)
C     PRE-ALLOCATED LOCAL VARIABLES
      INTEGER ICORE(MAXCOR)
C     LOCAL VARIABLES
      INTEGER DISSYT,IFLAG,LISTT1,LISTT2,LISTT3,LISTT4,LISTT5,NVRT,NOCC,
     &   IOFF,I001,I002,I003,I004,I005,NVRT2SQ,NUMSYT,IRREPJ,I0T3B,
     &   IOFFT1,IRREP,IOFFD,IOFFT2,I0T2A,I0T1A,MXCOR,I0T2B,SPIN,I0T3A,
     &   I0T1B
      DOUBLE PRECISION FACT,ONE,TWO,ONEM,HALF
      DATA ONE,TWO,ONEM,HALF /1.0D0,2.0D0,-1.0D0,0.5D0/
C----------------------------------------------------------------------------     
      MXCOR=MAXCOR
C
C CONTRIBUTIONS DUE TO SINGLE EXCITATIONS
C
      IF(ROHF) THEN
C     
C ALLOCATE MEMORY FOR T1 AMPLITUDES
C
         I0T1A=MXCOR+1-NT(1)*IINTFP
         MXCOR=MXCOR-NT(1)*IINTFP
         CALL GETLST(ICORE(I0T1A),1,1,1,1,90)
C     
         I0T2A=I0T1A
C
         I0T1B=I0T2A-NT(2)*IINTFP
         MXCOR=MXCOR-NT(2)*IINTFP
         CALL GETLST(ICORE(I0T1B),1,1,1,2,90)
C
         I0T2B=I0T1B
C
C PERFORM MULTIPLICATION:    SUM M   T(M,A) L(M,B)
C
C   FACT IS HERE ALWAYS ONE
C
         FACT=ONE
C
         DO 300 SPIN=1,UHF+1
C
            IF(SPIN.EQ.1) THEN
               IOFFT1=I0T1A
               IOFFT2=I0T2A
               IOFFD=1
            ELSE
               IOFFT1=I0T1B
               IOFFT2=I0T2B
               IOFFD=1+NF2(1)
            ENDIF
C 
            DO 250 IRREP=1,NIRREP
C     
               NOCC=POP(IRREP,SPIN)
               NVRT=VRT(IRREP,SPIN)
               IF(MIN(NVRT,NOCC).GT.0) THEN
                  CALL XGEMM('N','T',NVRT,NVRT,NOCC,FACT,ICORE(IOFFT1),
     &               NVRT,ICORE(IOFFT2),NVRT,ONE,DVV(IOFFD),NVRT)
               ENDIF
               IOFFT1=IOFFT1+NOCC*NVRT*IINTFP
               IOFFT2=IOFFT2+NOCC*NVRT*IINTFP
               IOFFD=IOFFD+NVRT*NVRT
 250        CONTINUE
 300     CONTINUE
C
      ENDIF
C
C CONTRIBUTION DUE TO DOUBLES
C
C    RESET MXCOR
C
      MXCOR=MAXCOR 
C
C LOOP OVER SPIN CASES (SPIN=1: ALPHA DENSITY MATRIX, =2: BETA DENSITY MATRIX)
C
      DO 1000 SPIN=1,UHF+1
C
         IF(SPIN.EQ.1) THEN
            IOFF=1
         ELSE
            IOFF=NF2(1)+1
         ENDIF
         IF(UHF.EQ.1) THEN
C
C  CONTRIBUTION DUE TO AAAA OR BBBB AMPLITUDES (IS SKIPPED FOR RHF)
C
C NOTE SOME FURTHER LOGICAL STUFF HERE
C
C MBPT2 LISTT1 IS EQUAL TO LISTT2 (DON'T READ IT TWICE)
C
            LISTT1=43+SPIN
            LISTT2=43+SPIN
            FACT=ONE
            IFLAG=1

C
C
C LOOP OVER IR REPS OF MN BLOCK (THE SAME IRREPS AS THE AF AND EF BLOCKS C HAVE
C
            DO 100 IRREP=1,NIRREP
C
C DETERMINE LENGTH OF EXPANDED VIRTUAL-VIRTUAL BLOCK
C
               NVRT2SQ=0
               DO 110 IRREPJ=1,NIRREP
                  NVRT2SQ=NVRT2SQ+VRT(IRREPJ,SPIN)*
     &               VRT(DIRPRD(IRREPJ,IRREP),SPIN)
 110           CONTINUE
C     
               DISSYT=IRPDPD(IRREP,ISYTYP(1,LISTT1))
               NUMSYT=IRPDPD(IRREP,ISYTYP(2,LISTT1)) 
               I001=1
               I002=I001+IINTFP*NUMSYT*NVRT2SQ
               I003=I002+IINTFP*NUMSYT*NVRT2SQ
               I004=I003+IINTFP*NUMSYT*DISSYT
               IF(MIN(NUMSYT,DISSYT).NE.0) THEN
                  IF(I004.LT.MXCOR) THEN
C  
C         IN CORE VERSION
C
                     CALL DVVAA(ICORE(I001),ICORE(I002),ICORE(I003),
     &                  DVV(IOFF),FACT,SPIN,POP(1,SPIN),VRT(1,SPIN),
     &                  DISSYT,NUMSYT,LISTT1,LISTT2,LISTT3,IRREP,IFLAG)
                  ELSE
                     CALL INSMEM('DVVAA',I004,MXCOR)
                  ENDIF
               ELSE
               ENDIF      
 100        CONTINUE
         ENDIF
C     
C       AB SPIN CASE
C
         LISTT1=46
         LISTT2=46
         FACT=ONE
         IFLAG=1
C     
C     LOOP OVER IRREPS.
C
         DO 200 IRREP=1,NIRREP
C
            DISSYT=IRPDPD(IRREP,ISYTYP(1,46))
            NUMSYT=IRPDPD(IRREP,ISYTYP(2,46))
            I001=1
            I002=I001+IINTFP*NUMSYT*DISSYT
            I003=I002+IINTFP*NUMSYT*DISSYT
            I004=I003
            IF(MIN(NUMSYT,DISSYT).NE.0) THEN
               I005=I004+3*IINTFP*MAX(DISSYT,NUMSYT)
               IF(I005.LE.MXCOR) THEN
C
C         IN CORE VERSION
C
                  CALL DVVAB(ICORE(I001),ICORE(I002),ICORE(I003),
     &               DVV(IOFF),FACT,SPIN,POP(1,SPIN),POP(1,3-SPIN),
     &               VRT(1,SPIN),VRT(1,3-SPIN), DISSYT,NUMSYT,LISTT1,
     &               LISTT2,LISTT3,IRREP,ICORE(I004),UHF,IFLAG)  
               ELSE
                  CALL INSMEM('DVVAB',I005,MXCOR)
               ENDIF
            ELSE
C     
C     
            ENDIF
 200     CONTINUE
C
 1000 CONTINUE
      RETURN
      END
