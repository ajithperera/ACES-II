      SUBROUTINE SMICAN(FOCK,SCR1,SCR2,SCR3,SCR4,SCR5,EVEC,EVAL,
     &                  POP,VRT,SCR,OSCR2,NBAS,LDIM1,LDIM3,NIRREP,
     &                  ISPIN)
C
C THIS SUBROUTINE PERFORMS A TRANSFORMATION TO SEMICANONICAL ORBITALS,
C  WHICH ARE DEFINED BY
C
C             F(IJ) = 0 (I.NE.J)
C             F(AB) = 0 (A.NE.B)
C             F(AI) UNAFFECTED
C
C THE FOCK MATRIX WHICH IS PASSED IN MUST BE IN THE ORTHOGONAL BASIS.
C
CEND
      IMPLICIT INTEGER (A-Z)
C
      CHARACTER*1 SP(2)
      CHARACTER*8 WLABEL(2,2)
      LOGICAL SEMI
      DOUBLE PRECISION FOCK,SCR1,SCR2,SCR3,SCR4,SCR5,EVEC,ONE,ZILCH,EVAL
      DOUBLE PRECISION SCR,OSCR2
      DIMENSION FOCK(1),SCR1(1),SCR2(1),SCR3(1),EVEC(1),EVAL(1)
      DIMENSION SCR4(1),SCR5(1),SCR(1),OSCR2(1)
      DIMENSION POP(NIRREP),VRT(NIRREP)
C
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /FLAGS/ IFLAGS(100)
C
      DATA ONE /1.0/
      DATA ZILCH /0.0/
      DATA WLABEL /'WMATRXOA','WMATRXVA','WMATRXOB','WMATRXVB'/
      DATA SP /'A','B'/
C
      NNP1O2(I)=(I*(I+1))/2
C
C TRANSFORM AO BASIS FOCK MATRIX TO THE ORTHOGONAL BASIS
C
      SEMI=.FALSE.
      IF(IFLAGS(39).EQ.1) SEMI=.TRUE.
      LENGTH=0
      DO 222 I=1,NIRREP
       LENGTH=LENGTH+NNP1O2(POP(I)+VRT(I))
222   CONTINUE
      CALL PUTREC(20,'JOBARC','FOCK    ',LENGTH*IINTFP,FOCK)
      CALL FAO2MO(FOCK,EVEC,SCR2,SCR3,POP,VRT,NIRREP)
      IF(SEMI) THEN
        CALL ZERO(SCR,NBAS*NBAS)
        CALL MKFULL(SCR,EVEC,OSCR2,LDIM1,LDIM3,NBAS,0)
        CALL PUTREC(20,'JOBARC','ROHFEVC'//SP(ISPIN),NBAS*NBAS*IINTFP,
     &              SCR)
        CALL ZERO(SCR,NBAS*NBAS)
        CALL SCOPY(NBAS,FOCK,NBAS+1,SCR,1)
        CALL PUTREC(20,'JOBARC','ROHFEVL'//SP(ISPIN),NBAS*IINTFP,SCR)
      ENDIF
C
      IPOS=1
      IOFFF=1
      IOFFE=1
      IOFFEVL=1
C
C LOOP OVER IRREPS
C
      IOFFWO=1
      IOFFWV=1
      DO 10 IRREP=1,NIRREP
       NOCC=POP(IRREP)
       NVRT=VRT(IRREP)
       NSIZ=NOCC+NVRT
       CALL EXPND2(FOCK(IOFFF),SCR1,NSIZ)
#ifdef _DEBUG_LVL0
      Write(6,*) "The MO basis FOCK matrix in standard orbitals"
      call output(Scr1, 1, NSIZ, 1, NSIZ, NSIZ, NSIZ, 1)
#endif
C
C DIAGONALIZE OCCUPIED-OCCUPIED BLOCK OF FOCK MATRIX
C
       CALL BLKCPY2(SCR1,NSIZ,NSIZ,SCR2,NOCC,NOCC,1,1)
       CALL EIG(SCR2,SCR3,NOCC,NOCC,0)
       CALL SCOPY(NOCC*NOCC,SCR3,1,SCR4(IOFFWO),1)
       IOFFWO=IOFFWO+NOCC*NOCC
       CALL SCOPY(NOCC,SCR2,NOCC+1,EVAL(IOFFEVL),1)
#ifdef _DEBUG_LVLM1
       Write(6,*)
       Write(6,*) "The occ-occ eigenvalues"
       Write(6,"(6F12.8)") (EVAL(IOFFEVL - 1+k),k=1,nocc)
#endif 
       IOFFEVL=IOFFEVL+NOCC
C
C NOW USE EIGENVECTORS TO ROTATE MOLECULAR ORBITALS
C
       CALL XGEMM('N','N',NSIZ,NOCC,NOCC,ONE,EVEC(IOFFE),NSIZ,
     &            SCR3,NOCC,ZILCH,SCR2,NSIZ)
       CALL SCOPY(NSIZ*NOCC,SCR2,1,EVEC(IOFFE),1)
C
       IOFFE=IOFFE+NSIZ*NOCC
C
C NOW DIAGONALIZE VIRTUAL-VIRTUAL BLOCK OF FOCK MATRIX
C
       CALL BLKCPY2(SCR1,NSIZ,NSIZ,SCR2,NVRT,NVRT,NOCC+1,NOCC+1)
       CALL EIG(SCR2,SCR3,NVRT,NVRT,0)
       CALL SCOPY(NVRT*NVRT,SCR3,1,SCR5(IOFFWV),1)
       IOFFWV=IOFFWV+NVRT*NVRT
       CALL SCOPY(NVRT,SCR2,NVRT+1,EVAL(IOFFEVL),1)
#ifdef _DEBUG_LVLM1
       Write(6,*)
       Write(6,*) "The vrt-vrt eigenvalues"
       Write(6,"(6F12.8)") (EVAL(IOFFEVL - 1+k),k=1,nvrt)
#endif 
       IOFFEVL=IOFFEVL+NVRT
       CALL XGEMM('N','N',NSIZ,NVRT,NVRT,ONE,EVEC(IOFFE),NSIZ,
     &            SCR3,NVRT,ZILCH,SCR2,NSIZ)
       CALL SCOPY(NSIZ*NVRT,SCR2,1,EVEC(IOFFE),1)
C
       IOFFE=IOFFE+NSIZ*NVRT
C
       IOFFF=IOFFF+NNP1O2(NSIZ)
       IPOS=IPOS+NVRT+NOCC
10    CONTINUE
C
C  Now dump the canonical to semi-canonical transformation matrices.
C
      IF(SEMI) THEN
        CALL PUTREC(20,'JOBARC',WLABEL(1,ISPIN),(IOFFWO-1)*IINTFP,SCR4)
        CALL PUTREC(20,'JOBARC',WLABEL(2,ISPIN),(IOFFWV-1)*IINTFP,SCR5)
      ENDIF
C
      CALL GETREC(20,'JOBARC','FOCK    ',LENGTH*IINTFP,FOCK)
      RETURN
      END
