      SUBROUTINE DORPP(IERROR,FOCK,DENS,SOVRLP,ERR,SCR1,SCR2,SCR3,
     &                 SCRA,SCRB,SCRTMP,LDIM1,LDIM2,LDIM3,LDIM4,
     &                 LDIMA,LDIMB,NBAS,ITER,IUHF,TOL,NOCONV)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
      DIMENSION FOCK((IUHF+1)*LDIM1),DENS((IUHF+1)*LDIM1)
      DIMENSION SOVRLP(NBAS*NBAS)
      DIMENSION ERR((IUHF+1)*LDIM2),IERROR(LDIM3)
      DIMENSION SCR1(LDIM4),SCR2(LDIM4),SCR3(LDIM4)
      DIMENSION SCRA(LDIMA),SCRB(LDIMB),SCRTMP(LDIM4)
      DIMENSION IADERR(200),IADFCK(200,2)
      LOGICAL NOCONV,rohf
      DOUBLE PRECISION MAX_ERROR
C
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /FILES/ LUOUT,MOINTS
      COMMON /FLAGS/ IFLAGS(100)
#include "symm2.com"
      COMMON /RPPINF/ ISTART,IORDER,IADERR,IADFCK
C
      DATA ONE /1.0D0/
      DATA ONEM /-1.0D0/
C
      NNP1O2(I)=(I*(I+1))/2
C
      IUHF2=IUHF
      rohf=iflags(11).eq.2
      CALL GETREC(20,'JOBARC','AOOVRLAP',NBAS*NBAS*IINTFP,SOVRLP)
      if (rohf) then
        iuhf2=0
        CALL GETREC(20,'JOBARC','MOVECTOR',ISQRLN(NIRREP+1)*IINTFP,
     &             ERR)
        call FAO2MOROHF(FOCK,SOVRLP,ERR,SCR1,SCR2,NBAS,.TRUE.)
      endif
      CALL ZERO(ERR,(1+IUHF)*LDIM2)
      DO 100 ISPIN=1,(IUHF+1)
        DO 101 I=1,NIRREP
          IF(NBFIRR(I).EQ.0) GOTO 101
          CALL GETBLK(SOVRLP,SCR1,NBFIRR(I),NBAS,IREPS(I))
          if (rohf) then
            CALL EXPND2(FOCK(ITRIOF(I)),SCR2,NBFIRR(I))
          else
            CALL EXPND2(FOCK((ISPIN-1)*LDIM1+ITRIOF(I)),SCR2,NBFIRR(I))
          endif
          CALL EXPND2(DENS((ISPIN-1)*LDIM1+ITRIOF(I)),SCR3,NBFIRR(I))
C
C  Now form FOCK*DENS*AOOVERLAP  { F*D*S }
C
          CALL MXM(SCR2,NBFIRR(I),SCR3,NBFIRR(I),SCRTMP,NBFIRR(I))
          CALL MXM(SCRTMP,NBFIRR(I),SCR1,NBFIRR(I),SCRA,NBFIRR(I))
C
C  Now form AOOVERLAP*DENS*FOCK  { S*D*F }
C
          CALL MXM(SCR1,NBFIRR(I),SCR3,NBFIRR(I),SCRTMP,NBFIRR(I))
          CALL MXM(SCRTMP,NBFIRR(I),SCR2,NBFIRR(I),SCRB,NBFIRR(I))
C
C  Now form F*D*S - S*D*F
C
          CALL SAXPY(ISQRLN(I),ONEM,SCRB,1,SCRA,1)
          CALL SAXPY(ISQRLN(I),ONE,SCRA,1,ERR(ISQROF(I)),1)
  101   CONTINUE
  100 CONTINUE
C
C  Now put this error matrix and the Fock matrix in the correct
C  location.
C
      IF(MOD(ITER,IORDER).EQ.0) THEN
        IERRLOC=IORDER
      ELSE
        IERRLOC=MOD(ITER,IORDER)
      ENDIF
c YAU : old
c     CALL ICOPY(ISQRLN(NIRREP+1)*IINTFP,ERR,1,IERROR(IADERR(IERRLOC)),1)
c YAU : new
      CALL DCOPY(ISQRLN(NIRREP+1),ERR,1,IERROR(IADERR(IERRLOC)),1)
c YAU : end
C
C  Now deal with the Fock matrix.
C
      CALL ZERO(ERR,LDIM2*(1+IUHF2))
        DO 220 ISPIN=1,(IUHF2+1)
          DO 221 I=1,NIRREP
            IADRER=ISQROF(I)+(ISPIN-1)*LDIM2
            CALL EXPND2(FOCK((ISPIN-1)*LDIM1+ITRIOF(I)),SCR1,NBFIRR(I))
c YAU : old
c           CALL ICOPY(ISQRLN(I)*IINTFP,SCR1,1,ERR(IADRER),1)
c YAU : new
            CALL DCOPY(ISQRLN(I),SCR1,1,ERR(IADRER),1)
c YAU : end
  221     CONTINUE
          ISTART=1+(ISPIN-1)*LDIM2
c YAU : old
c         CALL ICOPY(ISQRLN(NIRREP+1)*IINTFP,
c    &               ERR(ISTART),1,IERROR(IADFCK(IERRLOC,ISPIN)),1)
c YAU : new
          CALL DCOPY(ISQRLN(NIRREP+1),
     &               ERR(ISTART),1,IERROR(IADFCK(IERRLOC,ISPIN)),1)
c YAU : end
  220   CONTINUE
C
C  Now update ISTART.
C
      IF(ITER.GT.IORDER) ISTART=IERRLOC+1
      IF(ISTART.GT.IORDER) ISTART=1
C 
C  Now call the real meat of the RPP routine . . .
C
C The full squared out Fock matrix is returned in ERR.
C
      CALL RPP(IERROR,ERR,SCRA,SCRB,NBFIRR,NIRREP,ITER,
     &         ISQRLN(NIRREP+1),IUHF2)    
c     CALL RPP2(IERROR,ERR,SCRA,SCRB,NBFIRR,NIRREP,ITER,
c    &         ISQRLN(NIRREP+1),IUHF2)
        DO 230 ISPIN=1,(IUHF2+1)
          DO 231 I=1,NIRREP
            CALL SQUEZ2(ERR((ISPIN-1)*LDIM2+ISQROF(I)),
     &                   FOCK((ISPIN-1)*LDIM1+ITRIOF(I)),NBFIRR(I))
  231     CONTINUE
  230   CONTINUE
999   continue
      if (iflags(11).eq.2) then
        CALL GETREC(20,'JOBARC','MOVECTOR',ISQRLN(NIRREP+1)*IINTFP,
     &             ERR)
        call FAO2MOROHF(FOCK,SOVRLP,ERR,SCR1,SCR2,NBAS,.FALSE.)
      endif
      RETURN
      END
