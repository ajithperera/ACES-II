      SUBROUTINE T3IT_TRPS14(OOOV,OOOV2,GOOOV,BUF,EVAL,
     &                       IADBLK,LENBLK,IADT2,LENT2,
     &                       IADV,LENV, OOOVAD,LENINT,LNOOOV,
     &                       ICORE,NFREE,IUHF,ISPIN,NO,NV,INT1,INT2,
     &                       NONHF,T3STOR,INIT)
      IMPLICIT INTEGER (A-Z)
#include "maxbasfn.par"
C
C The three most relevant papers for all of the standard triple
C excitation methods: Watts et al., JCP, 98, 8718, 1993 (JCP2)
C
      LOGICAL INT1,INT2,NONHF,INIT
      LOGICAL IJKEQL,IJEQL,JKEQL,NONEQL
      LOGICAL CCSDT4,CCSDT,LCCSD_T
      LOGICAL TRIPNI,TRIPNI1,TRIPIT,T3STOR
      DOUBLE PRECISION ALPHA
      DOUBLE PRECISION DIJK,DOOA,DOOB,DVVA,DVVB,DDOT,E_test
      DOUBLE PRECISION EVAL(NO+NV)
      DOUBLE PRECISION E14,E2AAB,E2BBA
C     ijka integrals/intermediates used in D3T3 = WT2
      DOUBLE PRECISION OOOV(LNOOOV),BUF(NO*(NO-1)/2)
C     ijka integrals/intermediates used in D2T2 = WT3 (includes 1b)
      DOUBLE PRECISION OOOV2(LNOOOV)
      DIMENSION OOOVAD(8),LENINT(8)
C
      DOUBLE PRECISION GOOOV(LNOOOV)
      DOUBLE PRECISION ICORE(1)
C
      DIMENSION LEN(8,8),IADBLK(8),LENBLK(8)
      DIMENSION                        IADT2(8) ,LENT2(8),
     1                                 IADV(8)  ,LENV(8)
      DIMENSION POPT3(8)
C
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
      COMMON /SYM/    POP(8,2),VRT(8,2),NTAA,NTBB,NF1AA,NF2AA,
     1                NF1BB,NF2BB
      COMMON /INFO/   NOCCO(2),NVRTO(2)
      COMMON /FLAGS/  IFLAGS(100)
C
C     TRIPLES COMMON BLOCKS
C
      COMMON /T3OFF/  IOFFVV(8,8,10),IOFFOO(8,8,10),IOFFVO(8,8,4)
      COMMON /ACTORB/ ABSVRT(MAXBASFN,8,2),ABSOCC(MAXBASFN,8,2)
      COMMON /LISWI/  LWIC11,LWIC12,LWIC13,LWIC14,
     1                LWIC15,LWIC16,LWIC17,LWIC18,
     1                LWIC21,LWIC22,LWIC23,LWIC24,
     1                LWIC25,LWIC26,LWIC27,LWIC28,
     1                LWIC31,LWIC32,LWIC33,
     1                LWIC34,LWIC35,LWIC36,
     1                LWIC37,LWIC38,LWIC39,LWIC40,LWIC41,LWIC42
      COMMON /T3IOOF/ IJKPOS(8,8,8,2),IJKLEN(36,8,4),IJKOFF(36,8,4),
     1                NCOMB(4)
      COMMON /EDEBUG/ E14, E2AAB, E2BBA
C
      INDEX(I) = I*(I-1)/2
C
      IF(ISPIN.EQ.1)THEN
      NT1 = NTAA
      ELSE
      NT1 = NTBB
      ENDIF
C
C     MAIN CORE VECTOR ADDRESSING
C
      E_test=0.0D0
      IM90 = 1
      IM80 = IM90 + NT1
      IM70 = IM80 + NT1
      IM60 = IM70 + NT1
      IM50 = IM60 + NT1
C
      IF(ISPIN.EQ.1)THEN
      WRITE(6,1015)
 1015 FORMAT(' @TRPS14-I, Spin case AAA ')
      ELSE
      WRITE(6,1020)
 1020 FORMAT(' @TRPS14-I, Spin case BBB ')
      ENDIF
C
C     INITIALIZE T1 INCREMENTS
C
      CALL ZERO(ICORE(IM90),NT1)
C
C     INITIALIZE "F" INCREMENTS
C
      CALL ZERO(ICORE(IM70),NT1)
C
C     GET EIGENVALUES
C
      IF(ISPIN.EQ.1)THEN
      CALL GETREC(20,'JOBARC','SCFEVALA',(NO+NV)*IINTFP,EVAL)
      ELSE
      CALL GETREC(20,'JOBARC','SCFEVALB',(NO+NV)*IINTFP,EVAL)
      ENDIF
C
C     Compute (B<C,A) lengths for given IRPIJK (=IRPABC)
C
      DO   90 IRPIJK=1,NIRREP
      DO   80 IRPA  =1,NIRREP
      IRPBC = DIRPRD(IRPIJK,IRPA)
      LEN(IRPA,IRPIJK) = IRPDPD(IRPBC,ISPIN) * VRT(IRPA,ISPIN)
   80 CONTINUE
   90 CONTINUE
C
C     COMPUTE LENGTHS OF SYMMETRY PACKED ABC TRIPLES FOR EACH
C     IRREP
C
      DO  220 IRREP=1,NIRREP
      POPT3(IRREP) = 0
  220 CONTINUE
C
      DO 233 IRPC=1,NIRREP
      DO 232 IRPB=1,IRPC
      DO 231 IRPA=1,IRPB
      IRPBC  = DIRPRD(IRPB,IRPC)
      IRPABC = DIRPRD(IRPA,IRPBC)
C
C     Compute length of the block. There are four possible cases.
C
      IF(IRPA.EQ.IRPB.AND.IRPB.EQ.IRPC)THEN
      LENGTH = (VRT(IRPC,ISPIN) * (VRT(IRPC,ISPIN) - 1) *
     1                            (VRT(IRPC,ISPIN) - 2)) / 6
      ENDIF
C
      IF(IRPA.EQ.IRPB.AND.IRPB.NE.IRPC)THEN
      LENGTH = (VRT(IRPC,ISPIN) *  VRT(IRPB,ISPIN)      *
     1                            (VRT(IRPB,ISPIN) - 1)) / 2
      ENDIF
C
      IF(IRPA.NE.IRPB.AND.IRPB.EQ.IRPC)THEN
      LENGTH = (VRT(IRPC,ISPIN) * (VRT(IRPC,ISPIN) - 1) *
     1                             VRT(IRPA,ISPIN)    )  / 2
      ENDIF
C
      IF(IRPA.NE.IRPB.AND.IRPB.NE.IRPC)THEN
      LENGTH =  VRT(IRPC,ISPIN) *  VRT(IRPB,ISPIN)      *
     1                             VRT(IRPA,ISPIN)
      ENDIF
C
      POPT3(IRPABC) = POPT3(IRPABC) + LENGTH
  231 CONTINUE
  232 CONTINUE
  233 CONTINUE
C

      DO  240 IRREP=1,NIRREP
C     WRITE(6,1200) IRREP,POPT3(IRREP)
  240 CONTINUE
 1200 FORMAT(' @TRPS14-I, IRREP, A<B<C POPULATION ',I4,I10)
C
C     COMPUTE ADDRESSES FOR BLOCKS OF OOOV INTEGRALS. PRESENTLY
C     THESE ARE HELD IN CORE.
C
      DO  250 IRREP=1,NIRREP
      LENINT(IRREP) = IRPDPD(IRREP,2+ISPIN) * IRPDPD(IRREP,15+ISPIN)
  250 CONTINUE
C
      OOOVAD(1) = 1
      IF(NIRREP.GT.1)THEN
      DO  260 IRREP = 2,NIRREP
      OOOVAD(IRREP) = OOOVAD(IRREP-1) + LENINT(IRREP-1)
  260 CONTINUE
      ENDIF
C      WRITE(6,1210)
 1210 FORMAT(' @TRPS14-I, OOOV ARRAY LENGTHS AND ADDRESSES ')
      DO  270 IRREP=1,NIRREP
C      WRITE(6,1220) IRREP,LENINT(IRREP),OOOVAD(IRREP)
 1220 FORMAT(' IRREP, LENGTH, ADDRESS ',I4,I6,I6)
  270 CONTINUE
C
      IF(ISPIN.EQ.1)THEN
      LISTWO = LWIC11
      ELSE
      LISTWO = LWIC12
      ENDIF
C
      DO  280 IRREP=1,NIRREP
      CALL GETTRN(OOOV(OOOVAD(IRREP)),BUF,IRPDPD(IRREP,2+ISPIN),
     1            IRPDPD(IRREP,15+ISPIN),2,IRREP,LISTWO)
  280 CONTINUE
C
C For INT2 set to false and this should not go here. Keept for
C consistency.

      IF(INT2)THEN
C
      IF(ISPIN.EQ.1)THEN
      DO  281 IRREP=1,NIRREP
      CALL GETTRN(OOOV2(OOOVAD(IRREP)),BUF,IRPDPD(IRREP,2+ISPIN),
     1            IRPDPD(IRREP,15+ISPIN),2,IRREP,LWIC21)
  281 CONTINUE
      ELSE
      DO  282 IRREP=1,NIRREP
      CALL GETTRN(OOOV2(OOOVAD(IRREP)),BUF,IRPDPD(IRREP,2+ISPIN),
     1            IRPDPD(IRREP,15+ISPIN),2,IRREP,LWIC22)
  282 CONTINUE
      ENDIF
C
      ENDIF

C     COMPUTE THE NUMBER OF FREE DOUBLE WORDS (YUK !)

      MCORE = NFREE / IINTFP
      WRITE(6,1230) NFREE,MCORE,IINTFP
 1230 FORMAT(' @TRPS14-I, Number of free integer words ',I10,/,
     1       '            Number of free double words  ',I10,/,
     1       '            Ratio                        ',I10)
C
#ifdef _DEBUG_LVL0
      E4T14  = 0.0D+00
      E5ST14 = 0.0D+00
#endif 
C

      DO IRPIJK=1,NIRREP
C
C The orginal IJKVAL =  0 is wrong. This variable never get updated
C before it is used. So, set it to 1 instead. Ajith Perera, 09/2006.
C 
C This is incorrect.  Need to be updating ijkval as it cycles through
C IJKVAL should start at 0 and then be added to after D1T14
C Andrew Taube 12/2009

C     IJKVAL = 1
      IJKVAL = 0
C
      DO  IRPK=1,NIRREP
      IF(POP(IRPK,ISPIN).EQ.0) GOTO 990
      DO   IRPJ=1,IRPK
      IRPJK = DIRPRD(IRPJ,IRPK)
      IRPI  = DIRPRD(IRPJK,IRPIJK)
      IRPIJ =  DIRPRD(IRPI,IRPJ)
      IRPIK =  DIRPRD(IRPI,IRPK)
C
      IF(IRPI.GT.IRPJ.OR.POP(IRPI,ISPIN).EQ.0.OR.
     &                   POP(IRPJ,ISPIN).EQ.0) GOTO 980
C
      IF(IRPI.EQ.IRPJ.AND.
     &   IRPI.EQ.IRPK.AND.POP(IRPK,ISPIN).LT.3) GOTO 980

      IF(IRPJ.EQ.IRPK.AND.POP(IRPK,ISPIN).LT.2) GOTO 980
      IF(IRPI.EQ.IRPJ.AND.POP(IRPJ,ISPIN).LT.2) GOTO 980
C
      IJKEQL = .FALSE.
      IJEQL  = .FALSE.
      JKEQL  = .FALSE.
      NONEQL = .FALSE.
      IF(IRPI.EQ.IRPJ.AND.IRPI.EQ.IRPK) IJKEQL = .TRUE.
      IF(IRPJ.EQ.IRPK.AND.IRPI.NE.IRPK)  JKEQL = .TRUE.
      IF(IRPI.EQ.IRPJ.AND.IRPI.NE.IRPK)  IJEQL = .TRUE.
      IF(IRPI.NE.IRPJ.AND.IRPI.NE.IRPK.AND.IRPJ.NE.IRPK) NONEQL = .TRUE.
C
      IF(IJKEQL)THEN
      NIJ = (POP(IRPK,ISPIN) * (POP(IRPK,ISPIN)-1))/2
      NIK = (POP(IRPK,ISPIN) * (POP(IRPK,ISPIN)-1))/2
      NJK = (POP(IRPK,ISPIN) * (POP(IRPK,ISPIN)-1))/2
      ENDIF
C
      IF(JKEQL)THEN
      NIJ = POP(IRPI,ISPIN) * POP(IRPJ,ISPIN)
      NIK = POP(IRPI,ISPIN) * POP(IRPK,ISPIN)
      NJK = (POP(IRPK,ISPIN) * (POP(IRPK,ISPIN)-1))/2
      ENDIF
C
      IF(IJEQL)THEN
      NIJ = (POP(IRPJ,ISPIN) * (POP(IRPJ,ISPIN)-1))/2
      NIK = POP(IRPI,ISPIN) * POP(IRPK,ISPIN)
      NJK = POP(IRPJ,ISPIN) * POP(IRPK,ISPIN)
      ENDIF
C
      IF(NONEQL)THEN
      NIJ = POP(IRPI,ISPIN) * POP(IRPJ,ISPIN)
      NIK = POP(IRPI,ISPIN) * POP(IRPK,ISPIN)
      NJK = POP(IRPJ,ISPIN) * POP(IRPK,ISPIN)
      ENDIF
C
C     COMPUTE ADDRESSES AND LENGTHS OF ABC SYMMETRY BLOCKS FOR
C     THIS IJK. THIS LOOP IS EFFECTIVELY OVER IRREPS OF A (IE
C     COLUMNS OF THE EVENTUAL TARGET).
C
      DO  300 IRREP=1,NIRREP
      IF(IRREP.EQ.1)THEN
      IADBLK(IRREP) = 1
      ELSE
      IADBLK(IRREP) = IADBLK(IRREP-1) + LEN(IRREP-1,IRPIJK)
      ENDIF
      LENBLK(IRREP) = LEN(IRREP,IRPIJK)
  300 CONTINUE
C
      LENABC=0
      DO  310 IRREP=1,NIRREP
      LENABC = LENABC + LENBLK(IRREP)
  310 CONTINUE
C

C     IM50 is t3(a<b<c)
      I000 = IM50 + POPT3(IRPIJK)
      I010 = I000 + LENABC
C
C     SET ADDRESSES FOR T2 VECTORS
C
      I020 = I010 + IRPDPD(IRPIJ,ISPIN) * NIJ
      I030 = I020 + IRPDPD(IRPIK,ISPIN) * NIK
      I040 = I030 + IRPDPD(IRPJK,ISPIN) * NJK
C
C     DETERMINE DISTRIBUTION SIZES FOR EXPANDED T2 VECTORS
C
      DSZEIJ = IRPDPD(IRPIJ,18+ISPIN)
      DSZEIK = IRPDPD(IRPIK,18+ISPIN)
      DSZEJK = IRPDPD(IRPJK,18+ISPIN)
C
      I050 = I040 + DSZEIJ * NIJ
      I060 = I050 + DSZEIK * NIK
      I070 = I060 + DSZEJK * NJK
C
C     READ T2 VECTORS (NEED OFFSETS IN EACH IRREP_IOFFOO FROM OTHER
C     ROUTINES SHOULD SUFFICE).
C
      CALL GETLST(ICORE(I010),IOFFOO(IRPJ,IRPIJ,ISPIN)+1,
     1            NIJ,1,IRPIJ,43+ISPIN)
      CALL GETLST(ICORE(I020),IOFFOO(IRPK,IRPIK,ISPIN)+1,
     1            NIK,1,IRPIK,43+ISPIN)
      CALL GETLST(ICORE(I030),IOFFOO(IRPK,IRPJK,ISPIN)+1,
     1            NJK,1,IRPJK,43+ISPIN)
C
C     EXPAND T2 VECTORS
C
      CALL SYMEXP2(IRPIJ,VRT(1,ISPIN),DSZEIJ,IRPDPD(IRPIJ,ISPIN),
     1             NIJ,ICORE(I040),ICORE(I010))
      CALL SYMEXP2(IRPIK,VRT(1,ISPIN),DSZEIK,IRPDPD(IRPIK,ISPIN),
     1             NIK,ICORE(I050),ICORE(I020))
      CALL SYMEXP2(IRPJK,VRT(1,ISPIN),DSZEJK,IRPDPD(IRPJK,ISPIN),
     1             NJK,ICORE(I060),ICORE(I030))
C
C     SET ADDRESSES FOR TRANSPOSED BLOCKS OF OOOV INTEGRALS (USED FOR
C     INCLUSION OF T3 IN T2 (T2T314O).
C
      LNVOIJ = IRPDPD(IRPIJ,8+ISPIN)
      LNVOIK = IRPDPD(IRPIK,8+ISPIN)
      LNVOJK = IRPDPD(IRPJK,8+ISPIN)
      I080 = I070 + LNVOIJ * NIJ
      I090 = I080 + LNVOIK * NIK
      I100 = I090 + LNVOJK * NJK
C
C     DO THE OUT-OF-PLACE TRANSPOSITIONS.
C
      IF(INT2)THEN
C
      CALL SYMTRA2(IRPIJ,POP(1,ISPIN),VRT(1,ISPIN),LNVOIJ,NIJ,
     1             OOOV2(OOOVAD(IRPIJ) + 
     1                  IOFFOO(IRPJ,IRPIJ,ISPIN) * LNVOIJ),
     1             ICORE(I070))
      CALL SYMTRA2(IRPIK,POP(1,ISPIN),VRT(1,ISPIN),LNVOIK,NIK,
     1             OOOV2(OOOVAD(IRPIK) + 
     1                  IOFFOO(IRPK,IRPIK,ISPIN) * LNVOIK),
     1             ICORE(I080))
      CALL SYMTRA2(IRPJK,POP(1,ISPIN),VRT(1,ISPIN),LNVOJK,NJK,
     1             OOOV2(OOOVAD(IRPJK) + 
     1                  IOFFOO(IRPK,IRPJK,ISPIN) * LNVOJK),
     1             ICORE(I090))
      ENDIF
C
      I110 = I100 + POPT3(IRPIJK)
      I120 = I110 + IRPDPD(IRPJK,ISPIN)
      I130 = I120 + IRPDPD(IRPIK,ISPIN)
      I140 = I130 + IRPDPD(IRPIJ,ISPIN)
      I150 = I140 + POPT3(IRPIJK)
      ISTART = I150
      NLEFT = MCORE - ISTART
C
C The following memory test is not correct. We use ICORE(ISTART) 
C to store quantities of length (a<b,c) for gradients and iterative
C triples. This might be the cause of mysterious crashes of large
C triples gradient calculations for low symmetry molecules.
C Ajith Perera 11/2005.
CSSS      IF(ISTART.GE.MCORE)THEN
CSSS      WRITE(6,9010)
CSSS      CALL INSMEM('TRPS14',ISTART,MCORE)
CSSS      ENDIF

      IF (ISTART+LENABC.GE.MCORE) THEN
         WRITE(6,9010)
 9010 FORMAT(' @TRPS14-I, Insufficient memory to continue. ')
         CALL INSMEM('TRPS14',ISTART+LENABC,MCORE)
      END IF
C
C     FORM ABC DENOMINATOR FOR THIS IJK SYMMETRY BLOCK.
C
      CALL MKD314(ICORE(I100),EVAL,ISPIN,NO,NV,IRPIJK,POPT3)
C
      IF(NONEQL)THEN
      KLOW  = 1
      KHIGH = POP(IRPK,ISPIN)
      JLOW  = 1
      JHIGH = POP(IRPJ,ISPIN)
      ILOW  = 1
      IHIGH = POP(IRPI,ISPIN)
      ENDIF
C
      IF(IJKEQL)THEN
      KLOW  = 3
      KHIGH = POP(IRPK,ISPIN)
      JLOW  = 2
      ILOW  = 1
      ENDIF
C
      IF(IJEQL)THEN
      KLOW  = 1
      KHIGH = POP(IRPK,ISPIN)
      JLOW  = 2
      JHIGH = POP(IRPJ,ISPIN)
      ILOW  = 1
      ENDIF
C
      IF(JKEQL)THEN
      KLOW  = 2
      KHIGH = POP(IRPK,ISPIN)
      JLOW  = 1
      ILOW  = 1
      IHIGH = POP(IRPI,ISPIN)
      ENDIF
C
      DO  K=KLOW,KHIGH
C
      IF(IJKEQL.OR.JKEQL) JHIGH = K-1
      DO  J=JLOW,JHIGH
C
      IF(IJKEQL.OR.IJEQL) IHIGH = J-1
      DO  I=ILOW,IHIGH
C
      CALL ZERO(ICORE(I000),LENABC)
      CALL ZERO(ICORE(IM50),POPT3(IRPIJK))
C
C Compute the T3(ijk,abc)= T2(ij,{le}a)<bc||{le}k> 
c
      CALL D1T14(ICORE(I000),ICORE(I040),ICORE(I050),ICORE(I060),
     & OOOV(OOOVAD(IRPIJ) + 
     &      IOFFOO(IRPJ,IRPIJ,ISPIN)*IRPDPD(IRPIJ,15+ISPIN)),
     & OOOV(OOOVAD(IRPIK) + 
     &      IOFFOO(IRPK,IRPIK,ISPIN)*IRPDPD(IRPIK,15+ISPIN)),
     & OOOV(OOOVAD(IRPJK) + 
     &      IOFFOO(IRPK,IRPJK,ISPIN)*IRPDPD(IRPJK,15+ISPIN)),
     &           ICORE(ISTART),ISPIN,
     &           IADBLK,LENBLK,IADT2,LENT2,IADV,LENV,
     &           I,J,K,IRPI,IRPJ,IRPK,IRPIJ,IRPIK,IRPJK,IRPIJK,
     &           DSZEIJ,DSZEIK,DSZEJK,
     & IRPDPD(IRPIJ,15+ISPIN),IRPDPD(IRPIK,15+ISPIN),
     & IRPDPD(IRPJK,15+ISPIN),NLEFT,.FALSE.)

C Update IJKVAL (see comment at start of loop 1000)
      IJKVAL = IJKVAL + 1

C Skip these two contribution for the starting T3 GUess.

      IF (.NOT. INIT) THEN
C
C     CCSD(T) non-HF calculations without semicanonical orbitals.
C     (i) Virtual orbital sum.
C
      CALL T3FT314V(ICORE(I000),ICORE(ISTART),NFREE,ISPIN,POPT3(IRPIJK),
     1              LENABC,IRPIJK,IJKVAL,IADBLK)
C
C     Convert the a<b;c T3 to a<b<c.
C
      CALL SYMCONTW(ICORE(IM50),ICORE(I000),IADBLK,ISPIN,IRPIJK)
C
C     CCSD(T)  non-HF calculations without semicanonical orbitals.
C     (ii) Occupied orbital sum.
C     Note : T3FT314O computes contributions to an a<b<c T3 rather than
C     to a<b;c. Therefore, it MUST be called after SYMCONTW.
C
      CALL ZERO(ICORE(ISTART),LENABC)
      CALL T3FT314O(ICORE(IM50),ICORE(ISTART),NFREE,ISPIN,
     1               POPT3(IRPIJK),IRPI,IRPJ,IRPK,IRPIJK,I,J,K)

      ELSE 
C
C     Convert the a<b;c T3 to a<b<c.
C
      CALL SYMCONTW(ICORE(IM50),ICORE(I000),IADBLK,ISPIN,IRPIJK)
C 
      ENDIF
#ifdef _DEBUG_LVLM
      Write(*,*)
      Call checksum("T3IT_TRPS14-0", ICORE(IM50), POPT3(IRREPIJK))
#endif 
C
      DIJK = EVAL(ABSOCC(I,IRPI,ISPIN)) + EVAL(ABSOCC(J,IRPJ,ISPIN))
     1                                  + EVAL(ABSOCC(K,IRPK,ISPIN))

      CALL RMD314(ICORE(IM50),ICORE(I100),POPT3(IRPIJK),DIJK)
C
C ICORE(IM50)   A<B<C ordered T3(C)
C Lets compute the T3(d) terms T2*W +T2*FOV

C#ifdef _INCLUDE
      CALL ZERO(ICORE(I000),LENABC)
      CALL ZERO(ICORE(I140),POPT3(IRPIJK))

      CALL S1S214(ICORE(ISTART),ICORE(I000),IADBLK,ISPIN,I,J,K,
     1            IRPI,IRPJ,IRPK,IRPIJ,IRPIK,IRPJK,IRPIJK,1,.FALSE.)
      CALL S1S214(ICORE(ISTART),ICORE(I000),IADBLK,ISPIN,I,J,K,
     1            IRPI,IRPJ,IRPK,IRPIJ,IRPIK,IRPJK,IRPIJK,2,.FALSE.)
C
      CALL SYMCONTW(ICORE(I140),ICORE(I000),IADBLK,ISPIN,IRPIJK)
      CALL RMD314(ICORE(I140),ICORE(I100),POPT3(IRPIJK),DIJK)
      CALL DAXPY(POPT3(IRPIJK), 1.0D0, ICORE(I140), 1, ICORE(IM50), 1)
C#endif

      IF(T3STOR)THEN
         CALL PUTLIST(ICORE(IM50),IJKVAL,1,1,IRPIJK,1+3*(ISPIN-1))
      ENDIF
#ifdef _DEBUG_LVL0
      CALL DAXPY(POPT3(IRPIJK), -1.0D0, ICORE(I140), 1, ICORE(IM50), 1)
      CALL DAXPY(POPT3(IRPIJK), 1.0D0, ICORE(IM50), 1, ICORE(I140), 1)
      CALL E4TCTDIJK(ICORE(IM50),ICORE(I140),ICORE(I100),
     &               POPT3(IRPIJK),DIJK,
     &               E14,__FILE__)
      Write(*,*)
      Call checksum("T3IT_TRPS14", ICORE(IM50), POPT3(IRREPIJK))
#endif 

      ENDDO
      ENDDO
      ENDDO
      
 980  CONTINUE
      ENDDO
 990  CONTINUE
      ENDDO 
      ENDDO

#ifdef _DEBUG_LVL0
      IF(ISPIN.EQ.1)THEN
      WRITE(6,6000) E14
 6000 FORMAT(' @TRPS14-I, E4TAAA ',F20.12)
      ELSE
      WRITE(6,6010) E14
 6010 FORMAT(' @TRPS14-I, E4TBBB ',F20.12)
      ENDIF
#endif 
      RETURN
      END
