      SUBROUTINE G6AB(T2,T,G,T1,T1A,T1B,GIK,FACT,LAMBDA,CCSD,
     &                TRIP,ISPIN,POP1,POP2,VRT1,VRT2,NT,
     &                DISSYT,NUMSYT,DISSYG,NUMSYG,LISTT,LISTL,
     &                LISTG,IRREP,TMP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL LAMBDA,CCSD,TRIP
      INTEGER DIRPRD,DISSYT,DISSYG,POP1,POP2,VRT1,VRT2
      DIMENSION T2(NUMSYT,1),T(DISSYT,1),G(DISSYG,1),T1(NT,2) 
      DIMENSION POP1(8),POP2(8),VRT1(8),VRT2(8),TMP(1),T1A(1),T1B(1)
      DIMENSION GIK(1)
      COMMON/SYMINF/NSTART,NIRREP,IRREPA(255,2),DIRPRD(8,8)
C
      DATA AZERO,ONE,HALF/0.D0,1.D0,0.5D0/
C
      IF(CCSD.OR.TRIP) THEN
       CALL GETLST(G,1,NUMSYG,1,IRREP,LISTG)
       IF(ISPIN.EQ.1) THEN
        CALL SYMTR1(IRREP,POP1,VRT2,DISSYG,G,TMP,TMP(1+DISSYG),
     &              TMP(1+2*DISSYG))
       ENDIF
      ELSE
       CALL ZERO(G,NUMSYG*DISSYG)
      ENDIF
C
      IPASS=1
C
C   IPASS =1 CORRESPONDS TO LAMBDA(K,A) T(IJ,EA)
C   IPASS =2 CORRESPONDS TO T(K,C) LAMBDA(IJ,EA)
C
1     CONTINUE
C
C  SET PARAMETERS FOR LOOP
C
      IF(IPASS.EQ.1) THEN
       LIST1=LISTT
      ELSE
       LIST1=LISTL
      ENDIF
C
C    GET FIRST T2 AMPLITUDES FROM DISK
C
C    IF ISPIN=1 TRANSPOSE FROM A,b ; I,j To I,j ; A,b AND THEN TO I,j ; b,A
C    IF ISPIN=2 TRANSPOSE FROM A,b ; I,j TO I,j ; A,b
C
      CALL GETLST(T,1,NUMSYT,1,IRREP,LIST1)
C
C IF CCSD THE FORM ON  THE FIRST PASS TAU AMPLITUDES
C
      IF(IPASS.EQ.1.AND.CCSD) THEN
       IF(ISPIN.EQ.1) THEN
        CALL FTAU(T,T1A,T1B,DISSYT,NUMSYT,POP1,POP2,VRT1,VRT2,
     &            IRREP,3,ONE)
       ELSE
        CALL FTAU(T,T1A,T1B,DISSYT,NUMSYT,POP2,POP1,VRT2,VRT1,
     &            IRREP,3,ONE)
       ENDIF
      ENDIF
C
      CALL TRANSP(T,T2,NUMSYT,DISSYT)
      IF(ISPIN.EQ.1) THEN
       CALL SYMTR1(IRREP,VRT1,VRT2,NUMSYT,T2,TMP,TMP(1+NUMSYT),
     &             TMP(1+2*NUMSYT))
      ENDIF
C
C
C     NOW PERFORM MULTIPLICATION
C
C  IOFF OFFSET IN T1
C  JOFFT2 OFFSET IN VRT VRT BLOCK OF T2
C  JOFFG OFFSET IN OCC VIRT BLOCK OF G
C
      IOFF=1
      JOFFT2=1
      JOFFG=1
C
      DO 100 IRREPJ=1,NIRREP
C
C  OCCUPIED AND VIRTUAL ORBITALS FOR MULTIPLICATION
C
      NOCCJ=POP1(IRREPJ)
      NVRTJ=VRT1(IRREPJ) 
      IRREPI=DIRPRD(IRREP,IRREPJ)
      NVRTI=VRT2(IRREPI)
C
C  IF ANY OF THE POPULATION IS ZERO, SKIP LOOP
C
      IF(MIN(NVRTI,NVRTJ,NOCCJ).NE.0) THEN
C
       CALL XGEMM('N','N',NUMSYT*NVRTI,NOCCJ,NVRTJ,FACT,T2(1,JOFFT2),
     &            NUMSYT*NVRTI,T1(IOFF,IPASS),NVRTJ,ONE,G(1,JOFFG),
     &            NUMSYT*NVRTI)
      ENDIF
C
C   UPDATE POINTERS
C
      IOFF=IOFF+NVRTJ*NOCCJ
      JOFFT2=JOFFT2+NVRTI*NVRTJ
      JOFFG=JOFFG+NVRTI*NOCCJ
C
100   CONTINUE
C
      IPASS=IPASS+1
      IF(LAMBDA.AND.IPASS.EQ.2) GO TO 1
C
C  IF ISPIN=1 THEN
C  TRANSPOSE INDICES SINCE WE HAVE CALCULATES -G(Ij,aK) = G(Ij,Ka)
C  WITH AN ORDERING OF  IjaK
C
C  FOR ISPIN=2 DO NOTHING
C
      IF(ISPIN.EQ.1) THEN
       CALL SYMTR1(IRREP,VRT2,POP1,DISSYG,G,TMP,TMP(1+DISSYG),
     &             TMP(1+2*DISSYG))
      ENDIF
C
C  ADDITIONAL TERMS FOR CCSD
C
      IF(CCSD) THEN
C            
C  TRANSPOSE G(Ij,A,k) FOR ISPIN=2
C
       IF(ISPIN.EQ.2) THEN
        CALL SYMTR1(IRREP,VRT2,POP1,DISSYG,G,TMP,TMP(1+DISSYG),
     &              TMP(1+2*DISSYG))
       ENDIF
C
C  GET V(IJ,KM) FROM DISK
C
       CALL GETLST(T2,1,NUMSYT,2,IRREP,153)
C
C   FOR ISPIN=2, TRANSPOSE
C
       IF(ISPIN.EQ.2) THEN
C
        CALL SYMTR1(IRREP,POP2,POP1,NUMSYT,T2,TMP,TMP(1+NUMSYT),
     &              TMP(1+2*NUMSYT))
       ENDIF
C
C  FIRST TERM INVOVES V(IJ,KM)*T(M,A)
C
       IOFFV=1
       IOFFG=1
       IOFFT=1
       DO 200 IRREPJ=1,NIRREP
C
C   ORBITAL POPULATION FOR MULTIPLICATION
C
        NOCCJ=POP2(IRREPJ)
        NVRTJ=VRT2(IRREPJ)
        IRREPI=DIRPRD(IRREP,IRREPJ)
        NOCCI=POP1(IRREPI)
C
C   IF ANY OF THE OCCUPATIONS IS ZERO, SKIP MULTIPLICATION
C
        IF(MIN(NVRTJ,NOCCJ,NOCCI).NE.0) THEN
C
         IF(ISPIN.EQ.1) THEN
          CALL XGEMM('N','T',NUMSYT*NOCCI,NVRTJ,NOCCJ,HALF,
     &               T2(1,IOFFV),NUMSYT*NOCCI,T1B(IOFFT),NVRTJ,
     &               ONE,G(1,IOFFG),DISSYG*NOCCI)
         ELSE
          CALL XGEMM('N','T',NUMSYT*NOCCI,NVRTJ,NOCCJ,HALF,
     &               T2(1,IOFFV),NUMSYT*NOCCI,T1A(IOFFT),NVRTJ,
     &               ONE,G(1,IOFFG),DISSYG*NOCCI)
         ENDIF
        ENDIF
C
C  UPDATE OFFSETS
C
       IOFFV=IOFFV+NOCCI*NOCCJ
       IOFFG=IOFFG+NOCCI*NVRTJ
       IOFFT=IOFFT+NOCCJ*NVRTJ
C
200   CONTINUE
C
C   FOR ISPIN=2, TRANSPOSE
C
       IF(ISPIN.EQ.2) THEN
C
        CALL SYMTR1(IRREP,POP1,VRT2,DISSYG,G,TMP,TMP(1+DISSYG),
     &              TMP(1+2*DISSYG))
       ENDIF
C
C  ADD THE CONTRIBUTION - G(IK) T(JA)
C
       CALL GETLST(GIK,1,1,1,ISPIN,191)
C
C  CALL G6TAU IN ORDER TO ADD THIS CONTRBIBUTION
C 
       IF(ISPIN.EQ.1) THEN
        CALL G6TAU(G,GIK,T1B,DISSYG,NUMSYG,POP1,POP2,
     &             VRT2,IRREP,3)
       ELSE
        CALL G6TAU(G,GIK,T1A,DISSYG,NUMSYG,POP1,POP2,
     &             VRT2,IRREP,4)
       ENDIF
      ENDIF
C
C  SAVE GAMMA ON LIST
C
      CALL PUTLST(G,1,NUMSYG,2,IRREP,LISTG)
C
      RETURN
      END
