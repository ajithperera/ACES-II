      SUBROUTINE RCL_Q2AB(T,W,Z,T1A,T1B,ISPIN,POP1,POP2,VRT1,
     &                VRT2,NOCCSQ,DISSYW,DISSYT,NUMSYW,NUMSYT,
     &                IRREP,TMP,IUHF,FACT,IMULT)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
      INTEGER DISSYT, DISSYW, DIRPRD,POP1,POP2,VRT1,VRT2
      LOGICAL  MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC,
     &            CC2,RCCD,DRCCD
      DIMENSION W(DISSYW,NUMSYW),T(DISSYT,NUMSYT),Z(NOCCSQ)
      DIMENSION TMP(1)
      DIMENSION POP1(8),POP2(8),T1A(1),T1B(1),VRT1(8),VRT2(8) 
      COMMON /SYMINF/ NSTART,NIRREP,IRREPA(255),IRREPB(255),DIRPRD(8,8)
      COMMON/METH/MBPT2,MBPT3,M4DQ,M4SDQ,M4SDTQ,CCD,QCISD,CCSD,UCC,
     &            CC2,RCCD,DRCCD
      COMMON /FLAGS/  IFLAGS(100)
      COMMON /FLAGS2/ IFLAGS2(500)
C
      DATA ONE,ONEM,TWO /1.0D0,-1.D0,2.D0/,HALF /0.5D0/
C
C SPIN ADAPTED CODE FOR RHF
C
      IF(IUHF.EQ.0) THEN

       IF (RCCD) THEN
          IF (IMULT .EQ. 1) THEN
              CALL GETLST(W,1,NUMSYW,2,IRREP,197)
          ELSE IF (IMULT .EQ. 2) THEN
              CALL GETLST(W,1,NUMSYW,2,IRREP,198)
          ENDIF 

       ELSE IF (DRCCD) THEN

C If antisymmetric  <ab||ij> is used
             
          CALL GETLST(W,1,NUMSYW,2,IRREP,16)
          CALL SPINAD1(IRREP,POP1,DISSYW,W,TMP,TMP(1+DISSYW))

C If Coulomb only integrals are used

CSSS       CALL DSCAL(NUMSYW*DISSYW,TWO,W,1)
       ENDIF 
      ELSE 
C
C      PICK UP FIRST THE RELEVANT T2 AND W PIECES
C
      CALL GETLST(W,1,NUMSYW,2,IRREP,16)

      ENDIF 

      IF (IMULT .EQ. 2 .AND. IUHF .EQ. 0) THEN
         CALL GETLST(T,1,NUMSYT,1,IRREP,44)
      ELSE 
         CALL GETLST(T,1,NUMSYT,1,IRREP,46)
      ENDIF 

#ifdef _DEBUG_LVL0
      call checksum("@q2b-W:",W,NUMSYW*DISSYW)
      call checksum("@q2b-T:",T,NUMSYT*DISSYT)
#endif

      IF(IUHF.EQ.1.AND.ISPIN.EQ.1) THEN 
       CALL SYMTR1(IRREP,POP1,POP2,DISSYW,W,TMP,TMP(1+DISSYW),
     &             TMP(1+2*DISSYW))
       CALL SYMTR1(IRREP,POP1,POP2,DISSYT,T,TMP,TMP(1+DISSYT),
     &             TMP(1+2*DISSYT))
      ENDIF
C
         JOFF=1
         IOFF=1
         DO 90 IRREPI=1,NIRREP
C          
C        GET OCCUPATION NUMBER FOR JRREP     
C
           NOCCI=POP1(IRREPI)
C
C
C        IF ZERO, NOTHING TO COMPUTE
C
           IF(NOCCI.EQ.0) GO TO 90
C
C        DETERMINE KRREP WHOSE DIRECT PRODUCT WITH JRREP GIVES IRREP
C
           IRREPJ=DIRPRD(IRREP,IRREPI)
C
C        GET OCCUPATION NUMBER FOR KRREP
C
           NOCCJ=POP2(IRREPJ)
C
C        IF ZERO, NOTHING TO COMPUTE
C
           IF(NOCCJ.EQ.0) GO TO 80
C
            CALL XGEMM('T','N',NOCCI,NOCCI,DISSYW*NOCCJ,FACT,
     &                 W(1,JOFF),NOCCJ*DISSYW,T(1,JOFF),      
     &                 NOCCJ*DISSYW,ONE,Z(IOFF),NOCCI)

           JOFF=JOFF+NOCCJ*NOCCI
80         CONTINUE
C
C         UPDATE THE OFFSET FOR THE INTERMEDIATE Z
C
            IOFF=IOFF+POP1(IRREPI)**2
90        CONTINUE
C
      RETURN
      END
