      SUBROUTINE TRIIII(ICORE, MAXCOR, IUHF)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      LOGICAL RHF,DOALL,NOABCD,ABIJ,LAST,FIRST
      INTEGER DIRPRD,POP,VRT
      CHARACTER*80 FNAME
C
#include <maxbasfn.par>

      DIMENSION ICORE(MAXCOR)
      DIMENSION ISIZE2(8),ISIZE3(8),ISIZE4(8),IOFFI(8),
     &          IOFFAO(8),IOFFMO(8,2), CMO(maxbasfn*maxbasfn)
      DIMENSION NFIRST(8),NSTART(8),NEND(8)
C
      COMMON/MACHSP/IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON/INFO/NOCCO(2),NVRTO(2)
      COMMON/INFO2/NBASIS,NBAS(8),NMO(8),POP(8,2),VRT(8,2)
      COMMON/SYMINF/NDUMMY,NIRREP,IRREPA(255,2),DIRPRD(8,8)
      COMMON/AOOFST/INDOCC(8,2)
      COMMON/DOINTS/DOALL,ABIJ,NOABCD
C
      NNP1O2(I)=(I*(I+1))/2
C
      CALL GETREC(20,'JOBARC','SYMPOPOA',NIRREP,POP(1,1))
      CALL GETREC(20,'JOBARC','SYMPOPVA',NIRREP,VRT(1,1))
C
      IF(IUHF.EQ.0) THEN
       DO IRREP=1,NIRREP
          POP(IRREP,2)=POP(IRREP,1)
          VRT(IRREP,2)=VRT(IRREP,1)
       ENDDO
      ELSE
       CALL GETREC(20,'JOBARC','SYMPOPOB',NIRREP,POP(1,2))
       CALL GETREC(20,'JOBARC','SYMPOPVB',NIRREP,VRT(1,2))
      ENDIF
C
C CREATE LOOK UP VECTOR FOR IRREP OF EACH AO
C
CSSS      MAXCOR =300645026 
      NCOMP = NOCCO(1)+NVRTO(1)
      NBASIS = NCOMP
      ISYMAO = 1
      IREORD = ISYMAO+NBASIS
      ISTART = IREORD+(1+IUHF)*NBASIS
      IJTRN  = NNP1O2(NBASIS)
C
      IJKLTRN  = NNP1O2(IJTRN)
      NSIZE_AO = IJKLTRN 
C
      IF(MOD(ISTART,2).NE.1) ISTART=ISTART+1
C
      NCOMP=NOCCO(1)+NVRTO(1)
      DO IRREP=1,NIRREP
       NBAS(IRREP)=POP(IRREP,1)+VRT(IRREP,1)
        NMO(IRREP)=NBAS(IRREP) 
      ENDDO
C
      CALL PROCEVEC(ICORE, MAXCOR, IUHF, NBASIS, NBASIS)
      CALL DCOPY(NBASIS*NBASIS*(1+IUHF), ICORE, 1, CMO, 1)
C
      IND =0
      DO 1 IRREP=1,NIRREP
       DO 1 I=1,NBAS(IRREP)
        IND=IND+1
        ICORE(IND)=IRREP
1     CONTINUE
C
C FILL REORDER VECTOR FOR WRITING INTEGRALS TO DISK
C
      IND=IREORD-1
      DO 5 ISPIN=1,MIN(IUHF+1,2)
       IOFFOCC=0
       IOFFVRT=NOCCO(ISPIN)
       DO 4 IRREP=1,NIRREP
        DO 2 IOCC=1,POP(IRREP,ISPIN)
         IND=IND+1
         ICORE(IND)=IOCC+IOFFOCC
2       CONTINUE
        IOFFOCC=IOFFOCC+POP(IRREP,ISPIN)
        DO 3 IVRT=1,VRT(IRREP,ISPIN)
         IND=IND+1
         ICORE(IND)=IVRT+IOFFVRT
3       CONTINUE
        IOFFVRT=IOFFVRT+VRT(IRREP,ISPIN)
4      CONTINUE
5     CONTINUE
C
C DETERMINE VALUE OF RHF FLAG
C
      RHF=IUHF.EQ.0
C
C LOOP OVER SPIN CASES
C
      DO 1000 ISPIN=1,MIN(1+IUHF,2)
C
C OPEN INTEGRAL FILE IIII (UNIT 10)
C
       LUINT=10
       CALL GFNAME('IIII    ',FNAME,ILENGTH)
       OPEN(LUINT,FILE=FNAME(1:ILENGTH),STATUS='OLD',
     &      FORM='UNFORMATTED',ACCESS='SEQUENTIAL')
       CALL LOCATE(LUINT,'TWOELSUP')
C
C FILL NFIRST
C
       IF(NOABCD) THEN
        CALL ICOPY(NIRREP,POP(1,ISPIN),1,NFIRST,1)
       ELSE
        CALL ICOPY(NIRREP,NMO,         1,NFIRST,1)
       ENDIF
C
C   NSTART AND NEND PARAMETER FOR FULL IN-CORE TRANSFORMATION
C
       DO 6 IRREP=1,NIRREP
        NSTART(IRREP)=1
        NEND(IRREP)=NFIRST(IRREP)
6      CONTINUE
C
C CALCULATE SIZE OF SYMMETRIC TRIANGULAR ARRAY FOR EACH IRREP
C
       CALL IZERO(IOFFI,8)
       CALL IZERO(ISIZE2,8)
       CALL IZERO(ISIZE3,8)
       CALL IZERO(ISIZE4,8)
       CALL IZERO(IOFFAO,8)
       CALL IZERO(IOFFMO,16)
       NSIZE=0
       MSIZE=0
       IAO=0
       IMO=0
C
       DO 10 IRREP=1,NIRREP
C
        IOFFAO(IRREP)=IAO
        IOFFMO(IRREP,1)=IMO
        IOFFMO(IRREP,2)=IMO+NCOMP
        IOFFI(IRREP)=NSIZE
        ISIZE2(IRREP)=NNP1O2(NBAS(IRREP))
        ISIZE3(IRREP)=ISIZE2(IRREP)*NBAS(IRREP)
        ISIZE4(IRREP)=ISIZE3(IRREP)*NFIRST(IRREP)
        NSIZE=NSIZE+ISIZE4(IRREP)
        MSIZE=MAX(MSIZE,ISIZE3(IRREP),2*NBAS(IRREP)*NBAS(IRREP))
        IAO=IAO+NBAS(IRREP)
        IMO=IMO+NMO(IRREP)
C
10     CONTINUE
C
       ILNBUF=600
C
       I000=ISTART
       I010=I000+NSIZE*IINTFP
C
C       I015=I010+IINTFP*NBASIS
C       I020=I015+NSIZE_AO
C
       I020=I010+IINTFP*NBASIS
C  
       I030=I020+ILNBUF*IINTFP
       IEND1=I030+ILNBUF
       IEND2=I015+IINTFP*MSIZE
       IEND=MAX(IEND1,IEND2)

C
C CHECK IF FULL IN-CORE TRANSFORMATION IS POSSIBLE
C
       Write(*,'(t3,a,a,i12,a,i12)'), "Memory needed 
     & and available to test for in-core or
     & out-of-core- ", "needed: ", iend, " available: ",maxcor
C 
       IF(IEND.GE.MAXCOR) THEN
C
C MULTIPLE PASSES ARE REQUIRED (OUT-OF-CORE ALGORITHM)
C
        Print*, "out of core"
C
C        I015=ISTART
C        I010 = I015  + NSIZE_AO
C
        I010=ISTART
        I020=I010+IINTFP*NBASIS
        I030=I020+IINTFP*ILNBUF
        IEND1=I030+ILNBUF
        IEND2=I015+IINTFP*MSIZE
        IEND=MAX(IEND1,IEND2)
        IF(MOD(IEND,2).NE.1) IEND=IEND+1
        I000  = IEND
C
C MXCOR IS MAXIMUM OF AVAILABLE CORE MEMORY
C
        MXCOR=MAXCOR-IEND
C
C SET FIRST ORBITAL TO 1
C
        JSTART=1
        NPASS1=0
C
C SET JEND TO TOTAL NUMBER OF ALL (OCCUPIED) ORBITALS
C
        JEND=0
        DO 915 IRREP=1,NIRREP
         JEND=JEND+NFIRST(IRREP)
915     CONTINUE
C
       ELSE
C
C FULL INCORE ALGORITHM IS POSSIBLE, SET LAST TO TRUE
C
        Print*, "in core"
        NPASS1 = 1 
        NSIZE1=NSIZE
        LAST=.TRUE.
        GO TO 950
C
       ENDIF
C
900    CONTINUE
C
C RESET MXCOR1
C
       MXCOR1=MXCOR
C
C DETERMINE NSTART AND NEND FOR OUT-OF-CORE TRANSFORMATION. NOTE
C THE OUT-OF-CORE TRANSFORMATION IS DONE AS A MULTIPLE PASS
C ALGORITHM WITH SEVERAL READS OF THE IIII FILE
C
C SET NSIZE1 TO ZERO
C
       NSIZE1=0
C
C  ZERO NEND, NSTART SHOULD STILL BE 1
C
       CALL IZERO(NEND,8)
       CALL IZERO(IOFFI,8)
       DO 901 IRREP=1,NIRREP
        NSTART(IRREP)=1
901    CONTINUE
C
C  DETERMINE STARTING ADDRESS USING JSTART
C
       JST=JSTART
       DO 910 IRREP=1,NIRREP
        JRREP=IRREP
        IF(JST.LE.NFIRST(IRREP)) GO TO 920
        JST=JST-NFIRST(IRREP)
910    CONTINUE
C
920    CONTINUE
C
       NSTART(JRREP)=JST
C
       FIRST=.TRUE.
C
C WITHIN THIS IRREP THERE ARE NEND+1-NSTART ORBITALS LEFT
C DETERMINE HOW MANY FIT INTO CORE
C
930    CONTINUE
C
       NLEFT=NFIRST(JRREP)+1-NSTART(JRREP)
C
C DETERMINE HOW MUCH CORE MEMORY IS REQUIRED
C
       IF(ISIZE3(JRREP).NE.0) THEN
        NORB=MXCOR1/(ISIZE3(JRREP)*IINTFP)
        IF(NORB.EQ.0.AND.FIRST) THEN
         write(*,*) ' @TRIIII-F, Sorry, there is not enough memory !'
         CALL ERREX
        ENDIF
       ELSE
        NORB=NMO(JRREP)+1
       ENDIF
C
       Print*, " Nleft and Norb", Nleft, Norb
       FIRST=.FALSE.
       NEND(JRREP)=NSTART(JRREP)+MIN(NLEFT,NORB)-1
       MXCOR1=MXCOR1-MIN(NLEFT,NORB)*IINTFP*ISIZE3(JRREP)
       JSTART=JSTART+MIN(NLEFT,NORB)
       IOFFI(JRREP)=NSIZE1
       NSIZE1=NSIZE1+MIN(NLEFT,NORB)*ISIZE3(JRREP)
       LAST=.FALSE.
       IF(JSTART.GT.JEND) LAST=.TRUE.
C
C CHECK IF MORE IRREPS HAVE TO BE CONSIDERED IN THIS PATH
C
       IF((.NOT.LAST).AND.(NORB.GT.NLEFT)) THEN
        JRREP=JRREP+1
        NSTART(JRREP)=1
        GO TO 930
       ENDIF
C
950    CONTINUE
C
C This is only a timing test and so lets put zeros for eigenvectors.
C
CSSS       Print*, I000, I015, I010, I020, I030
CSSS       CALL LOAD1(CMO,ICORE(I000),ICORE(I010),ICORE(I015),
CSSS     &            ICORE(I020),
C
       Print*, NPASS1, Nsize
       CALL LOAD1(CMO,ICORE(I000),ICORE(I010),ICORE(I020),

C                 CMO,        W,          W2,         DBuf,
C
     &            ICORE(I030),ICORE(ISYMAO),NBAS,
C
c                 Ibuf,       isymao       , nbas
C
     &            NFIRST,NSTART,NEND,ISIZE3,IOFFAO,
C
C                 s,       s,   s,   isize, s,
C
     &            IOFFI,NSIZE1,ILNBUF,ISPIN,LUINT,nPass1,LAST,
     &            NBASIS, NSIZE_AO)
C
C                 s,    nsize, s,   s,      s,    s,    s
C
       IF(.NOT.LAST) GO TO 900
C
1000   CONTINUE
C
       RETURN
       END
