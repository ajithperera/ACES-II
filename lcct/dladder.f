C
      SUBROUTINE DLADDER(ICORE,MAXCOR,IUHF,IRROMEGA,ITYPE,
     &                   LISTT0,LISTW0,LISTZ0,ISIDE)
C
C THIS SUBROUTINE CALCULATES THE HOLE-HOLE LADDER CONTRIBUTION
C
C     Z(ab,ij) = SUM T(ab,mn) * <mn||ij>  [ITYPE=1] 
C                m,n
C
C     Z(ab,ij) = SUM W(ab,ef) * T(ef,ij)  [ITYPE=6]
C                e,f
C
CEND
      IMPLICIT INTEGER (A-Z)
      DOUBLE PRECISION ONE,ONEM,ZILCH,FACT
      CHARACTER*1 MATTYP(2)
      LOGICAL RHF
C
      DIMENSION ICORE(MAXCOR)
C
      COMMON /MACHSP/ IINTLN,IFLTLN,IINTFP,IALONE,IBITWD
      COMMON /SYMINF/ NSTART,NIRREP,IRREPS(255,2),DIRPRD(8,8)
      COMMON /SYM/ POP(8,2),VRT(8,2),NT(2),NFMI(2),NFEA(2)
      COMMON /SYMPOP/ IRPDPD(8,22),ISYTYP(2,500),ID(18)
C
      DATA ONE  /1.0/
      DATA ONEM /-1.0/
      DATA ZILCH/0.0/
      DATA MATTYP/'N','T'/
C
      DO 50 ISPIN=3,3-2*IUHF,-1
C
C ALPHA-BETA SPIN CASE
C
       DO 100 IRREPZR=1,NIRREP
C
C LOOP OVER KET IRREPS OF *TARGET*.  THIS IS NOT THE SAME AS THE
C  IRREPS OF THE INTEGRALS AND AMPLITUDES UNLESS IRROMEGA=1.
C
        IRREPZL=DIRPRD(IRREPZR,IRROMEGA)
        LISTW=LISTW0+ISPIN-1
        LISTT=LISTT0+ISPIN-1
        LISTZ=LISTZ0+ISPIN-1
        IF(ITYPE.EQ.1)THEN
         IRREPW=IRREPZR
        ELSE
         IRREPW=IRREPZL
        ENDIF
        DISSYW=IRPDPD(IRREPW,ISYTYP(1,LISTW))
        NUMDSW=IRPDPD(IRREPW,ISYTYP(2,LISTW)) 
        DISSYZ=IRPDPD(IRREPZL,ISYTYP(1,LISTZ))
        NUMDSZ=IRPDPD(IRREPZR,ISYTYP(2,LISTZ))
        DISSYT=DISSYZ
        NUMDST=NUMDSZ
        I000=1
        I010=I000+IINTFP*DISSYZ*NUMDSZ
        I020=I010+IINTFP*DISSYT*NUMDST
C
C USE GENERAL ALGORITHM ALLOWING BOTH IN-CORE AND OUT-OF-CORE
C SOLUTIONS
C
        FACT=ZILCH
        CORLFT=MAXCOR-I020+1
        IF(DISSYW.NE.0)THEN
         NINCOR=CORLFT/(DISSYW*IINTFP)
         IF(NINCOR.EQ.0)THEN
          WRITE(6,1000)
1000      FORMAT(T3,'@DLADDER-F, Not enough memory for ladders.')
          CALL INSMEM('DLADDER',DISSYW*IINTFP,CORLFT)
         ENDIF
        ELSE
         NINCOR=DISSYW
        ENDIF
        IOFFT=I010
        IOFFZ=I000
        NLEFT=NUMDSW
        NFIRST=1
        CALL GETLST(ICORE(I010),1,NUMDST,1,IRREPZR,LISTT)
1       NREAD =MIN(NLEFT,NINCOR)
        CALL GETLST(ICORE(I020),NFIRST,NREAD,1,IRREPW,LISTW)
        IF(ITYPE.EQ.1)THEN
         CALL XGEMM('N',MATTYP(ISIDE),DISSYZ,NREAD,NUMDSZ,ONE,
     &              ICORE(IOFFT),DISSYT,ICORE(I020),DISSYW,FACT,
     &              ICORE(IOFFZ),DISSYZ)
         IOFFZ=IOFFZ+DISSYZ*NREAD*IINTFP
        ELSE
         IF(ISIDE.EQ.1)THEN
          CALL XGEMM ('N','N',DISSYZ,NUMDSZ,NREAD,ONE,ICORE(I020),
     &                DISSYW,ICORE(IOFFT),DISSYT,FACT,ICORE(IOFFZ),
     &                DISSYZ)
          IOFFT=IOFFT+IINTFP*NREAD
          FACT =ONE
         ELSE
          CALL XGEMM ('T','N',NREAD,NUMDSZ,DISSYZ,ONE,ICORE(I020),
     &                DISSYW,ICORE(IOFFT),DISSYT,FACT,ICORE(IOFFZ),
     &                DISSYZ)
          IOFFZ=IOFFZ+NREAD*IINTFP
         ENDIF
        ENDIF
        NFIRST=NFIRST+NREAD
        NLEFT =NLEFT -NREAD
        IF(NLEFT.NE.0)GOTO 1
        CALL GETLST(ICORE(I010),1,NUMDSZ,1,IRREPZR,LISTZ)
C         
        CALL SAXPY (NUMDSZ*DISSYZ,ONE,ICORE(I010),1,ICORE(I000),1)
        CALL PUTLST(ICORE(I000),1,NUMDSZ,1,IRREPZR,LISTZ)
100    CONTINUE
50    CONTINUE
C
      RETURN
      END
